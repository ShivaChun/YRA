<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>自地自建評估計算書</title>

    <!-- 1. 引入 Babel -->
    <script src="https://unpkg.com/@babel/standalone@7.23.0/babel.min.js"></script>

    <!-- 2. 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Tailwind Config -->
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['GenYoGothic', 'sans-serif'],
            },
            cursor: {
              grab: 'grab',
              grabbing: 'grabbing',
            },
            colors: {
               stone: { 50: '#fafaf9', 100: '#f5f5f4', 200: '#e7e5e4', 300: '#d6d3d1', 400: '#a8a29e', 500: '#78716c', 600: '#57534e', 700: '#44403c', 800: '#292524', 900: '#1c1917' }
            }
          },
        },
      }
    </script>

    <style>
      @font-face {
        font-family: 'GenYoGothic';
        src: local('GenYoGothic'), local('源樣黑體'), local('Noto Sans TC');
      }
      body {
        background-color: #f5f5f4;
        font-family: 'GenYoGothic', sans-serif;
        overflow-x: hidden;
        overscroll-behavior-y: none; 
      }
      .num-font {
        font-variant-numeric: tabular-nums;
      }
      .no-scrollbar::-webkit-scrollbar {
        display: none;
      }
      .no-scrollbar {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }
      @keyframes riseUp {
        0% { transform: translate3d(var(--tx), var(--ty), -50px); opacity: 0; }
        100% { transform: translate3d(var(--tx), var(--ty), var(--tz)); opacity: 1; }
      }
      @keyframes slideUp {
        from { transform: translateY(100%); }
        to { transform: translateY(0); }
      }
      .animate-slide-up {
        animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      }
      @keyframes pulse-ring {
        0% { transform: scale(0.8); opacity: 0.8; }
        100% { transform: scale(1.5); opacity: 0; }
      }
      .animate-pulse-ring::before {
        content: '';
        position: absolute;
        left: -50%; top: -50%; width: 200%; height: 200%;
        border-radius: 50%;
        border: 2px solid #0ea5e9;
        animation: pulse-ring 1.5s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
      }
      /* Custom Cursor for Pan */
      .cursor-pan {
          cursor: grab;
      }
      .cursor-pan:active {
          cursor: grabbing;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
      /** @jsxRuntime classic */
      /** @jsx React.createElement */
      import React, { useState, useMemo, useEffect, useRef, useCallback } from 'https://esm.sh/react@18.2.0';
      import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client';
      import { 
        MapPin, Ruler, FileText, Info, Building2, Car, Layers, 
        ArrowDownUp, AlertTriangle, Bike, Compass, Plus, Trash2, 
        ChevronDown, ChevronUp, ChevronRight, ChevronLeft, Map, LayoutDashboard, Settings2, 
        Pencil, RefreshCw, RotateCw, Eye, Maximize, ToggleLeft, 
        ToggleRight, Box, Sun, Moon, ZoomIn, ZoomOut, PanelRightClose, PanelRightOpen,
        AlignLeft, AlignCenter, AlignRight, AlignVerticalJustifyCenter, ArrowUpToLine, ArrowDownToLine,
        Edit3, RotateCcw, Undo2, CheckCircle2, GripHorizontal, Copy, Move, Maximize2, Lock, Unlock,
        Grid, X, LayoutTemplate, MoreVertical, Hexagon, CheckSquare, Square, Scaling, Settings,
        ParkingCircle, Warehouse, MousePointer2, PlusCircle, Shovel, MinusCircle, MousePointerClick, Crosshair,
        CornerUpLeft, Grip, Hand
      } from 'https://esm.sh/lucide-react@0.263.1';

      // --- Helper Functions ---
      const formatNum = (num, digits = 2) => {
        return new Intl.NumberFormat('zh-TW', {
          minimumFractionDigits: digits,
          maximumFractionDigits: digits
        }).format(num || 0);
      };

      const toSqm = (ping) => ping * 3.3058;
      const toPing = (sqm) => sqm * 0.3025;
      
      const generateSvgPath = (points, curves, scale = 1, offsetX = 0, offsetY = 0) => {
          if (!points || points.length === 0) return "";
          let d = `M ${(points[0].x * scale) + offsetX} ${(points[0].y * scale) + offsetY}`;
          for (let i = 0; i < points.length; i++) {
              const nextP = points[(i + 1) % points.length];
              const curve = curves ? curves[i] : null;
              if (curve) {
                  d += ` Q ${(curve.x * scale) + offsetX} ${(curve.y * scale) + offsetY}, ${(nextP.x * scale) + offsetX} ${(nextP.y * scale) + offsetY}`;
              } else {
                  d += ` L ${(nextP.x * scale) + offsetX} ${(nextP.y * scale) + offsetY}`;
              }
          }
          d += " Z";
          return d;
      };

      const calculatePolygonArea = (points) => {
          if (!points || points.length < 3) return 0;
          let area = 0;
          for (let i = 0; i < points.length; i++) {
              const j = (i + 1) % points.length;
              area += points[i].x * points[j].y;
              area -= points[j].x * points[i].y;
          }
          return Math.abs(area) / 2;
      };

      const getPolygonCentroid = (points) => {
          if (!points || points.length === 0) return { x: 0, y: 0 };
          let cx = 0, cy = 0, area = 0;
          for (let i = 0; i < points.length; i++) {
              const j = (i + 1) % points.length;
              const cross = points[i].x * points[j].y - points[j].x * points[i].y;
              cx += (points[i].x + points[j].x) * cross;
              cy += (points[i].y + points[j].y) * cross;
              area += cross;
          }
          area /= 2;
          if (area === 0) {
              const sum = points.reduce((acc, p) => ({x: acc.x + p.x, y: acc.y + p.y}), {x:0, y:0});
              return { x: sum.x / points.length, y: sum.y / points.length };
          }
          return { x: cx / (6 * area), y: cy / (6 * area) };
      };

      const getPolygonBounds = (points) => {
          if (!points || points.length === 0) return null;
          let minX = points[0].x, maxX = points[0].x, minY = points[0].y, maxY = points[0].y;
          for (let i = 1; i < points.length; i++) {
              const p = points[i];
              if (p.x < minX) minX = p.x;
              if (p.x > maxX) maxX = p.x;
              if (p.y < minY) minY = p.y;
              if (p.y > maxY) maxY = p.y;
          }
          return { minX, maxX, minY, maxY };
      };

      const scalePolygon = (points, curves, scale, centroid) => {
          if (!points) return { points: null, curves: null };
          const center = centroid || getPolygonCentroid(points);
          const newPoints = points.map(p => ({
              x: (p.x - center.x) * scale + center.x,
              y: (p.y - center.y) * scale + center.y
          }));
          let newCurves = null;
          if (curves) {
              newCurves = {};
              Object.keys(curves).forEach(k => {
                  const cp = curves[k];
                  newCurves[k] = {
                      x: (cp.x - center.x) * scale + center.x,
                      y: (cp.y - center.y) * scale + center.y
                  };
              });
          }
          return { points: newPoints, curves: newCurves };
      };

      const getSegmentNormal = (p1, p2, centroid) => {
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const len = Math.sqrt(dx * dx + dy * dy);
          if (len === 0) return { x: 0, y: 0 };
          
          let nx = -dy / len;
          let ny = dx / len;
          
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          const toCentroidX = centroid.x - midX;
          const toCentroidY = centroid.y - midY;
          
          // Ensure normal points inward
          if (nx * toCentroidX + ny * toCentroidY < 0) {
              nx = -nx;
              ny = -ny;
          }
          return { x: nx, y: ny };
      };

      const getLineIntersection = (p1, p2, p3, p4) => {
          const denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
          if (denom == 0) return null;
          const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;
          return { x: p1.x + ua * (p2.x - p1.x), y: p1.y + ua * (p2.y - p1.y) };
      };

      const discretizePolygon = (points, curves, steps = 10) => {
          if (!curves) return { points: points, edgeMap: points.map((_, i) => i) };
          const newPoints = [];
          const edgeMap = [];
          for (let i = 0; i < points.length; i++) {
              const p1 = points[i];
              const p2 = points[(i + 1) % points.length];
              const curve = curves[i];
              if (curve) {
                  for (let j = 0; j < steps; j++) {
                      const t = j / steps;
                      const invT = 1 - t;
                      const x = invT * invT * p1.x + 2 * invT * t * curve.x + t * t * p2.x;
                      const y = invT * invT * p1.y + 2 * invT * t * curve.y + t * t * p2.y;
                      newPoints.push({ x, y });
                      edgeMap.push(i);
                  }
              } else {
                  newPoints.push(p1);
                  edgeMap.push(i);
              }
          }
          return { points: newPoints, edgeMap };
      };

      const offsetPolygon = (points, edgeTypes, depths, frontageIndices, curves) => {
          if (!points || points.length < 3) return null;
          
          // 1. Discretize if curves exist
          const { points: densePoints, edgeMap } = discretizePolygon(points, curves, 15);
          
          const centroid = getPolygonCentroid(densePoints); // Use dense centroid
          
          const shiftedLines = [];
          for (let i = 0; i < densePoints.length; i++) {
              const p1 = densePoints[i];
              const p2 = densePoints[(i + 1) % densePoints.length];
              const normal = getSegmentNormal(p1, p2, centroid);
              
              let depth = 0; 
              const originalIdx = edgeMap[i];
              
              if (frontageIndices && frontageIndices.has(originalIdx)) {
                  depth = depths.front;
              } else if (edgeTypes && edgeTypes[originalIdx] === 'back') {
                  depth = depths.back;
              } else if (edgeTypes && edgeTypes[originalIdx] === 'side') {
                  depth = depths.side;
              }

              const shiftX = normal.x * depth;
              const shiftY = normal.y * depth;
              
              shiftedLines.push({
                  p1: { x: p1.x + shiftX, y: p1.y + shiftY },
                  p2: { x: p2.x + shiftX, y: p2.y + shiftY },
                  origIdx: originalIdx
              });
          }

          const newPoints = [];
          const newEdgeIndices = [];

          for (let i = 0; i < shiftedLines.length; i++) {
              const l1 = shiftedLines[i];
              const l2 = shiftedLines[(i + 1) % shiftedLines.length];
              const intersect = getLineIntersection(l1.p1, l1.p2, l2.p1, l2.p2);
              
              if (intersect) {
                  newPoints.push(intersect);
              } else {
                  newPoints.push(l1.p2);
              }
              newEdgeIndices.push(l1.origIdx);
          }
          
          return { points: newPoints, edgeIndices: newEdgeIndices };
      };

      const distToSegment = (p, v, w) => {
          const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
          if (l2 == 0) return Math.hypot(p.x - v.x, p.y - v.y);
          let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
          t = Math.max(0, Math.min(1, t));
          return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
      };

      const EditableInput = ({ value, onChange, className, step, disabled }) => {
        const [localVal, setLocalVal] = useState(value);
        const [isEditing, setIsEditing] = useState(false);

        useEffect(() => {
            if (!isEditing) {
                setLocalVal(typeof value === 'number' ? parseFloat(value.toFixed(2)) : value);
            }
        }, [value, isEditing]);

        const handleChange = (e) => {
            setLocalVal(e.target.value);
        };

        const handleBlur = () => {
            setIsEditing(false);
            if (localVal !== "" && !isNaN(parseFloat(localVal))) {
                onChange(parseFloat(localVal));
            } else {
                setLocalVal(parseFloat(value.toFixed(2)));
            }
        };

        const handleKeyDown = (e) => {
            if (e.key === 'Enter') e.target.blur();
        };

        return (
            <input
                type="number"
                value={localVal}
                onChange={handleChange}
                onFocus={() => setIsEditing(true)}
                onBlur={handleBlur}
                onKeyDown={handleKeyDown}
                step={step}
                className={className}
                disabled={disabled}
            />
        );
      };

      const ArtisticCompass = React.memo(({ className, rotation, isDarkMode }) => (
        <div className={`${className} relative flex items-center justify-center opacity-80 transition-transform duration-300 ease-out`} style={{ transform: `rotate(${rotation}deg)` }}>
          <svg viewBox="0 0 100 100" className="w-full h-full drop-shadow-lg">
            <circle cx="50" cy="50" r="46" fill={isDarkMode ? "#1e293b" : "#f8fafc"} stroke={isDarkMode ? "#475569" : "#94a3b8"} strokeWidth="1.5" />
            <circle cx="50" cy="50" r="42" fill="none" stroke={isDarkMode ? "#64748b" : "#cbd5e1"} strokeWidth="0.5" strokeDasharray="3 3" />
            <line x1="50" y1="4" x2="50" y2="96" stroke={isDarkMode ? "#334155" : "#e2e8f0"} strokeWidth="0.5" />
            <line x1="4" y1="50" x2="96" y2="50" stroke={isDarkMode ? "#334155" : "#e2e8f0"} strokeWidth="0.5" />
            <path d="M 50 10 L 55 50 L 50 50 L 45 50 Z" fill="#ef4444" />
            <text x="50" y="24" textAnchor="middle" fontSize="8" fontWeight="bold" fill={isDarkMode ? "#e2e8f0" : "#334155"} className="font-serif">N</text>
            <circle cx="50" cy="50" r="2" fill={isDarkMode ? "#e2e8f0" : "#475569"} />
          </svg>
        </div>
      ));

      const FloorInfoCard = ({ data, isDarkMode, onReset, isConstraintMode }) => {
        if (!data) return null;
        
        const isBase = data.id === 'base';
        const isExcavation = data.id === 'excavation';

        return (
          <div 
            className={`absolute z-50 pointer-events-auto transition-opacity duration-300 ease-out ${data ? 'opacity-100' : 'opacity-0'}`}
            style={{ 
                top: '56px', right: '16px',
            }}
          >
             <div className={`backdrop-blur-md border rounded-xl shadow-lg p-3 min-w-[140px] transform scale-90 origin-top-right ${isDarkMode ? 'bg-slate-800/90 border-slate-600 text-white' : 'bg-white/95 border-stone-200 text-stone-700'}`}>
                <div className="flex justify-between items-center mb-1 pb-1 border-b border-stone-200/20">
                    <h3 className="font-bold text-sm flex items-center gap-2">
                        {isBase ? <Map size={14} className="text-stone-500"/> : (isExcavation ? <Shovel size={14} className="text-amber-500"/> : <Layers size={14} className="text-indigo-500"/>)}
                        {isBase ? '基地範圍' : (isExcavation ? '開挖範圍' : `${data.id} 樓板`)}
                    </h3>
                    {!isConstraintMode && !isBase && !isExcavation && <button onClick={() => onReset(data.id)} className="p-0.5 hover:bg-black/10 rounded" title="重置設定"><Undo2 size={12}/></button>}
                </div>
                <div className="space-y-1 text-xs">
                    <div className="flex justify-between items-end">
                        <span className="opacity-60 text-[10px]">面積</span>
                        <span className="font-bold text-base num-font text-indigo-600">{formatNum(toPing(data.realArea))} <span className="text-[10px] text-stone-400 font-normal">坪</span></span>
                    </div>
                     {data.points && (
                         <div className="text-center py-0.5 text-[10px] text-stone-400 bg-stone-100/50 rounded mt-1">
                            自訂多邊形
                         </div>
                     )}
                </div>
             </div>
          </div>
        );
      };
      
      const CoordinatePopup = ({ point, idx, onChange, scale, isDarkMode }) => {
          if (!point) return null;
          return (
             <div 
                className={`absolute z-[60] p-2 rounded-lg shadow-xl border backdrop-blur-sm animate-riseUp ${isDarkMode ? 'bg-slate-800/90 border-slate-600 text-white' : 'bg-white/90 border-stone-200'}`}
                style={{ 
                    left: `calc(50% + ${point.x * scale}px)`, 
                    top: `calc(50% + ${point.y * scale}px)`,
                    transform: 'translate(10px, -50%)'
                }}
                onPointerDown={e => e.stopPropagation()}
             >
                 <div className="text-[10px] font-bold opacity-50 mb-1 flex justify-between items-center">
                     <span>點 {idx + 1} 座標</span>
                 </div>
                 <div className="flex flex-col gap-1">
                     <div className="flex items-center gap-1">
                         <span className="text-xs font-mono w-3 text-stone-400">X</span>
                         <EditableInput value={point.x} onChange={(v) => onChange('x', v)} className="w-16 p-1 text-xs border rounded bg-transparent text-right outline-none focus:border-indigo-500" />
                     </div>
                     <div className="flex items-center gap-1">
                         <span className="text-xs font-mono w-3 text-stone-400">Y</span>
                         <EditableInput value={point.y} onChange={(v) => onChange('y', v)} className="w-16 p-1 text-xs border rounded bg-transparent text-right outline-none focus:border-indigo-500" />
                     </div>
                 </div>
             </div>
          );
      };

      const ContextMenu = ({ x, y, isOpen, onClose, items, isDarkMode }) => {
          if (!isOpen) return null;
          return (
              <div className={`fixed z-[60] min-w-[160px] rounded-lg shadow-xl border overflow-hidden animate-in fade-in zoom-in-95 duration-100 ${isDarkMode ? 'bg-slate-800 border-slate-700 text-slate-200' : 'bg-white border-stone-200 text-stone-700'}`} style={{ top: y, left: x }}>
                  {items.map((item, i) => (
                      <button key={i} onClick={(e) => { e.stopPropagation(); item.action(); onClose(); }} className={`w-full text-left px-4 py-2 text-sm flex items-center gap-2 hover:bg-opacity-50 ${isDarkMode ? 'hover:bg-slate-700' : 'hover:bg-stone-50'} ${item.className || ''}`}>
                          {item.icon}
                          <span>{item.label}</span>
                      </button>
                  ))}
              </div>
          );
      };

      const EditMenu2D = ({ data, isDarkMode, onUpdateSetting, onReset, isOpen, onClose, scale3d, inputs, basePoints, isRoadSelectMode, onToggleRoadSelectMode, interactionMode, setInteractionMode, selectedCurveIdx, onUpdateRoads, onUpdateInputs, isAreaLocked, setIsAreaLocked, unitSettings, onUpdateUnitSettings }) => {
          const [activeTab, setActiveTab] = useState('shape');
          const [contextMenu, setContextMenu] = useState({ x: 0, y: 0, isOpen: false });

          useEffect(() => {
              const handleContextMenu = (e) => {
                  e.preventDefault();
                  setContextMenu({ x: e.clientX, y: e.clientY, isOpen: true });
              };
              document.addEventListener('contextmenu', handleContextMenu);
              return () => document.removeEventListener('contextmenu', handleContextMenu);
          }, []);

          const contextMenuItems = [
              { label: '形狀編輯', icon: <Edit3 size={14}/>, action: () => setActiveTab('shape') },
              { label: '道路設定', icon: <Compass size={14}/>, action: () => setActiveTab('roads') },
              { label: '位置移動', icon: <Move size={14}/>, action: () => setActiveTab('pos') },
              { label: '後院退縮', icon: <Square size={14} className="text-emerald-500"/>, action: () => setInteractionMode('set_back') },
              { label: '側院退縮', icon: <Square size={14} className="text-blue-500"/>, action: () => setInteractionMode('set_side') },
              { label: '完成編輯', icon: <CheckCircle2 size={14}/>, action: onClose, className: 'text-green-600 font-bold' }
          ];
          const [isCollapsed, setIsCollapsed] = useState(false);
          const [lockedParam, setLockedParam] = useState(null);
          const [position, setPosition] = useState({ x: 0, y: 0 });
          const [showHelp, setShowHelp] = useState(false);

          if (!data || !isOpen) return null;
          
          const isBase = data.id === 'base';
          const isExcavation = data.id === 'excavation';

          const pingValue = toPing(data.realArea);
          const points = data.points; 

          useEffect(() => {
              if (activeTab === 'shape' && !points && !isRoadSelectMode && !isBase) {
                  const w = data.realWidth; 
                  const d = data.realDepth;
                  
                  if (isExcavation && basePoints) {
                       const scaleRate = Math.sqrt(inputs.excavationRatio / 100);
                       const { points: newPts, curves: newCurves } = scalePolygon(basePoints, inputs.baseCurves, scaleRate);
                       onUpdateSetting(data.id, 'points', newPts);
                       onUpdateSetting(data.id, 'curves', newCurves);
                  } else {
                       const pts = [{x: -w/2, y: -d/2}, {x: w/2, y: -d/2}, {x: w/2, y: d/2}, {x: -w/2, y: d/2}];
                       onUpdateSetting(data.id, 'points', pts);
                  }
              }
          }, [activeTab]);

          const handleArea = (val) => {
              const newAreaSqm = toSqm(val);
              if (points) {
                  const currentArea = data.realArea;
                  const scale = Math.sqrt(newAreaSqm / currentArea);
                  const { points: newPoints, curves: newCurves } = scalePolygon(points, data.curves, scale, {x:0, y:0});
                  onUpdateSetting(data.id, 'points', newPoints);
                  if (newCurves) onUpdateSetting(data.id, 'curves', newCurves);
              } else {
                  if (lockedParam === 'width') onUpdateSetting(data.id, 'depth', newAreaSqm/data.realWidth);
                  else if (lockedParam === 'depth') onUpdateSetting(data.id, 'width', newAreaSqm/data.realDepth);
                  onUpdateSetting(data.id, 'area', newAreaSqm);
              }
          };

          const handleResetShape = () => {
              if (isBase) {
                  const w = data.realWidth; 
                  const d = data.realDepth;
                  const pts = [{x: -w/2, y: -d/2}, {x: w/2, y: -d/2}, {x: w/2, y: d/2}, {x: -w/2, y: d/2}];
                  onUpdateSetting(data.id, 'points', pts);
                  onUpdateSetting(data.id, 'curves', null);
              } else {
                  onUpdateSetting(data.id, 'points', null);
                  onUpdateSetting(data.id, 'curves', null);
              }
              onReset(data.id); 
          };
          
          const handleRevertCurve = () => {
              if (selectedCurveIdx !== null) {
                  const newCurves = { ...(data.curves || {}) };
                  delete newCurves[selectedCurveIdx];
                  onUpdateSetting(data.id, 'curves', newCurves);
              }
          };

          const toggleTab = (t) => {
              setActiveTab(prev => prev === t ? null : t);
          };
          const toggleLock = (p) => setLockedParam(prev => prev === p ? null : p);
          
          const LockBtn = ({p}) => (
              <button onClick={(e) => {e.stopPropagation(); toggleLock(p);}} className={`p-1 rounded ${lockedParam===p?'bg-indigo-100 text-indigo-600':'text-gray-400'}`}>
                  {lockedParam===p?<Lock size={12}/>:<Unlock size={12}/>}
              </button>
          );

          const handleToggleEdge = (roadId, edgeIdx) => {
              const newRoads = inputs.roads.map(r => {
                  if (r.id === roadId) {
                      const indices = new Set(r.edgeIndices || []);
                      if (r.edgeIndex !== undefined && r.edgeIndex !== null && r.edgeIndex !== "") indices.add(parseInt(r.edgeIndex));
                      
                      if (indices.has(edgeIdx)) indices.delete(edgeIdx);
                      else indices.add(edgeIdx);
                      
                      return { ...r, edgeIndices: Array.from(indices), edgeIndex: undefined };
                  }
                  return r;
              });
              onUpdateRoads(newRoads);
          };

          // Drag Logic
          const isDragging = useRef(false);
          const dragStart = useRef({ x: 0, y: 0 });
          const initialPos = useRef({ x: 0, y: 0 });

          const handleDragStart = (e) => {
              isDragging.current = true;
              dragStart.current = { x: e.clientX, y: e.clientY };
              initialPos.current = { ...position };
              e.target.setPointerCapture(e.pointerId);
          };

          const handleDragMove = (e) => {
              if (!isDragging.current) return;
              const dx = e.clientX - dragStart.current.x;
              const dy = e.clientY - dragStart.current.y;
              setPosition({ x: initialPos.current.x + dx, y: initialPos.current.y + dy });
          };

          const handleDragEnd = (e) => {
              isDragging.current = false;
              e.target.releasePointerCapture(e.pointerId);
          };

          return (
              <>
                  <div 
                      className={`absolute bottom-4 left-0 right-0 z-50 rounded-xl shadow-2xl border backdrop-blur-md transition-opacity duration-300 ease-in-out flex flex-col md:flex-row items-center justify-between p-1 gap-1 mx-auto w-fit ${isDarkMode ? 'bg-slate-800/95 border-slate-600 text-white' : 'bg-white/95 border-stone-200 text-stone-800'}`}
                      style={{ transform: `translate(${position.x}px, ${position.y}px)` }}
                      onClick={(e) => e.stopPropagation()}
                  >
                      {/* Drag Handle */}
                      <div className="absolute -top-6 left-1/2 -translate-x-1/2 flex items-center gap-2">
                          <div 
                            className="w-12 h-4 bg-white/50 rounded-full cursor-grab active:cursor-grabbing flex items-center justify-center border border-stone-200 shadow-sm"
                            onPointerDown={handleDragStart}
                            onPointerMove={handleDragMove}
                            onPointerUp={handleDragEnd}
                          >
                             <GripHorizontal size={12} className="text-stone-500" />
                          </div>
                          <button onClick={() => setIsCollapsed(!isCollapsed)} className="w-6 h-4 bg-white/50 rounded-full flex items-center justify-center border border-stone-200 shadow-sm hover:bg-white">
                              {isCollapsed ? <ChevronUp size={10}/> : <ChevronDown size={10}/>}
                          </button>
                      </div>

                      {/* Left: Info HUD */}
                      {!isCollapsed && (
                          <div className="flex items-center gap-2 px-2 w-full md:w-auto overflow-x-auto no-scrollbar animate-fade-in">
                              <div className="flex items-center gap-2 border-r pr-2 border-stone-300/30 flex-shrink-0">
                                  <span className="font-bold flex items-center gap-1 text-xs">
                                      {isBase ? <Map size={16} className="text-stone-500"/> : (isExcavation ? <Shovel size={16} className="text-amber-500"/> : <Layers size={16} className="text-indigo-500"/>)}
                                      <span className="hidden md:inline">{isBase ? '基地編輯' : (isExcavation ? '開挖範圍' : data.id)}</span>
                                  </span>
                              </div>
                              
                              <div className="flex flex-col items-center leading-none flex-shrink-0">
                                  <span className="text-[9px] opacity-50 uppercase tracking-wide">Area (坪)</span>
                                  <div className="flex items-baseline gap-1">
                                      <EditableInput value={pingValue} onChange={handleArea} step="0.5" className="w-20 p-0 text-center font-bold text-sm border-b border-transparent hover:border-indigo-400 focus:border-indigo-500 outline-none bg-transparent" />
                                      {!points && !isBase && <LockBtn p="area"/>}
                                      {points && (
                                          <button onClick={() => setIsAreaLocked(!isAreaLocked)} className={`p-1 rounded ${isAreaLocked?'bg-indigo-100 text-indigo-600':'text-gray-400'}`} title="鎖定面積 (形狀改變時維持面積)">
                                              {isAreaLocked ? <Lock size={12}/> : <Unlock size={12}/>}
                                          </button>
                                      )}
                                  </div>
                              </div>
                          </div>
                      )}

                      {/* Center: Tools */}
                      <div className="flex items-center gap-1 flex-shrink-0">
                          <button onClick={() => toggleTab('shape')} className={`flex items-center gap-1 px-2 py-1.5 rounded-lg transition-all ${activeTab==='shape' ? 'bg-indigo-600 text-white shadow-lg' : 'hover:bg-stone-100 text-stone-500'}`}>
                              <Hexagon size={14} className={activeTab==='shape'?'animate-pulse':''}/>
                              <span className="text-xs font-bold">形狀</span>
                          </button>

                          {isBase && (
                              <button onClick={() => toggleTab('base')} className={`flex items-center gap-1 px-2 py-1.5 rounded-lg transition-all ${activeTab==='base' ? 'bg-indigo-600 text-white shadow-lg' : 'hover:bg-stone-100 text-stone-500'}`}>
                                <Map size={14}/>
                                <span className="text-xs font-bold">基地</span>
                              </button>
                          )}

                          {isBase && (
                              <button onClick={() => toggleTab('roads')} className={`flex items-center gap-1 px-2 py-1.5 rounded-lg transition-all ${activeTab==='roads' ? 'bg-indigo-600 text-white shadow-lg' : 'hover:bg-stone-100 text-stone-500'}`}>
                                <Compass size={14}/>
                                <span className="text-xs font-bold">道路</span>
                              </button>
                          )}

                          {!isBase && (
                              <button onClick={() => toggleTab('pos')} className={`flex items-center gap-1 px-2 py-1.5 rounded-lg transition-all ${activeTab==='pos' ? 'bg-indigo-600 text-white shadow-lg' : 'hover:bg-stone-100 text-stone-500'}`}>
                                  <Move size={14}/>
                                  <span className="text-xs font-bold">位置</span>
                              </button>
                          )}
                          
                          {isBase && points && (
                              <>
                                  <button onClick={() => setInteractionMode(interactionMode === 'set_back' ? 'none' : 'set_back')} className={`flex items-center gap-1 px-2 py-1.5 rounded-lg transition-all border ${interactionMode === 'set_back' ? 'bg-emerald-500 text-white border-emerald-600 shadow-lg animate-pulse' : 'bg-white text-stone-600 border-stone-200 hover:bg-stone-50'}`}>
                                      <Square size={14} fill={interactionMode === 'set_back' ? "white" : "none"}/>
                                      <span className="text-xs font-bold">後院(綠)</span>
                                  </button>
                                  <button onClick={() => setInteractionMode(interactionMode === 'set_side' ? 'none' : 'set_side')} className={`flex items-center gap-1 px-2 py-1.5 rounded-lg transition-all border ${interactionMode === 'set_side' ? 'bg-blue-500 text-white border-blue-600 shadow-lg animate-pulse' : 'bg-white text-stone-600 border-stone-200 hover:bg-stone-50'}`}>
                                      <Square size={14} fill={interactionMode === 'set_side' ? "white" : "none"}/>
                                      <span className="text-xs font-bold">側院(藍)</span>
                                  </button>
                              </>
                          )}
                      </div>

                      {/* Right: Actions */}
                      <div className="flex items-center gap-1 border-l pl-2 border-stone-300/30 flex-shrink-0">
                          {data.id !== 'base' && data.id !== 'excavation' && (
                              <button onClick={() => onUpdateUnitSettings(prev => ({...prev, enabled: !prev.enabled, target: data.id}))} className={`flex items-center gap-1 px-2 py-1.5 rounded-lg transition-colors ${unitSettings?.enabled ? 'bg-indigo-100 text-indigo-700' : 'hover:bg-stone-100 text-stone-500'}`} title="分戶功能">
                                  <LayoutDashboard size={14}/>
                                  <span className="text-xs font-bold">分戶</span>
                              </button>
                          )}
                          {activeTab === 'shape' && data && (
                              <>
                                  {selectedCurveIdx !== null && (
                                      <button onClick={handleRevertCurve} className="flex items-center gap-1 px-2 py-1.5 rounded-lg text-xs text-orange-600 hover:text-orange-700 hover:bg-orange-50 border border-orange-100 transition-colors">
                                          <RotateCcw size={12}/> 還原直線
                                      </button>
                                  )}
                                  <button onClick={handleResetShape} className="flex items-center gap-1 px-2 py-1.5 rounded-lg text-xs text-red-600 hover:text-red-700 hover:bg-red-50 border border-red-100 transition-colors">
                                      <Trash2 size={12}/> 重置形狀
                                  </button>
                              </>
                          )}
                          <button onClick={() => setShowHelp(!showHelp)} className={`p-1.5 rounded-lg transition-colors ${showHelp ? 'bg-indigo-100 text-indigo-600' : 'hover:bg-stone-100 text-stone-500'}`} title="說明">
                              <Info size={14}/>
                          </button>
                          <button onClick={onClose} className="flex items-center gap-1 px-3 py-1.5 rounded-lg bg-stone-800 text-white hover:bg-stone-700 shadow-md transition-colors">
                              <CheckCircle2 size={14}/>
                              <span className="text-xs font-bold">完成</span>
                          </button>
                      </div>

                      {activeTab && activeTab !== 'shape' && (
                          <div className={`absolute bottom-full mb-3 left-1/2 -translate-x-1/2 w-80 p-4 rounded-xl shadow-xl border animate-slide-up ${isDarkMode ? 'bg-slate-800 border-slate-600 text-white' : 'bg-white border-stone-200 text-stone-800'}`}>
                              
                              {activeTab === 'base' && isBase && (
                                  <div className="space-y-3">
                                      <div className="pb-2 border-b border-stone-100/10 flex justify-between items-center">
                                          <span className="text-xs font-bold opacity-70">基地設定</span>
                                      </div>
                                      <div className="flex items-center justify-between text-xs pb-2 border-b border-stone-100/10 mb-2">
                                          <span className="font-bold flex items-center gap-1"><Compass size={14}/> 北向方位角</span>
                                          <div className="flex items-center gap-1">
                                              <input type="range" min="0" max="360" value={inputs.northAngle || 0} onChange={(e) => onUpdateInputs('northAngle', parseFloat(e.target.value))} className="w-20 accent-indigo-500" />
                                              <EditableInput value={inputs.northAngle || 0} onChange={(v) => onUpdateInputs('northAngle', v)} className="w-10 p-0.5 text-right border rounded bg-transparent" />
                                              <span>°</span>
                                          </div>
                                      </div>
                                  </div>
                              )}

                              {activeTab === 'roads' && isBase && points && (
                                  <div className="space-y-3">
                                      <div className="pb-2 border-b border-stone-100/10 flex justify-between items-center">
                                          <span className="text-xs font-bold opacity-70">道路設定</span>
                                          <button onClick={() => { const newId = Math.max(0, ...inputs.roads.map(r=>r.id)) + 1; onUpdateRoads([...inputs.roads, {id:newId, name:'新道路', width:6, type:'secondary'}]); }} className="text-[10px] bg-indigo-50 text-indigo-600 px-2 py-0.5 rounded border border-indigo-100 hover:bg-indigo-100 flex items-center gap-1">
                                              <Plus size={10}/> 新增
                                          </button>
                                      </div>
                                      
                                      <div className="flex items-center justify-between text-xs pb-2 border-b border-stone-100/10 mb-2 bg-stone-50/50 p-2 rounded">
                                          <span className="font-bold flex items-center gap-1 text-stone-600">退縮設定 (米)</span>
                                          <div className="flex gap-2 text-stone-500 font-mono">
                                             <span title="前院退縮">前:{inputs.frontYardDepth || 0}</span>
                                             <span title="後院退縮">後:{inputs.backYardDepth || 0}</span>
                                             <span title="側院退縮">側:{inputs.sideYardDepth || 0}</span>
                                          </div>
                                      </div>

                                      <div className="flex items-center justify-between text-xs pb-2 border-b border-stone-100/10 mb-2">
                                          <span className="font-bold flex items-center gap-1 text-stone-600">側院深度</span>
                                          <div className="flex items-center gap-1">
                                              <select value={inputs.sideYardDirection || 'right'} onChange={(e) => onUpdateInputs('sideYardDirection', e.target.value)} className="text-[10px] p-0.5 rounded border border-stone-200 bg-white text-stone-700 outline-none">
                                                  <option value="right">右側</option>
                                                  <option value="left">左側</option>
                                              </select>
                                              <input type="number" value={inputs.sideYardDepth || 0} onChange={(e) => onUpdateInputs('sideYardDepth', e.target.value)} className="w-16 p-0.5 text-right border border-stone-300 rounded bg-white" />
                                              <span className="text-[10px] text-stone-400">m</span>
                                          </div>
                                      </div>

                                      {showHelp && <p className="text-[10px] opacity-50">指定道路對應的基地邊線 (0 ~ {points.length-1})</p>}

                                      <div className="space-y-2 max-h-[150px] overflow-y-auto pr-1">
                                          {inputs.roads.map(road => (
                                              <div key={road.id} className="flex flex-col text-xs gap-1 border-b border-stone-100/10 pb-2 mb-2 last:border-0">
                                                  <div className="flex items-center gap-1">
                                                      <button onClick={() => onUpdateRoads(inputs.roads.filter(r => r.id !== road.id))} className="text-stone-300 hover:text-red-500 p-0.5"><Trash2 size={12}/></button>
                                                      <span className="font-bold truncate max-w-[80px]" title={road.name}>{road.name}</span>
                                                      <span className="text-stone-400">({road.width}m)</span>
                                                      <select 
                                                        value={road.type || 'secondary'} 
                                                        onChange={(e) => {
                                                            const newRoads = inputs.roads.map(r => r.id === road.id ? { ...r, type: e.target.value } : r);
                                                            onUpdateRoads(newRoads);
                                                        }}
                                                        className="ml-auto text-[10px] p-0.5 rounded border border-stone-200 bg-white text-stone-700 outline-none"
                                                      >
                                                        <option value="primary">主要</option>
                                                        <option value="secondary">一般</option>
                                                      </select>
                                                  </div>
                                                  <div className="flex flex-wrap gap-1 pl-4">
                                                      {points.map((_, i) => {
                                                          const isActive = (road.edgeIndices || []).includes(i) || road.edgeIndex == i;
                                                          return (
                                                              <button key={i} onClick={() => handleToggleEdge(road.id, i)} className={`text-[9px] px-1.5 py-0.5 rounded border transition-colors ${isActive ? 'bg-indigo-100 border-indigo-300 text-indigo-700 font-bold shadow-sm' : 'bg-white border-stone-200 text-stone-400 hover:bg-stone-50'}`} title={`切換邊線 ${i}`}>
                                                                  {i}
                                                              </button>
                                                          );
                                                      })}
                                                  </div>
                                              </div>
                                          ))}
                                          {inputs.roads.length === 0 && <div className="text-xs opacity-50 text-center">無道路資料</div>}
                                      </div>
                                  </div>
                              )}
                          </div>
                      )}
                  </div>
              </>
          );
      };

      const SummaryRow = ({ label, value, highlight, isAlert, alertText, subtext }) => (
          <div className="flex justify-between items-center py-1 border-b border-stone-100 last:border-0">
              <span className="text-stone-500 text-sm">{label}</span>
              <div className="text-right">
                   <div className={`font-bold num-font ${highlight ? 'text-emerald-600 text-lg' : (isAlert ? 'text-rose-500' : 'text-stone-800')}`}>
                       {value}
                       {isAlert && <span className="ml-2 text-[10px] bg-rose-100 text-rose-600 px-1 rounded">{alertText}</span>}
                   </div>
                   {subtext && <div className="text-[10px] text-stone-400">{subtext}</div>}
              </div>
          </div>
      );

      const BuildingLayer = React.memo(({ width, depth, height, x, y, z, rotation, pivot, scale, color, strokeColor, opacity, visible, showFrame, isSlabMode, animate, delay, isDarkMode, onClick, isSelected, isViolation, points, curves, staticPoints, unusedReviewArea, unitLabel, unitArea }) => {
        if (!visible) return null;
        const thickness = isSlabMode ? Math.max(1.5, height * 0.08) : height;
        const pivotX = (pivot?.x || 0) * scale;
        const pivotY = (pivot?.y || 0) * scale;
        
        let displayColor = color; let displayBorder = strokeColor; let displayOpacity = opacity;

        const highlightColor = isSelected ? (isDarkMode ? "#38bdf8" : "#0ea5e9") : displayBorder;
        const highlightBorder = isViolation ? `2px solid ${displayBorder}` : (isSelected ? `2px solid ${highlightColor}` : (showFrame ? `1px solid ${displayBorder}` : 'none'));
        const highlightBg = isSelected && !isViolation ? (isDarkMode ? "#0c4a6e" : "#bae6fd") : displayColor;
        const finalBorder = isSlabMode ? (showFrame ? `1px solid ${isViolation ? strokeColor : highlightColor}` : 'none') : highlightBorder;
        const finalOpacity = isSlabMode ? (isViolation ? 0.8 : 0.95) : opacity;

        const showStroke = isViolation || isSelected || showFrame || isSlabMode;
        const unitText = unitLabel ? `${unitLabel} (${formatNum(toPing(unitArea || 0))}坪)` : null;

        const face = (w, h, tx, ty, tz, rx, ry, rz, bg, border, op) => ({
          width: `${w}px`, height: `${h}px`, position: 'absolute', left: '50%', top: '50%', marginLeft: `-${w / 2}px`, marginTop: `-${h / 2}px`, backgroundColor: bg, border: border, boxSizing: 'border-box', transform: `translate3d(${tx}px, ${ty}px, ${tz}px) rotateX(${rx}deg) rotateY(${ry}deg) rotateZ(${rz}deg)`, opacity: op, pointerEvents: 'auto', cursor: 'pointer', transition: 'all 0.5s cubic-bezier(0.4, 0, 0.2, 1)', backfaceVisibility: 'visible', animation: isViolation ? 'pulse-red 3s infinite' : 'none', boxShadow: isDarkMode ? (isSlabMode ? "inset 0 0 15px rgba(255,255,255,0.1)" : "none") : (isSlabMode ? "inset 0 0 5px rgba(0,0,0,0.1)" : "none")
        });

        // Helper to generate SVG Path for Polygon
        const getPolyData = (pts, crvs) => {
            if (!pts || pts.length === 0) return null;
            const ptsPx = pts.map(p => ({ x: (p.x || 0) * scale, y: (p.y || 0) * scale }));
            if (ptsPx.some(p => isNaN(p.x) || isNaN(p.y))) return null;
            const minX = Math.min(...ptsPx.map(p=>p.x)); const maxX = Math.max(...ptsPx.map(p=>p.x)); const minY = Math.min(...ptsPx.map(p=>p.y)); const maxY = Math.max(...ptsPx.map(p=>p.y));
            const bCx = (maxX + minX) / 2; const bCy = (maxY + minY) / 2;
            const padding = 50; const contW = (maxX - minX) + padding * 2; const contH = (maxY - minY) + padding * 2;
            let d = `M ${(ptsPx[0].x - minX + padding)} ${(ptsPx[0].y - minY + padding)}`;
            for (let i = 0; i < ptsPx.length; i++) {
                const pNext = ptsPx[(i + 1) % ptsPx.length];
                const curve = crvs ? crvs[i] : null;
                const nextX = pNext.x - minX + padding; const nextY = pNext.y - minY + padding;
                if (curve) { const cpX = curve.x * scale - minX + padding; const cpY = curve.y * scale - minY + padding; d += ` Q ${cpX} ${cpY}, ${nextX} ${nextY}`; } else { d += ` L ${nextX} ${nextY}`; }
            }
            d += " Z";
            return { d, contW, contH, bCx, bCy };
        };

        if (points && points.length > 0) {
            const polyData = getPolyData(points, curves);
            if (!polyData) return null;
            const { d, contW, contH, bCx, bCy } = polyData;
            
            // Generate Walls
            const ptsPx = points.map(p => ({ x: (p.x || 0) * scale, y: (p.y || 0) * scale }));
            const walls = []; const segmentsForCurve = 8; 
            for (let i = 0; i < ptsPx.length; i++) {
                const p1 = ptsPx[i]; const p2 = ptsPx[(i + 1) % ptsPx.length]; const curve = curves ? curves[i] : null;
                const generateWallSeg = (pt1, pt2, key) => {
                     const dx = pt2.x - pt1.x; const dy = pt2.y - pt1.y; const dist = Math.sqrt(dx*dx + dy*dy); const angle = Math.atan2(dy, dx) * (180 / Math.PI); const midX = (pt1.x + pt2.x) / 2; const midY = (pt1.y + pt2.y) / 2; const customTransform = `translate3d(${midX}px, ${midY}px, ${thickness/2}px) rotateZ(${angle}deg) rotateX(90deg)`;
                     walls.push( <div key={key} style={{ width: `${dist + 0.5}px`, height: `${thickness}px`, position: 'absolute', left: '50%', top: '50%', marginLeft: `-${(dist + 0.5) / 2}px`, marginTop: `-${thickness / 2}px`, backgroundColor: highlightBg, border: finalBorder, boxSizing: 'border-box', transform: customTransform, opacity: finalOpacity, pointerEvents: 'auto', cursor: 'pointer', transition: 'all 0.5s', backfaceVisibility: 'visible', boxShadow: isSlabMode ? "inset 0 0 5px rgba(0,0,0,0.1)" : "none" }} /> );
                };
                if (curve) {
                    const cp = { x: curve.x * scale, y: curve.y * scale }; let prevP = p1;
                    for(let k=1; k<=segmentsForCurve; k++) { const t = k / segmentsForCurve; const tx = (1-t)*(1-t)*p1.x + 2*(1-t)*t*cp.x + t*t*p2.x; const ty = (1-t)*(1-t)*p1.y + 2*(1-t)*t*cp.y + t*t*p2.y; const currP = { x: tx, y: ty }; generateWallSeg(prevP, currP, `${i}-${k}`); prevP = currP; }
                } else { generateWallSeg(p1, p2, i); }
            }

            const clipPath = `path('${d}')`;
            const topFaceStyle = { ...face(contW, contH, bCx, bCy, thickness, 0, 0, 0, highlightBg, 'none', finalOpacity + 0.1), clipPath: clipPath, filter: isSelected ? 'brightness(1.1)' : 'none' };
            const strokeFaceStyle = { ...face(contW, contH, bCx, bCy, thickness + 0.5, 0, 0, 0, 'transparent', 'none', 1), pointerEvents: 'none' };
            const bottomStrokeFaceStyle = { ...face(contW, contH, bCx, bCy, 0, 0, 0, 0, 'transparent', 'none', 1), pointerEvents: 'none' };
            const bottomFaceStyle = { ...face(contW, contH, bCx, bCy, 0, 0, 0, 0, highlightBg, 'none', finalOpacity), clipPath: clipPath };
            
            // Ghost (Static) Layer Logic
            let ghostLayer = null;
            if (staticPoints && staticPoints.length > 0) {
                 const gPoly = getPolyData(staticPoints, curves);
                 if (gPoly) {
                     const gClip = `path('${gPoly.d}')`;
                     // Red transparent style
                     const ghostStyle = { ...face(gPoly.contW, gPoly.contH, gPoly.bCx, gPoly.bCy, thickness - 1, 0, 0, 0, "#ef4444", 'none', 0.2), clipPath: gClip, pointerEvents: 'none' };
                     ghostLayer = <div style={ghostStyle} />;
                 }
            }

            return ( <div className="absolute" onClick={onClick} style={{ left: '50%', top: '50%', width: 0, height: 0, transformStyle: 'preserve-3d', transform: `translate3d(${x}px, ${y}px, ${z}px) rotateZ(${rotation || 0}deg)`, animation: animate ? `riseUp 0.8s ease-out ${delay}ms backwards` : 'none', '--tx': `${x}px`, '--ty': `${y}px`, '--tz': `${z}px` }}>
                {ghostLayer}
                {walls} 
                <div style={{...topFaceStyle, backfaceVisibility: 'hidden'}} className="hover:brightness-110" />
                {showStroke && (
                    <div style={strokeFaceStyle}>
                        <svg width={contW} height={contH} viewBox={`0 0 ${contW} ${contH}`} style={{position:'absolute', left:0, top:0, overflow:'visible'}}>
                            <path d={d} fill="none" stroke={displayBorder} strokeWidth="2" vectorEffect="non-scaling-stroke"/>
                        </svg>
                    </div>
                )}
                <div style={bottomFaceStyle} /> 
                {showStroke && (
                    <div style={bottomStrokeFaceStyle}>
                        <svg width={contW} height={contH} viewBox={`0 0 ${contW} ${contH}`} style={{position:'absolute', left:0, top:0, overflow:'visible'}}>
                            <path d={d} fill="none" stroke={displayBorder} strokeWidth="2" vectorEffect="non-scaling-stroke"/>
                        </svg>
                    </div>
                )}
                {unusedReviewArea > 0.1 && (
                     <div style={{ position: 'absolute', top: 0, left: 0, width: '100px', height: '20px', transform: `translate3d(${bCx}px, ${bCy}px, ${thickness + 10}px) rotateX(-90deg)`, pointerEvents: 'none', display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
                         <div className="bg-red-500/80 text-white text-[10px] font-bold px-1.5 py-0.5 rounded shadow-sm backdrop-blur-sm whitespace-nowrap">
                            -{unusedReviewArea.toFixed(1)}坪
                         </div>
                     </div>
                 )}
                {unitText && (
                     <div style={{ position: 'absolute', top: 0, left: 0, transform: `translate3d(${bCx}px, ${bCy}px, ${thickness + 10}px) rotateX(-90deg)`, pointerEvents: 'none', display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
                         <div className="bg-white/90 text-indigo-600 text-[10px] font-bold px-1.5 py-0.5 rounded shadow-sm backdrop-blur-sm whitespace-nowrap">
                            {unitText}
                         </div>
                     </div>
                 )}
            </div> );
        }
        const topFaceStyle = { ...face(width, depth, 0, 0, thickness, 0, 0, 0, highlightBg, finalBorder, finalOpacity + 0.1), filter: isSelected ? 'brightness(1.1)' : 'none' };
        return ( <div className="absolute" onClick={onClick} style={{ left: '50%', top: '50%', width: 0, height: 0, transformStyle: 'preserve-3d', transform: `translate3d(${x}px, ${y}px, ${z}px) rotateZ(${rotation || 0}deg)`, transformOrigin: `calc(50% + ${pivotX}px) calc(50% - ${pivotY}px)`, animation: animate ? `riseUp 0.8s ease-out ${delay}ms backwards` : 'none', '--tx': `${x}px`, '--ty': `${y}px`, '--tz': `${z}px` }}> <div style={face(width, thickness, 0, depth/2, thickness/2, 90, 0, 0, highlightBg, finalBorder, finalOpacity)} /> <div style={face(width, thickness, 0, -depth/2, thickness/2, -90, 0, 0, highlightBg, finalBorder, finalOpacity)} /> <div style={face(depth, thickness, width/2, 0, thickness/2, 0, 90, 90, highlightBg, finalBorder, finalOpacity)} /> <div style={face(depth, thickness, -width/2, 0, thickness/2, 0, 90, -90, highlightBg, finalBorder, finalOpacity)} /> <div style={topFaceStyle} className="hover:brightness-110" /> <div style={face(width, depth, 0, 0, 0, 0, 0, 0, highlightBg, finalBorder, finalOpacity)} /> {unitText && ( <div style={{ position: 'absolute', top: 0, left: 0, transform: `translate3d(0px, 0px, ${thickness + 10}px) rotateX(-90deg)`, pointerEvents: 'none', display: 'flex', justifyContent: 'center', alignItems: 'center' }}> <div className="bg-white/90 text-indigo-600 text-[10px] font-bold px-1.5 py-0.5 rounded shadow-sm backdrop-blur-sm whitespace-nowrap"> {unitText} </div> </div> )} </div> );
      });

      const PlanAnalysis2D = ({ layers, baseWidthM, baseDepthM, onSelectFloor, selectedFloorId, isDarkMode, onUpdateSetting, floorSettings, inputs, scale3d, basements, onToggleBasement, activeBasementArea, totalAllowedArea, showCheckLines, volumeLimit, parkingOn1F, onToggleParkingLocation, onClose, basePoints, baseCurves, onAddRoad, excavationPoints, excavationCurves, frontageIndices, onUpdateFrontageIndices, onAddFloor, onRemoveFloor, edgeTypes, onUpdateEdgeTypes, view, onUpdateView, onUpdateInputs, onUpdateRoads, onEditEnd, unitSettings, onUpdateUnitSettings, onApplyAll, floorsAboveValue, onUpdateFloorsAbove }) => {
          
          // 1. Calculate Default Points (Temporary display only)
          const defaultBasePts = useMemo(() => {
              const w = baseWidthM;
              const d = baseDepthM;
              return [{x: -w/2, y: -d/2}, {x: w/2, y: -d/2}, {x: w/2, y: d/2}, {x: -w/2, y: d/2}];
          }, [baseWidthM, baseDepthM]);

          // Use default points if explicit basePoints are null, to prevent 3D state change
          const currentBasePoints = basePoints || defaultBasePts;
          const baseCentroid = useMemo(() => getPolygonCentroid(currentBasePoints || defaultBasePts), [currentBasePoints, defaultBasePts]);
          const groupedLayers = useMemo(() => {
              const map = {};
              const order = [];
              (layers || []).forEach(layer => {
                  const baseId = layer.id.split('-')[0];
                  if (!map[baseId]) {
                      map[baseId] = { id: baseId, units: [] };
                      order.push(baseId);
                  }
                  map[baseId].units.push(layer);
              });
              return order.map(id => map[id]);
          }, [layers]);

          let displayLayer = null;
          if (selectedFloorId === 'base') {
              // Ensure displayLayer always has points so EditMenu2D works without auto-initializing state
              displayLayer = { id: 'base', points: currentBasePoints, realWidth: baseWidthM, realDepth: baseDepthM, realArea: inputs.baseArea, isViolation: false, curves: baseCurves };
          } else if (selectedFloorId === 'excavation') {
               const defaultExcavationW = baseWidthM * Math.sqrt(inputs.excavationRatio/100); const defaultExcavationD = baseDepthM * Math.sqrt(inputs.excavationRatio/100);
               displayLayer = { id: 'excavation', points: excavationPoints, realWidth: defaultExcavationW, realDepth: defaultExcavationD, realArea: excavationPoints ? calculatePolygonArea(excavationPoints) : (defaultExcavationW * defaultExcavationD), isViolation: false, curves: excavationCurves };
          } else if (selectedFloorId) { 
              displayLayer = layers.find(l => l.id === selectedFloorId);
              if (!displayLayer) {
                  const splitLayer = layers.find(l => l.id.startsWith(`${selectedFloorId}-`));
                  if (splitLayer) {
                      const basePts = floorSettings?.[selectedFloorId]?.splitBasePoints || floorSettings?.[selectedFloorId]?.points || splitLayer.points || null;
                      const baseCurvs = floorSettings?.[selectedFloorId]?.splitBaseCurves || floorSettings?.[selectedFloorId]?.curves || splitLayer.curves || null;
                      const baseArea = basePts ? calculatePolygonArea(basePts) : splitLayer.realArea;
                      displayLayer = { ...splitLayer, id: selectedFloorId, points: basePts, curves: baseCurvs, realArea: baseArea };
                  }
              }
          }
          const savedUnits = useMemo(() => {
              if (!selectedFloorId) return null;
              return floorSettings?.[selectedFloorId]?.units || null;
          }, [floorSettings, selectedFloorId]);

          const [containerSize, setContainerSize] = useState({ w: 800, h: 600 });
          useEffect(() => { const updateSize = () => { setContainerSize({ w: window.innerWidth, h: window.innerHeight * 0.7 }); }; updateSize(); window.addEventListener('resize', updateSize); return () => window.removeEventListener('resize', updateSize); }, []);

          const maxDim = Math.max(baseWidthM, baseDepthM); const padding = 40; 
          const scale = Math.min((containerSize.w - padding * 2) / maxDim, (containerSize.h - padding * 2) / maxDim);
          const baseW = baseWidthM * scale; const baseH = baseDepthM * scale;
          let xPos = 0, yPos = 0;
          if (displayLayer && selectedFloorId !== 'base' && selectedFloorId !== 'excavation') { const shiftX_M = displayLayer.shiftX / scale3d; const shiftY_M = displayLayer.shiftYPx / scale3d; xPos = shiftX_M * scale; yPos = shiftY_M * scale; }
          const containerRef = useRef(null);
          
          const onWheel = (e) => { 
             e.stopPropagation(); e.preventDefault(); 
             
             // Target Zoom (Zoom towards cursor)
             const rect = e.currentTarget.getBoundingClientRect();
             const mouseX = e.clientX - rect.left;
             const mouseY = e.clientY - rect.top;
             const centerX = rect.width / 2;
             const centerY = rect.height / 2;
             
             // Mouse position relative to center
             const mRelX = mouseX - centerX;
             const mRelY = mouseY - centerY;

             const s = Math.exp(-e.deltaY * 0.001); 
             const newK = Math.min(Math.max(0.5, view.k * s), 5); 
             
             // Calculate new translation to keep mouse point fixed
             // NewOffset = OldOffset * Ratio + MousePos * (1 - Ratio)
             const scaleRatio = newK / view.k;
             const newX = view.x * scaleRatio + mRelX * (1 - scaleRatio);
             const newY = view.y * scaleRatio + mRelY * (1 - scaleRatio);
             
             onUpdateView(v => ({ ...v, k: newK, x: newX, y: newY })); 
          };
          
          const [isPanning, setIsPanning] = useState(false);
          const panStart = useRef({ x: 0, y: 0 });
          const lastTouchDist = useRef(null);
          const lastTouchPos = useRef(null);
          const getTouchDistance2D = (touches) => Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);

          const handlePanStart = (e) => { if (!isPanning) return; if (selectedPointForEdit) setSelectedPointForEdit(null); if (e.button !== 0 && e.button !== 1) return; panStart.current = { x: e.clientX, y: e.clientY }; e.target.setPointerCapture(e.pointerId); };
          const handlePanMove = (e) => { if (!isPanning) return; const dx = e.clientX - panStart.current.x; const dy = e.clientY - panStart.current.y; onUpdateView(v => ({ ...v, x: v.x + dx, y: v.y + dy })); panStart.current = { x: e.clientX, y: e.clientY }; };
          const handlePanEnd = (e) => { if (e.target && e.target.releasePointerCapture) e.target.releasePointerCapture(e.pointerId); };
          const handleTouchPanStart = (e) => {
              if (!displayLayer) return;
              if (e.target?.dataset?.type) return;
              if (e.cancelable) e.preventDefault();
              e.stopPropagation();
              if (e.touches.length === 2) {
                  lastTouchDist.current = getTouchDistance2D(e.touches);
                  lastTouchPos.current = null;
              } else if (e.touches.length === 1) {
                  lastTouchPos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                  lastTouchDist.current = null;
              }
          };
          const handleTouchPanMove = (e) => {
              if (!displayLayer) return;
              if (e.cancelable) e.preventDefault();
              e.stopPropagation();
              if (e.touches.length === 2 && lastTouchDist.current !== null) {
                  const currentDist = getTouchDistance2D(e.touches);
                  const delta = currentDist - lastTouchDist.current;
                  onUpdateView(v => ({ ...v, k: Math.min(5, Math.max(0.5, v.k + delta * 0.005)) }));
                  lastTouchDist.current = currentDist;
                  return;
              }
              if (e.touches.length === 1 && lastTouchPos.current) {
                  const dx = e.touches[0].clientX - lastTouchPos.current.x;
                  const dy = e.touches[0].clientY - lastTouchPos.current.y;
                  onUpdateView(v => ({ ...v, x: v.x + dx, y: v.y + dy }));
                  lastTouchPos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
              }
          };
          const handleTouchPanEnd = () => {
              lastTouchDist.current = null;
              lastTouchPos.current = null;
          };
          
          const isDragging = useRef(false);
          const lastPos = useRef({ x: 0, y: 0 });
          const dragStartPos = useRef({ x: 0, y: 0 });
          const dragStartPoint = useRef(null);
          
          const [isRoadSelectMode, setIsRoadSelectMode] = useState(false);
          const [interactionMode, setInteractionMode] = useState('none'); 
          const [selectedPointForEdit, setSelectedPointForEdit] = useState(null); 
          const [selectedCurveForEdit, setSelectedCurveForEdit] = useState(null);
          const longPressTimer = useRef(null);
          const [isAreaLocked, setIsAreaLocked] = useState(false);
          const lockedAreaRef = useRef(null);
          const [unitMenuOffset, setUnitMenuOffset] = useState({ x: 0, y: 0 });
          const unitMenuDragRef = useRef({ dragging: false, startX: 0, startY: 0, originX: 0, originY: 0 });
          useEffect(() => {
              const handleMove = (e) => {
                  if (!unitMenuDragRef.current.dragging) return;
                  const dx = e.clientX - unitMenuDragRef.current.startX;
                  const dy = e.clientY - unitMenuDragRef.current.startY;
                  setUnitMenuOffset({ x: unitMenuDragRef.current.originX + dx, y: unitMenuDragRef.current.originY + dy });
              };
              const handleUp = () => {
                  unitMenuDragRef.current.dragging = false;
              };
              window.addEventListener('pointermove', handleMove);
              window.addEventListener('pointerup', handleUp);
              return () => {
                  window.removeEventListener('pointermove', handleMove);
                  window.removeEventListener('pointerup', handleUp);
              };
          }, []);

          // Task 3: Unit Split State (Lifted to Visualizer3D)
          // const [isUnitSplitMode, setIsUnitSplitMode] = useState(false);
          // const [splitParams, setSplitParams] = useState({ axis: 'x', ratio: 0.5, gap: 0 });
          
          const previewUnits = useMemo(() => {
              if (!unitSettings?.enabled || !displayLayer?.points) return null;
              return getSplitUnits(displayLayer.points, unitSettings);
          }, [unitSettings, displayLayer?.points]);
          const unitsToRender = useMemo(() => {
              if (previewUnits) return null;
              if (!savedUnits || savedUnits.length === 0) return null;
              return savedUnits;
          }, [previewUnits, savedUnits]);
          const handleUnitMenuPointerDown = (e) => {
              e.preventDefault();
              e.stopPropagation();
              unitMenuDragRef.current = { dragging: true, startX: e.clientX, startY: e.clientY, originX: unitMenuOffset.x, originY: unitMenuOffset.y };
          };

          const handleDragStart = (e) => { if (e.button !== 0) return; if (e.target.dataset.type === 'control-point' || e.target.dataset.type === 'edge-line' || e.target.dataset.type === 'curve-handle') return; e.stopPropagation(); isDragging.current = true; lastPos.current = { x: e.clientX, y: e.clientY }; e.target.setPointerCapture(e.pointerId); setSelectedPointForEdit(null); setSelectedCurveForEdit(null); };

          const toWorldBaseData = (points, curves) => {
              if (!points || points.length === 0) return { points, curves };
              const worldPoints = points.map(p => ({ x: p.x, y: p.y }));
              let worldCurves = null;
              if (curves) {
                  worldCurves = {};
                  Object.keys(curves).forEach(k => {
                      const cp = curves[k];
                      worldCurves[k] = { x: cp.x, y: cp.y };
                  });
              }
              return { points: worldPoints, curves: worldCurves };
          };
          const toWorldFloorPoints = (points) => {
              if (!points || points.length === 0) return points;
              const c = baseCentroid || { x: 0, y: 0 };
              return points.map(p => ({ x: p.x + c.x, y: p.y + c.y }));
          };
          const toWorldFloorCurves = (curves) => {
              if (!curves) return curves;
              const c = baseCentroid || { x: 0, y: 0 };
              const worldCurves = {};
              Object.keys(curves).forEach(k => {
                  const cp = curves[k];
                  worldCurves[k] = { x: cp.x + c.x, y: cp.y + c.y };
              });
              return worldCurves;
          };

          const updateSetting = (floorId, field, value) => {
              if (floorId === 'base') {
                  if (field === 'points') {
                      const { points: worldPoints, curves: worldCurves } = toWorldBaseData(value, displayLayer?.curves || baseCurves);
                      onUpdateSetting(floorId, 'points', worldPoints);
                      if (worldCurves) onUpdateSetting(floorId, 'curves', worldCurves);
                      const bounds = getPolygonBounds(worldPoints);
                      if (bounds) {
                          const baseWidthM = bounds.maxX - bounds.minX;
                          const baseDepthM = bounds.maxY - bounds.minY;
                          onUpdateInputs('baseWidthM', parseFloat(baseWidthM.toFixed(2)));
                          onUpdateInputs('baseDepthM', parseFloat(baseDepthM.toFixed(2)));
                      }
                      onUpdateInputs('baseVersion', (inputs.baseVersion || 0) + 1);
                      return;
                  }
                  if (field === 'curves') {
                      const { curves: worldCurves } = toWorldBaseData(displayLayer?.points || currentBasePoints, value);
                      onUpdateSetting(floorId, 'curves', worldCurves);
                      return;
                  }
              }
              if (field === 'points') {
                  const worldPoints = toWorldFloorPoints(value);
                  onUpdateSetting(floorId, 'points', worldPoints);
                  if (displayLayer?.curves) {
                      const worldCurves = toWorldFloorCurves(displayLayer.curves);
                      if (worldCurves) onUpdateSetting(floorId, 'curves', worldCurves);
                  }
                  return;
              }
              if (field === 'curves') {
                  const worldCurves = toWorldFloorCurves(value);
                  onUpdateSetting(floorId, 'curves', worldCurves);
                  return;
              }
              onUpdateSetting(floorId, field, value);
          };

          const handleDragMove = (e) => { if (!isDragging.current) return; if (selectedFloorId === 'base') return; const dxPx = (e.clientX - lastPos.current.x) / view.k; const dyPx = (e.clientY - lastPos.current.y) / view.k; const dxM = dxPx / scale; const dyM = dyPx / scale; if (selectedFloorId === 'excavation') return; updateSetting(displayLayer.id, 'offset_delta', { x: dxM, y: dyM }); lastPos.current = { x: e.clientX, y: e.clientY }; };
          const handleDragEnd = (e) => { isDragging.current = false; e.target.releasePointerCapture(e.pointerId); };

          const draggingPointIdx = useRef(null); const draggingCurveIdx = useRef(null); const [selectedIndices, setSelectedIndices] = useState(new Set()); const [lockedEdgeIndices, setLockedEdgeIndices] = useState(new Set()); const draggingEdgeIdx = useRef(null);

          const handlePointPointerDown = (e, idx) => {
              e.stopPropagation(); e.target.setPointerCapture(e.pointerId);
              let newSelected;
              if (e.shiftKey) { newSelected = new Set(selectedIndices); if (newSelected.has(idx)) { newSelected.delete(idx); draggingPointIdx.current = null; } else { newSelected.add(idx); draggingPointIdx.current = idx; } } else { if (selectedIndices.has(idx) && selectedIndices.size > 1) { newSelected = new Set(selectedIndices); } else { newSelected = new Set([idx]); } draggingPointIdx.current = idx; }
              setSelectedIndices(newSelected); lastPos.current = { x: e.clientX, y: e.clientY }; dragStartPos.current = { x: e.clientX, y: e.clientY }; dragStartPoint.current = displayLayer.points[idx]; 
              setSelectedPointForEdit({ idx, point: displayLayer.points[idx] }); setSelectedCurveForEdit(null);
              // Area Lock Init
              if (isAreaLocked && displayLayer.points) lockedAreaRef.current = calculatePolygonArea(displayLayer.points);
          };

          const handleCurvePointerDown = (e, idx) => { e.stopPropagation(); e.target.setPointerCapture(e.pointerId); draggingCurveIdx.current = idx; lastPos.current = { x: e.clientX, y: e.clientY }; dragStartPos.current = { x: e.clientX, y: e.clientY }; dragStartPoint.current = displayLayer.curves?.[idx] || {x:0, y:0}; setSelectedCurveForEdit(idx); setSelectedPointForEdit(null); };

          const handlePointPointerMove = (e) => {
             if (draggingPointIdx.current === null && draggingEdgeIdx.current === null && draggingCurveIdx.current === null) return;
             e.stopPropagation();
             let dxPx = (e.clientX - lastPos.current.x) / view.k; let dyPx = (e.clientY - lastPos.current.y) / view.k;
             if (e.shiftKey && (draggingPointIdx.current !== null || draggingCurveIdx.current !== null)) { const totalDx = e.clientX - dragStartPos.current.x; const totalDy = e.clientY - dragStartPos.current.y; if (Math.abs(totalDx) > Math.abs(totalDy)) { dyPx = 0; } else { dxPx = 0; } }
             const dxM = dxPx / scale; const dyM = dyPx / scale; 
             let localDx = dxM; let localDy = dyM;
             if (displayLayer.rotation) { const rotRad = -(displayLayer.rotation || 0) * (Math.PI / 180); const cos = Math.cos(rotRad); const sin = Math.sin(rotRad); localDx = dxM * cos - dyM * sin; localDy = dxM * sin + dyM * cos; }

             if (draggingCurveIdx.current !== null) {
                 const currentCurves = { ...(displayLayer.curves || {}) }; const idx = draggingCurveIdx.current; const oldC = currentCurves[idx] || { x:0, y:0 }; currentCurves[idx] = { x: oldC.x + localDx, y: oldC.y + localDy }; updateSetting(displayLayer.id, 'curves', currentCurves);
             } 
             else {
                 let currentPoints = [...displayLayer.points];
                 const indicesToMove = new Set();
                 if (draggingEdgeIdx.current !== null) { indicesToMove.add(draggingEdgeIdx.current); indicesToMove.add((draggingEdgeIdx.current + 1) % currentPoints.length); } else { indicesToMove.add(draggingPointIdx.current); selectedIndices.forEach(idx => indicesToMove.add(idx)); }
                 indicesToMove.forEach(idx => { const p = currentPoints[idx]; const newX = (p.x || 0) + localDx; const newY = (p.y || 0) + localDy; if (!isNaN(newX) && !isNaN(newY)) { currentPoints[idx] = { x: newX, y: newY }; } });
                 
                 // Task 1: Area Lock Logic
                if (isAreaLocked && lockedAreaRef.current) {
                    const newArea = Math.abs(calculatePolygonArea(currentPoints));
                    if (newArea > 0.001) {
                        const scaleFactor = Math.sqrt(Math.abs(lockedAreaRef.current) / newArea);
                         const centroid = getPolygonCentroid(currentPoints);
                         const scaled = scalePolygon(currentPoints, null, scaleFactor, centroid);
                         currentPoints = scaled.points;
                     }
                 }

                 updateSetting(displayLayer.id, 'points', currentPoints);
                 if (draggingPointIdx.current !== null) { setSelectedPointForEdit({ idx: draggingPointIdx.current, point: currentPoints[draggingPointIdx.current] }); }
             }
             lastPos.current = { x: e.clientX, y: e.clientY };
          };

          const handlePointPointerUp = (e) => { 
              draggingPointIdx.current = null; draggingEdgeIdx.current = null; draggingCurveIdx.current = null; 
              if (e && e.target && e.target.releasePointerCapture) { e.target.releasePointerCapture(e.pointerId); }
              if (onEditEnd && selectedFloorId === 'base') { onEditEnd('base', displayLayer.points); }
          };
          const handleEdgeContextMenu = (e, idx) => { e.preventDefault(); e.stopPropagation(); const newLocked = new Set(lockedEdgeIndices); if (newLocked.has(idx)) newLocked.delete(idx); else newLocked.add(idx); setLockedEdgeIndices(newLocked); };
          const handleEdgePointerDown = (e, idx) => { if (isRoadSelectMode && selectedFloorId === 'base') return; longPressTimer.current = setTimeout(() => { handleSegmentEdit(idx); }, 800); if (!lockedEdgeIndices.has(idx)) return; e.stopPropagation(); e.target.setPointerCapture(e.pointerId); draggingEdgeIdx.current = idx; lastPos.current = { x: e.clientX, y: e.clientY }; dragStartPos.current = { x: e.clientX, y: e.clientY }; setSelectedPointForEdit(null); setSelectedCurveForEdit(null); };
          const handleEdgePointerUp = () => { if (longPressTimer.current) clearTimeout(longPressTimer.current); handlePointPointerUp(); };

          const handleSegmentEdit = (idx) => {
              // Ensure we use the current display layer points (default or explicit)
              const pts = displayLayer.points;
              if (!pts) return;
              const p1 = pts[idx]; const p2 = pts[(idx + 1) % pts.length]; const currentLen = Math.hypot(p2.x - p1.x, p2.y - p1.y);
              const newLenStr = prompt(`目前邊長: ${currentLen.toFixed(2)}m\n請輸入新長度 (m):`, currentLen.toFixed(2));
              if (newLenStr !== null) {
                  const newLen = parseFloat(newLenStr);
                  if (!isNaN(newLen) && newLen > 0) {
                      const ratio = newLen / currentLen;
                      const newP2 = { x: p1.x + (p2.x - p1.x) * ratio, y: p1.y + (p2.y - p1.y) * ratio };
                      const newPoints = [...pts]; newPoints[(idx + 1) % pts.length] = newP2; updateSetting(displayLayer.id, 'points', newPoints);
                      if (onEditEnd && selectedFloorId === 'base') { onEditEnd('base', newPoints); }
                  }
              }
          };

          const handleLineClick = (e, idx1, idx2) => {
             e.stopPropagation();
             if (e.shiftKey) { handleSegmentEdit(idx1); return; }
             if (selectedFloorId === 'base') { if (isRoadSelectMode) return; if (interactionMode === 'set_back') { onUpdateEdgeTypes(idx1, 'back'); return; } if (interactionMode === 'set_side') { onUpdateEdgeTypes(idx1, 'side'); return; } }
             const pts = [...displayLayer.points]; const p1 = pts[idx1]; const p2 = pts[idx2]; const newP = { x: (p1.x + p2.x)/2, y: (p1.y + p2.y)/2 };
             const isClosing = (idx2 === 0 && idx1 === pts.length - 1); const insertIdx = isClosing ? pts.length : idx1 + 1;
             pts.splice(insertIdx, 0, newP); updateSetting(displayLayer.id, 'points', pts);
             if (onEditEnd && selectedFloorId === 'base') { onEditEnd('base', pts); }
             
             if (selectedFloorId === 'base') {
                 const newRoads = inputs.roads.map(r => { if (r.edgeIndex === undefined) return r; if (r.edgeIndex >= insertIdx) { return { ...r, edgeIndex: r.edgeIndex + 1 }; } return r; }); onUpdateRoads(newRoads);
                 const newFrontage = new Set(); frontageIndices.forEach(idx => { if (idx >= insertIdx) newFrontage.add(idx + 1); else newFrontage.add(idx); }); onUpdateFrontageIndices(newFrontage);
                 const newEdgeTypes = {}; Object.keys(edgeTypes).forEach(key => { const k = parseInt(key); const type = edgeTypes[k]; if (k >= insertIdx) newEdgeTypes[k + 1] = type; else newEdgeTypes[k] = type; }); 
                 if (edgeTypes[idx1]) newEdgeTypes[insertIdx] = edgeTypes[idx1];
                 onUpdateEdgeTypes(null, newEdgeTypes);
             }
          };

          const handleDeletePoint = (e, idx) => { e.preventDefault(); e.stopPropagation(); const pts = [...displayLayer.points]; if (pts.length <= 3) return; pts.splice(idx, 1); updateSetting(displayLayer.id, 'points', pts); if (selectedPointForEdit?.idx === idx) setSelectedPointForEdit(null); };
          const handlePointEdit = (axis, val) => { if (!selectedPointForEdit) return; const idx = selectedPointForEdit.idx; const pts = [...displayLayer.points]; pts[idx] = { ...pts[idx], [axis]: parseFloat(val) }; updateSetting(displayLayer.id, 'points', pts); setSelectedPointForEdit({ idx, point: pts[idx] }); };
          const generatePath = () => { if (!displayLayer.points) return ""; const pts = displayLayer.points; const curves = displayLayer.curves || {}; let d = `M ${(pts[0].x * scale)} ${(pts[0].y * scale)}`; for (let i = 0; i < pts.length; i++) { const nextP = pts[(i + 1) % pts.length]; const curve = curves[i]; if (curve) { d += ` Q ${(curve.x * scale)} ${(curve.y * scale)}, ${(nextP.x * scale)} ${(nextP.y * scale)}`; } else { d += ` L ${(nextP.x * scale)} ${(nextP.y * scale)}`; } } d += " Z"; return d; };
          const renderCurveHandles = () => { if (!displayLayer.points) return null; return displayLayer.points.map((p, i) => { const nextI = (i + 1) % displayLayer.points.length; const nextP = displayLayer.points[nextI]; const curve = displayLayer.curves?.[i]; const isEdgeSelected = selectedIndices.has(i) && selectedIndices.has(nextI); if (isEdgeSelected || curve) { const cpX = curve ? curve.x : (p.x + nextP.x)/2; const cpY = curve ? curve.y : (p.y + nextP.y)/2; return ( <g key={`curve-${i}`} transform={`translate(${cpX * scale}, ${cpY * scale})`}> <line x1={(p.x - cpX)*scale} y1={(p.y - cpY)*scale} x2={0} y2={0} stroke="#93c5fd" strokeDasharray="3" strokeWidth="1" /> <line x1={(nextP.x - cpX)*scale} y1={(nextP.y - cpY)*scale} x2={0} y2={0} stroke="#93c5fd" strokeWidth="1" strokeDasharray="3" /> <circle data-type="curve-handle" r="6" fill="#f59e0b" stroke="white" strokeWidth="2" className="cursor-crosshair hover:scale-125 transition-transform" onPointerDown={(e) => { if (!curve) { const newCurves = { ...(displayLayer.curves || {}), [i]: {x: cpX, y: cpY} }; updateSetting(displayLayer.id, 'curves', newCurves); } handleCurvePointerDown(e, i); }} onPointerMove={handlePointPointerMove} onPointerUp={handlePointPointerUp} onDoubleClick={(e) => { e.stopPropagation(); const newCurves = { ...(displayLayer.curves || {}) }; delete newCurves[i]; updateSetting(displayLayer.id, 'curves', newCurves); setSelectedCurveForEdit(null); }} /> </g> ) } return null; }); };
          const baseItemScale = 80 / Math.max(baseWidthM, baseDepthM);

          // --- Visualization Logic for Edge Types ---
          const vizPrimaryIndices = new Set();
          const vizSecondaryIndices = new Set();
          if (inputs.roads) {
             inputs.roads.forEach(r => {
                 const indices = new Set();
                 if (r.edgeIndices) r.edgeIndices.forEach(i => indices.add(i));
                 if (r.edgeIndex !== undefined && r.edgeIndex !== "") indices.add(parseInt(r.edgeIndex));
                 if (r.type === 'primary') indices.forEach(i => vizPrimaryIndices.add(i));
                 else indices.forEach(i => vizSecondaryIndices.add(i));
             });
          }
          const vizFrontIndices = new Set();
          if (frontageIndices && frontageIndices.size > 0) {
               frontageIndices.forEach(i => vizFrontIndices.add(i));
          } else {
               vizPrimaryIndices.forEach(i => vizFrontIndices.add(i));
               if (vizPrimaryIndices.size === 0 && vizSecondaryIndices.size > 0) vizSecondaryIndices.forEach(i => vizFrontIndices.add(i));
          }
          const vizCombinedEdgeTypes = { ...edgeTypes };
          vizSecondaryIndices.forEach(idx => {
              if (!vizFrontIndices.has(idx) && !vizCombinedEdgeTypes[idx]) {
                  vizCombinedEdgeTypes[idx] = 'side';
              }
          });

          // Calculate Setback Polygon for Visualization
          const setbackPoly = useMemo(() => {
              // Always use currentBasePoints (which is either explicit or default rect) for visualization
              const pts = selectedFloorId === 'base' ? currentBasePoints : basePoints;

              if (selectedFloorId === 'base' && pts) {
                  const front = parseFloat(inputs.frontYardDepth || 0);
                  const back = parseFloat(inputs.backYardDepth || 0);
                  const side = parseFloat(inputs.sideYardDepth || 0);
                  const res = offsetPolygon(pts, vizCombinedEdgeTypes, { front, back, side }, vizFrontIndices, baseCurves);
                  return res ? res.points : null;
              }
              return null;
          }, [selectedFloorId, basePoints, currentBasePoints, baseCurves, vizCombinedEdgeTypes, vizFrontIndices, inputs.frontYardDepth, inputs.backYardDepth, inputs.sideYardDepth]);
          // ------------------------------------------
          
          const regionPaths = useMemo(() => {
              if (selectedFloorId !== 'base' || !currentBasePoints || currentBasePoints.length < 3) return { paths: [], labels: [] };
              const { points: densePoints, edgeMap } = discretizePolygon(currentBasePoints, baseCurves, 15);
              if (!densePoints || densePoints.length < 2) return { paths: [], labels: [] };
              const centroid = getPolygonCentroid(densePoints);
              const frontDepth = parseFloat(inputs.frontYardDepth || 0);
              const backDepth = parseFloat(inputs.backYardDepth || 0);
              const sideDepth = parseFloat(inputs.sideYardDepth || 0);
              const arcadeDepth = (inputs.frontYardDepth == 0 && inputs.arcadeDepth) ? parseFloat(inputs.arcadeDepth) : 0;
              const combinedEdgeTypes = { ...vizCombinedEdgeTypes };
              const hasExplicitBack = Object.values(combinedEdgeTypes).includes('back');
              const hasExplicitSide = Object.values(combinedEdgeTypes).includes('side');
              let frontNormal = { x: 0, y: 0 };
              let frontCount = 0;
              densePoints.forEach((p, i) => {
                  const origIdx = edgeMap[i];
                  if (vizFrontIndices.has(origIdx)) {
                      const p2 = densePoints[(i + 1) % densePoints.length];
                      const n = getSegmentNormal(p, p2, centroid);
                      frontNormal.x += n.x;
                      frontNormal.y += n.y;
                      frontCount++;
                  }
              });
              if (frontCount > 0) {
                  const len = Math.hypot(frontNormal.x, frontNormal.y);
                  if (len > 0) { frontNormal.x /= len; frontNormal.y /= len; }
                  if (!hasExplicitBack) {
                      densePoints.forEach((p, i) => {
                          const origIdx = edgeMap[i];
                          if (vizFrontIndices.has(origIdx) || combinedEdgeTypes[origIdx]) return;
                          const p2 = densePoints[(i + 1) % densePoints.length];
                          const n = getSegmentNormal(p, p2, centroid);
                          const dot = n.x * frontNormal.x + n.y * frontNormal.y;
                          if (dot < -0.5) combinedEdgeTypes[origIdx] = 'back';
                      });
                  }
                  if (!hasExplicitSide && sideDepth > 0) {
                      const desiredSign = (inputs.sideYardDirection || 'right') === 'left' ? 1 : -1;
                      const candidates = [];
                      densePoints.forEach((p, i) => {
                          const origIdx = edgeMap[i];
                          if (vizFrontIndices.has(origIdx) || combinedEdgeTypes[origIdx]) return;
                          const p2 = densePoints[(i + 1) % densePoints.length];
                          const n = getSegmentNormal(p, p2, centroid);
                          const dot = n.x * frontNormal.x + n.y * frontNormal.y;
                          const cross = frontNormal.x * n.y - frontNormal.y * n.x;
                          candidates.push({ origIdx, dot, cross });
                      });
                      let selected = candidates.filter(c => Math.abs(c.dot) < 0.3 && desiredSign * c.cross > 0);
                      if (selected.length === 0) {
                          selected = candidates.filter(c => desiredSign * c.cross > 0).sort((a, b) => Math.abs(a.dot) - Math.abs(b.dot));
                      }
                      selected.forEach(c => { combinedEdgeTypes[c.origIdx] = 'side'; });
                  }
              }
              if (sideDepth > 0 && !Object.values(combinedEdgeTypes).includes('side')) {
                  for (let idx = 0; idx < currentBasePoints.length; idx++) {
                      if (!vizFrontIndices.has(idx) && !combinedEdgeTypes[idx]) {
                          combinedEdgeTypes[idx] = 'side';
                      }
                  }
              }
              const getDepthByType = (type) => {
                  if (type === 'front') return arcadeDepth > 0 ? arcadeDepth : frontDepth;
                  if (type === 'back') return backDepth;
                  if (type === 'side') return sideDepth;
                  return 0;
              };
              const getRegionType = (origIdx) => {
                  if (vizFrontIndices.has(origIdx)) return 'front';
                  if (combinedEdgeTypes[origIdx] === 'back') return 'back';
                  if (combinedEdgeTypes[origIdx] === 'side') return 'side';
                  return null;
              };
              const buildOffsetPoints = (activeType) => {
                  const shiftedLines = [];
                  for (let i = 0; i < densePoints.length; i++) {
                      const p1 = densePoints[i];
                      const p2 = densePoints[(i + 1) % densePoints.length];
                      const origIdx = edgeMap[i];
                      const regionType = getRegionType(origIdx);
                      const depth = regionType === activeType ? getDepthByType(regionType) : 0;
                      const n = getSegmentNormal(p1, p2, centroid);
                      shiftedLines.push({
                          p1: { x: p1.x + n.x * depth, y: p1.y + n.y * depth },
                          p2: { x: p2.x + n.x * depth, y: p2.y + n.y * depth }
                      });
                  }
                  const newPoints = [];
                  for (let i = 0; i < shiftedLines.length; i++) {
                      const l1 = shiftedLines[i];
                      const l2 = shiftedLines[(i + 1) % shiftedLines.length];
                      const intersect = getLineIntersection(l1.p1, l1.p2, l2.p1, l2.p2);
                      newPoints.push(intersect || l1.p2);
                  }
                  return newPoints;
              };
              const buildRingPath = (innerPts) => {
                  if (!innerPts || innerPts.length < 3) return null;
                  let dPath = "";
                  densePoints.forEach((p, i) => {
                      const x = p.x * scale;
                      const y = p.y * scale;
                      if (i === 0) dPath += `M ${x} ${y}`;
                      else dPath += ` L ${x} ${y}`;
                  });
                  dPath += " Z";
                  const inner = [...innerPts].reverse();
                  inner.forEach((p, i) => {
                      const x = p.x * scale;
                      const y = p.y * scale;
                      if (i === 0) dPath += ` M ${x} ${y}`;
                      else dPath += ` L ${x} ${y}`;
                  });
                  dPath += " Z";
                  return dPath;
              };
              const regionTypes = ['front', 'back', 'side'];
              const paths = [];
              regionTypes.forEach(type => {
                  const depth = getDepthByType(type);
                  if (depth <= 0) return;
                  let hasEdge = false;
                  for (let i = 0; i < edgeMap.length; i++) {
                      if (getRegionType(edgeMap[i]) === type) { hasEdge = true; break; }
                  }
                  if (!hasEdge) return;
                  const innerPts = buildOffsetPoints(type);
                  const dPath = buildRingPath(innerPts);
                  if (dPath) paths.push({ d: dPath, type });
              });
              const labels = [];
              const labelByType = { front: arcadeDepth > 0 ? "騎樓" : "前院", back: "後院", side: "側院" };
              const segmentsByOrig = new globalThis.Map();
              for (let i = 0; i < edgeMap.length; i++) {
                  const orig = edgeMap[i];
                  if (!segmentsByOrig.has(orig)) segmentsByOrig.set(orig, []);
                  segmentsByOrig.get(orig).push(i);
              }
              segmentsByOrig.forEach((segments, origIdx) => {
                  const regionType = getRegionType(origIdx);
                  if (!regionType) return;
                  const depth = getDepthByType(regionType);
                  if (depth <= 0) return;
                  const midSeg = segments[Math.floor(segments.length / 2)];
                  const p1 = densePoints[midSeg];
                  const p2 = densePoints[(midSeg + 1) % densePoints.length];
                  if (!p1 || !p2) return;
                  const mid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                  const n = getSegmentNormal(p1, p2, centroid);
                  labels.push({
                      x: mid.x + n.x * depth * 0.5,
                      y: mid.y + n.y * depth * 0.5,
                      text: labelByType[regionType],
                      type: regionType,
                      key: `${regionType}-${origIdx}`
                  });
              });
              return { paths, labels };
          }, [selectedFloorId, currentBasePoints, baseCurves, vizFrontIndices, vizCombinedEdgeTypes, inputs.frontYardDepth, inputs.backYardDepth, inputs.sideYardDepth, inputs.sideYardDirection, inputs.arcadeDepth, scale]);
          
          return (
              <div className="w-full h-full flex flex-col relative overflow-hidden bg-stone-50" ref={containerRef} onPointerDown={(e) => { e.stopPropagation(); handlePanStart(e); }} onClick={(e) => e.stopPropagation()}>
                  {displayLayer && (
                      <div className="absolute top-16 left-4 z-50 flex gap-2">
                          <button onClick={onClose} className="p-2 bg-white/90 rounded-full hover:bg-red-50 text-stone-500 hover:text-red-500 shadow-md border border-stone-200 transition-colors" title="結束編輯"> <Undo2 size={20}/> </button>
                          {selectedFloorId !== 'base' && selectedFloorId !== 'excavation' && (
                              <button onClick={() => onUpdateUnitSettings(prev => ({...prev, enabled: !prev.enabled, target: selectedFloorId}))} className={`flex items-center gap-1 px-2.5 py-1.5 rounded-full shadow-md border transition-colors ${unitSettings?.enabled ? 'bg-indigo-600 text-white border-indigo-700' : 'bg-white/90 text-stone-600 border-stone-200 hover:bg-indigo-50'}`} title="分戶功能">
                                  <LayoutDashboard size={16}/>
                                  <span className="text-xs font-bold">分戶</span>
                              </button>
                          )}
                      </div>
                  )}
                  {unitSettings?.enabled && displayLayer && (
                      <div className="absolute top-28 left-4 z-50 bg-white p-4 rounded shadow-lg border border-stone-200 w-64">
                          <h3 className="font-bold text-sm mb-2">分戶設定</h3>
                          <div className="mb-2">
                              <label className="text-xs text-stone-500 block">分戶方式</label>
                              <div className="flex gap-2 mt-1">
                                  <button onClick={()=>onUpdateUnitSettings(p=>({...p, mode:'ratio'}))} className={`flex-1 text-xs py-1 border rounded ${unitSettings.mode==='ratio'?'bg-indigo-50 border-indigo-500 text-indigo-600':'bg-stone-50'}`}>比例</button>
                                  <button onClick={()=>onUpdateUnitSettings(p=>({...p, mode:'count'}))} className={`flex-1 text-xs py-1 border rounded ${unitSettings.mode==='count'?'bg-indigo-50 border-indigo-500 text-indigo-600':'bg-stone-50'}`}>戶數</button>
                                  <button onClick={()=>onUpdateUnitSettings(p=>({...p, mode:'area'}))} className={`flex-1 text-xs py-1 border rounded ${unitSettings.mode==='area'?'bg-indigo-50 border-indigo-500 text-indigo-600':'bg-stone-50'}`}>每戶坪</button>
                              </div>
                          </div>
                          <div className="mb-2">
                              <label className="text-xs text-stone-500 block">分割方向</label>
                              <div className="flex gap-2 mt-1">
                                  <button onClick={()=>onUpdateUnitSettings(p=>({...p, axis:'x'}))} className={`flex-1 text-xs py-1 border rounded ${unitSettings.axis==='x'?'bg-indigo-50 border-indigo-500 text-indigo-600':'bg-stone-50'}`}>垂直 (X)</button>
                                  <button onClick={()=>onUpdateUnitSettings(p=>({...p, axis:'y'}))} className={`flex-1 text-xs py-1 border rounded ${unitSettings.axis==='y'?'bg-indigo-50 border-indigo-500 text-indigo-600':'bg-stone-50'}`}>水平 (Y)</button>
                              </div>
                          </div>
                          {unitSettings.mode === 'ratio' && (
                              <div className="mb-2">
                                  <label className="text-xs text-stone-500 block">分割比例 ({Math.round(unitSettings.ratio*100)}:{Math.round((1-unitSettings.ratio)*100)})</label>
                                  <input type="range" min="0.1" max="0.9" step="0.05" value={unitSettings.ratio} onChange={(e)=>onUpdateUnitSettings(p=>({...p, ratio: parseFloat(e.target.value)}))} className="w-full" />
                              </div>
                          )}
                          {unitSettings.mode === 'count' && (
                              <div className="mb-2">
                                  <label className="text-xs text-stone-500 block">戶數</label>
                                  <input type="number" min="1" step="1" value={unitSettings.count} onChange={(e)=>onUpdateUnitSettings(p=>({...p, count: Math.max(1, parseInt(e.target.value || '1'))}))} className="w-full text-xs p-1 border rounded" />
                              </div>
                          )}
                          {unitSettings.mode === 'area' && (
                              <div className="mb-2">
                                  <label className="text-xs text-stone-500 block">每戶面積 (坪)</label>
                                  <input type="number" min="0.5" step="0.5" value={unitSettings.areaPerUnit} onChange={(e)=>onUpdateUnitSettings(p=>({...p, areaPerUnit: Math.max(0.5, parseFloat(e.target.value || '0.5'))}))} className="w-full text-xs p-1 border rounded" />
                                  <div className="text-[10px] text-stone-400 mt-1">預估戶數: {Math.max(1, Math.round(toPing(calculatePolygonArea(displayLayer.points || [])) / Math.max(0.5, unitSettings.areaPerUnit || 0.5)))}</div>
                              </div>
                          )}
                          <div className="mb-4">
                              <label className="text-xs text-stone-500 block">棟距 (Gap): {unitSettings.gap}m</label>
                              <input type="range" min="0" max="5" step="0.1" value={unitSettings.gap} onChange={(e)=>onUpdateUnitSettings(p=>({...p, gap: parseFloat(e.target.value)}))} className="w-full" />
                          </div>
                          <div className="flex gap-2">
                              <button onClick={()=>{
                                   const units = getSplitUnits(displayLayer.points, unitSettings);
                                   updateSetting(displayLayer.id, 'units', units);
                                   onUpdateUnitSettings(prev => ({...prev, enabled: false}));
                              }} className="flex-1 bg-indigo-600 text-white text-xs py-1.5 rounded hover:bg-indigo-700">確認分割</button>
                              <button onClick={()=>onUpdateUnitSettings(prev => ({...prev, enabled: false}))} className="flex-1 bg-white border border-stone-300 text-stone-600 text-xs py-1.5 rounded hover:bg-stone-50">取消</button>
                          </div>
                      </div>
                  )}
                  {!displayLayer && (
                    <div className="absolute top-4 left-1/2 -translate-x-1/2 z-50 flex gap-2">
                       <div className="flex bg-white shadow rounded-full border border-stone-200 overflow-hidden items-center">
                           <button onClick={onRemoveFloor} className="px-1 py-0.5 text-[8px] font-semibold hover:bg-stone-50 border-r flex items-center"><MinusCircle size={10}/></button>
                           <span className="px-1 py-0.5 text-[8px] font-semibold text-stone-600">地上層</span>
                           <button onClick={onAddFloor} className="px-1 py-0.5 text-[8px] font-semibold hover:bg-stone-50 border-l flex items-center"><Plus size={10}/></button>
                        </div>
                        <div className="flex bg-white shadow rounded-full border border-stone-200 overflow-hidden items-center">
                           <button onClick={() => onUpdateInputs('floorsBelow', Math.max(0, inputs.floorsBelow - 1))} className="px-1 py-0.5 text-[8px] font-semibold hover:bg-stone-50 border-r flex items-center"><MinusCircle size={10}/></button>
                           <span className="px-1 py-0.5 text-[8px] font-semibold text-stone-600">地下層</span>
                           <button onClick={() => onUpdateInputs('floorsBelow', inputs.floorsBelow + 1)} className="px-1 py-0.5 text-[8px] font-semibold hover:bg-stone-50 border-l flex items-center"><Plus size={10}/></button>
                        </div>
                       <div className="flex items-center gap-2 bg-white shadow rounded-full border border-stone-200 px-1 py-0.5">
                           <span className="text-[8px] text-stone-400 font-semibold">樓層配置</span>
                           <div className="flex items-center gap-1">
                               <span className="text-[8px] text-stone-400">地上</span>
                              <input type="number" min="1" value={floorsAboveValue} onChange={(e)=>onUpdateFloorsAbove && onUpdateFloorsAbove(parseFloat(e.target.value || '1'))} className="w-8 text-[8px] text-right border border-stone-200 rounded px-1 py-0.5" />
                            </div>
                            <div className="flex items-center gap-1">
                               <span className="text-[8px] text-stone-400">地下</span>
                               <input type="number" min="0" value={inputs.floorsBelow} onChange={(e)=>onUpdateInputs('floorsBelow', Math.max(0, parseInt(e.target.value || '0')))} className="w-8 text-[8px] text-right border border-stone-200 rounded px-1 py-0.5" />
                            </div>
                        </div>
                        <div className="flex bg-white shadow rounded-full border border-stone-200 overflow-hidden items-center">
                            <button
                               onClick={()=>{
                                   const firstFloor = (layers || []).find(l => l.id !== 'base' && l.id !== 'excavation');
                                   onUpdateUnitSettings(prev => ({...prev, enabled: !prev.enabled, target: prev.target || (firstFloor ? firstFloor.id : null)}));
                               }}
                               className={`px-2 py-0.5 text-[10px] font-bold rounded ${unitSettings?.enabled ? 'bg-indigo-600 text-white' : 'text-stone-600 hover:bg-stone-50'}`}
                               title="分戶功能">
                               <LayoutDashboard size={12}/>
                               <span className="ml-1">分戶</span>
                            </button>
                        </div>
                    </div>
                  )}
                  {unitSettings?.enabled && !displayLayer && (
                      <div className="absolute top-20 left-1/2 -translate-x-1/2 z-50 bg-white p-4 rounded shadow-lg border border-stone-200 w-72">
                          <h3 className="font-bold text-sm mb-2">分戶設定</h3>
                          <div className="mb-2">
                              <label className="text-xs text-stone-500 block">樓層</label>
                              <select
                                  value={unitSettings.target || ''}
                                  onChange={(e)=>onUpdateUnitSettings(p=>({...p, target: e.target.value}))}
                                  className="w-full text-xs p-1 border rounded bg-white">
                                  {(layers || []).filter(l=>l.id!=='base' && l.id!=='excavation').map(l=>(
                                      <option key={l.id} value={l.id}>{l.id}</option>
                                  ))}
                              </select>
                          </div>
                          <div className="mb-2">
                              <label className="text-xs text-stone-500 block">分戶方式</label>
                              <div className="flex gap-2 mt-1">
                                  <button onClick={()=>onUpdateUnitSettings(p=>({...p, mode:'ratio'}))} className={`flex-1 text-xs py-1 border rounded ${unitSettings.mode==='ratio'?'bg-indigo-50 border-indigo-500 text-indigo-600':'bg-stone-50'}`}>比例</button>
                                  <button onClick={()=>onUpdateUnitSettings(p=>({...p, mode:'count'}))} className={`flex-1 text-xs py-1 border rounded ${unitSettings.mode==='count'?'bg-indigo-50 border-indigo-500 text-indigo-600':'bg-stone-50'}`}>戶數</button>
                                  <button onClick={()=>onUpdateUnitSettings(p=>({...p, mode:'area'}))} className={`flex-1 text-xs py-1 border rounded ${unitSettings.mode==='area'?'bg-indigo-50 border-indigo-500 text-indigo-600':'bg-stone-50'}`}>每戶坪</button>
                              </div>
                          </div>
                          <div className="mb-2">
                              <label className="text-xs text-stone-500 block">分割方向</label>
                              <div className="flex gap-2 mt-1">
                                  <button onClick={()=>onUpdateUnitSettings(p=>({...p, axis:'x'}))} className={`flex-1 text-xs py-1 border rounded ${unitSettings.axis==='x'?'bg-indigo-50 border-indigo-500 text-indigo-600':'bg-stone-50'}`}>垂直 (X)</button>
                                  <button onClick={()=>onUpdateUnitSettings(p=>({...p, axis:'y'}))} className={`flex-1 text-xs py-1 border rounded ${unitSettings.axis==='y'?'bg-indigo-50 border-indigo-500 text-indigo-600':'bg-stone-50'}`}>水平 (Y)</button>
                              </div>
                          </div>
                          {unitSettings.mode === 'ratio' && (
                              <div className="mb-2">
                                  <label className="text-xs text-stone-500 block">分割比例 ({Math.round(unitSettings.ratio*100)}:{Math.round((1-unitSettings.ratio)*100)})</label>
                                  <input type="range" min="0.1" max="0.9" step="0.05" value={unitSettings.ratio} onChange={(e)=>onUpdateUnitSettings(p=>({...p, ratio: parseFloat(e.target.value)}))} className="w-full" />
                              </div>
                          )}
                          {unitSettings.mode === 'count' && (
                              <div className="mb-2">
                                  <label className="text-xs text-stone-500 block">戶數</label>
                                  <input type="number" min="1" step="1" value={unitSettings.count} onChange={(e)=>onUpdateUnitSettings(p=>({...p, count: Math.max(1, parseInt(e.target.value || '1'))}))} className="w-full text-xs p-1 border rounded" />
                              </div>
                          )}
                          {unitSettings.mode === 'area' && (
                              <div className="mb-2">
                                  <label className="text-xs text-stone-500 block">每戶面積 (坪)</label>
                                  <input type="number" min="0.5" step="0.5" value={unitSettings.areaPerUnit} onChange={(e)=>onUpdateUnitSettings(p=>({...p, areaPerUnit: Math.max(0.5, parseFloat(e.target.value || '0.5'))}))} className="w-full text-xs p-1 border rounded" />
                                  <div className="text-[10px] text-stone-400 mt-1">
                                      {(() => {
                                          const tId = unitSettings.target;
                                          const layer = (layers || []).find(l => l.id === tId);
                                          const area = layer && layer.points ? calculatePolygonArea(layer.points) : (layer ? (layer.realWidth || 0) * (layer.realDepth || 0) : 0);
                                          const per = Math.max(0.5, unitSettings.areaPerUnit || 0.5);
                                          const est = area > 0 ? Math.max(1, Math.round(toPing(area) / per)) : 1;
                                          return `預估戶數: ${est}`;
                                      })()}
                                  </div>
                              </div>
                          )}
                          <div className="mb-4">
                              <label className="text-xs text-stone-500 block">棟距 (Gap): {unitSettings.gap}m</label>
                              <input type="range" min="0" max="5" step="0.1" value={unitSettings.gap} onChange={(e)=>onUpdateUnitSettings(p=>({...p, gap: parseFloat(e.target.value)}))} className="w-full" />
                          </div>
                          <div className="flex gap-2">
                              <button onClick={()=>{
                                   const tId = unitSettings.target;
                                   const layer = (layers || []).find(l => l.id === tId);
                                   if (!layer) return;
                                   const units = getSplitUnits(layer.points, unitSettings);
                                   updateSetting(tId, 'units', units);
                                   onUpdateUnitSettings(prev => ({...prev, enabled: false}));
                              }} className="flex-1 bg-indigo-600 text-white text-xs py-1.5 rounded hover:bg-indigo-700">確認分割</button>
                              <button onClick={()=>onUpdateUnitSettings(prev => ({...prev, enabled: false}))} className="flex-1 bg-white border border-stone-300 text-stone-600 text-xs py-1.5 rounded hover:bg-stone-50">取消</button>
                          </div>
                      </div>
                  )}
                  {displayLayer ? (
                      <>
                      {selectedFloorId !== 'base' && selectedFloorId !== 'excavation' && (
                <div className="absolute top-32 left-4 z-40 flex gap-2 pointer-events-auto">
                          <button
                              onClick={()=>{
                                  let payload = {};
                                  if (displayLayer.points && displayLayer.points.length>=3) {
                                      const area = calculatePolygonArea(displayLayer.points);
                                      payload = { mode: 'polygon', points: displayLayer.points, curves: displayLayer.curves || null, area };
                                  } else {
                                      const w = displayLayer.realWidth || baseWidthM;
                                      const h = displayLayer.realDepth || baseDepthM;
                                      payload = { mode: 'box', width: w, depth: h, area: (w*h) };
                                  }
                                  onApplyAll && onApplyAll(payload);
                              }}
                            className={`px-2 py-0.5 text-[10px] font-bold rounded-full border shadow-sm flex items-center gap-1 ${isDarkMode ? 'bg-slate-800/80 text-white border-slate-700 hover:bg-slate-700' : 'bg-white text-stone-700 border-stone-200 hover:bg-stone-50'}`}
                              title="將目前樓板形狀與面積一鍵套用至所有地上樓層，並自動依總樓地板面積調整樓層數量"
                          >
                              套用至所有樓層
                          </button>
                      </div>
                      )}
                      <div className={`flex-1 flex items-center justify-center p-0 transition-all duration-300 overflow-hidden cursor-pan ${isPanning ? 'cursor-grabbing' : ''}`} onWheel={onWheel} onPointerDown={handlePanStart} onPointerMove={handlePanMove} onPointerUp={handlePanEnd} onPointerLeave={handlePanEnd} onTouchStart={handleTouchPanStart} onTouchMove={handleTouchPanMove} onTouchEnd={handleTouchPanEnd} onTouchCancel={handleTouchPanEnd}>
                          {selectedPointForEdit && ( <CoordinatePopup point={selectedPointForEdit.point} idx={selectedPointForEdit.idx} onChange={handlePointEdit} scale={view.k} isDarkMode={isDarkMode} /> )}
                          <div className="relative pointer-events-none" style={{ transform: `translate(${view.x}px, ${view.y}px) scale(${view.k})`, transformOrigin: 'center', transition: isPanning ? 'none' : 'transform 0.1s' }}>
                              <svg width={baseW + 400} height={baseH + 400} viewBox={`-${baseW/2 + 200} -${baseH/2 + 200} ${baseW + 400} ${baseH + 400}`} className="overflow-visible shadow-xl bg-white rounded-lg pointer-events-auto">
                                  <rect id="bg-rect" x={-baseW/2 - 200} y={-baseH/2 - 200} width={baseW + 400} height={baseH + 400} fill="transparent" />
                                  {/* Background Layer: Use currentBasePoints (Explicit or Default Rect) */}
                                  {selectedFloorId !== 'base' && ( 
                                     <path d={generateSvgPath(currentBasePoints, baseCurves, scale)} fill={isDarkMode ? "#1e293b" : "#f5f5f4"} stroke={isDarkMode ? "#475569" : "#d6d3d1"} strokeWidth="1" /> 
                                  )}

                                  {selectedFloorId !== 'excavation' && selectedFloorId !== 'base' && excavationPoints && ( <path d={generateSvgPath(excavationPoints, excavationCurves, scale)} fill="none" stroke="#f59e0b" strokeWidth="1" strokeDasharray="4,4" opacity="0.5"/> )}
                                 <g transform={`translate(${xPos}, ${yPos}) rotate(${displayLayer.rotation || 0})`} className="cursor-move" onPointerDown={handleDragStart} onPointerMove={handleDragMove} onPointerUp={handleDragEnd}>
                                   {selectedFloorId === 'base' && regionPaths.paths.length > 0 && (
                                        <g pointerEvents="none">
                                            {regionPaths.paths.map((path, idx) => {
                                                const isBackMode = interactionMode === 'set_back';
                                                const isSideMode = interactionMode === 'set_side';
                                                let opacity = 0.18;
                                                if (isBackMode) opacity = path.type === 'back' ? 0.32 : 0.06;
                                                else if (isSideMode) opacity = path.type === 'side' ? 0.32 : 0.06;
                                                const colorMap = path.type === 'front'
                                                    ? { fill: "#ef4444", stroke: "#ef4444" }
                                                    : path.type === 'back'
                                                        ? { fill: "#10b981", stroke: "#10b981" }
                                                        : { fill: "#3b82f6", stroke: "#3b82f6" };
                                                return (
                                                    <path key={`region-path-${idx}-${path.type}`} d={path.d} fill={colorMap.fill} fillOpacity={opacity} stroke={colorMap.stroke} strokeWidth="1" />
                                                );
                                            })}
                                            {regionPaths.labels.map(label => {
                                                const isBackMode = interactionMode === 'set_back';
                                                const isSideMode = interactionMode === 'set_side';
                                                let opacity = 0.7;
                                                if (isBackMode) opacity = label.type === 'back' ? 0.9 : 0.3;
                                                else if (isSideMode) opacity = label.type === 'side' ? 0.9 : 0.3;
                                                const colorMap = label.type === 'front'
                                                    ? { fill: "#ef4444" }
                                                    : label.type === 'back'
                                                        ? { fill: "#10b981" }
                                                        : { fill: "#3b82f6" };
                                                return (
                                                    <text key={label.key} x={label.x * scale} y={label.y * scale} textAnchor="middle" dominantBaseline="middle" fontSize="10" fill={colorMap.fill} opacity={opacity} className="select-none">
                                                        {label.text}
                                                    </text>
                                                );
                                            })}
                                        </g>
                                    )}
                                      {displayLayer.points ? (
                                          <>
                                              {previewUnits ? (
                                                  previewUnits.map((pts, i) => (
                                                      <path key={`preview-${i}`} d={generateSvgPath(pts, null, scale)} fill="rgba(99, 102, 241, 0.5)" stroke="#4f46e5" strokeWidth="2" />
                                                  ))
                                              ) : unitsToRender ? (
                                                  <>
                                                      <path d={generatePath()} fill="none" stroke={displayLayer.isViolation ? "#ef4444" : (selectedFloorId === 'base' ? "#78716c" : "#0284c7")} strokeWidth="2" opacity="0.7" />
                                                      {unitsToRender.map((pts, i) => {
                                                          const centroid = getPolygonCentroid(pts);
                                                          const fillOpacity = Math.min(0.85, 0.55 + i * 0.1);
                                                          return (
                                                              <g key={`unit-${i}`}>
                                                                  <path d={generateSvgPath(pts, null, scale)} fill={`rgba(99, 102, 241, ${fillOpacity})`} opacity="0.85" />
                                                                  <text x={centroid.x * scale} y={centroid.y * scale} textAnchor="middle" dominantBaseline="middle" fontSize="10" fill={isDarkMode ? "#ffffff" : "#0f172a"} className="select-none pointer-events-none font-mono">
                                                                      {String.fromCharCode(65 + i)} ({formatNum(toPing(calculatePolygonArea(pts)))}坪)
                                                                  </text>
                                                              </g>
                                                          );
                                                      })}
                                                  </>
                                              ) : (
                                                  <path d={generatePath()} fill={selectedFloorId === 'excavation' ? "rgba(245, 158, 11, 0.1)" : (displayLayer.isViolation ? "rgba(239, 68, 68, 0.5)" : (selectedFloorId === 'base' ? "#f5f5f4" : (isDarkMode ? "#38bdf8" : "#0ea5e9")))} stroke={selectedFloorId === 'excavation' ? "#f59e0b" : (displayLayer.isViolation ? "#ef4444" : (selectedFloorId === 'base' ? "#78716c" : "#0284c7"))} strokeWidth={selectedFloorId === 'excavation' ? "2" : "2"} strokeDasharray={selectedFloorId === 'excavation' ? "4,2" : "none"} opacity="0.9" />
                                              )}
                                              {displayLayer.points.map((p, i) => {
                                                  const nextI = (i + 1) % displayLayer.points.length; const nextP = displayLayer.points[nextI]; const isLocked = lockedEdgeIndices.has(i); const curve = displayLayer.curves?.[i];
                                                  const isFrontage = selectedFloorId === 'base' && vizFrontIndices.has(i);
                                                  const isBack = selectedFloorId === 'base' && vizCombinedEdgeTypes[i] === 'back'; const isSide = selectedFloorId === 'base' && vizCombinedEdgeTypes[i] === 'side';
                                                  let strokeColor = (isLocked ? "#ef4444" : "transparent"); if (isFrontage) strokeColor = "#ef4444"; else if (isBack) strokeColor = "#10b981"; else if (isSide) strokeColor = "#3b82f6";
                                                  const strokeWidth = (isFrontage || isBack || isSide) ? "4" : (isLocked ? "3" : "15"); const opacity = (isFrontage || isBack || isSide) ? 0.8 : 1;
                                                  let edgeD = `M ${p.x * scale} ${p.y * scale}`; if (curve) { edgeD += ` Q ${curve.x * scale} ${curve.y * scale}, ${nextP.x * scale} ${nextP.y * scale}`; } else { edgeD += ` L ${nextP.x * scale} ${nextP.y * scale}`; }
                                                  const roadNames = inputs.roads.filter(r => (r.edgeIndices || []).includes(i) || r.edgeIndex === i).map(r => r.name).join(', ');
                                                  // Task 5: Edge Index Label
                                                  const midX = curve ? (0.25*p.x + 0.5*curve.x + 0.25*nextP.x) : (p.x + nextP.x)/2;
                                                  const midY = curve ? (0.25*p.y + 0.5*curve.y + 0.25*nextP.y) : (p.y + nextP.y)/2;
                                                  return ( <g key={`line-group-${i}`}> {(isFrontage || isBack || isSide) && ( <path d={edgeD} stroke={isFrontage ? "#fee2e2" : (isBack ? "#d1fae5" : "#dbeafe")} strokeWidth="10" fill="none" strokeLinecap="round" /> )} <path key={`line-${i}`} d={edgeD} data-type="edge-line" stroke={strokeColor} strokeWidth={strokeWidth} fill="none" strokeLinecap="round" strokeOpacity={opacity} className={`${(isLocked || isFrontage || isBack || isSide) ? 'cursor-default' : (isRoadSelectMode || interactionMode !== 'none' ? 'cursor-pointer hover:stroke-indigo-400/50' : 'cursor-crosshair hover:stroke-black/10')}`} onContextMenu={(e) => handleEdgeContextMenu(e, i)} onPointerDown={(e) => isLocked ? handleEdgePointerDown(e, i) : handleEdgePointerDown(e, i)} onPointerUp={handleEdgePointerUp} onPointerMove={handlePointPointerMove} onClick={(e) => (!isLocked || isRoadSelectMode || interactionMode !== 'none') && handleLineClick(e, i, nextI)} /> {isFrontage && !baseCurves?.[i] && ( <text x={(p.x + nextP.x)/2 * scale} y={(p.y + nextP.y)/2 * scale} textAnchor="middle" dominantBaseline="middle" fontSize="8" fontWeight="bold" fill="#b91c1c" pointerEvents="none" className="select-none"> {`${roadNames || "道路"} (${i})`} </text> )} 
                                                  {!isFrontage && <text x={midX * scale} y={midY * scale} textAnchor="middle" dominantBaseline="middle" fontSize="8" fill={isDarkMode ? "#94a3b8" : "#64748b"} className="select-none pointer-events-none font-mono bg-white/50">{i}</text>}
                                                  </g> );
                                              })}
                                              {renderCurveHandles()} {displayLayer.points.map((p, i) => ( <g key={`pt-${i}`} transform={`translate(${p.x * scale}, ${p.y * scale})`}> <circle data-type="control-point" r="6" fill="white" stroke={selectedIndices.has(i) ? "#6366f1" : (selectedFloorId === 'excavation' ? "#f59e0b" : "#0284c7")} strokeWidth={selectedIndices.has(i) ? "3" : "2"} className={`cursor-grab relative ${selectedIndices.has(i) ? 'animate-pulse-ring' : ''}`} onPointerDown={(e) => handlePointPointerDown(e, i)} onPointerMove={handlePointPointerMove} onPointerUp={handlePointPointerUp} onContextMenu={(e) => handleDeletePoint(e, i)} /> </g> ))}
                                          </>
                                      ) : ( <rect x={-(displayLayer.realWidth * scale)/2} y={-(displayLayer.realDepth * scale)/2} width={displayLayer.realWidth * scale} height={displayLayer.realDepth * scale} fill={displayLayer.isViolation ? "rgba(239, 68, 68, 0.5)" : (isDarkMode ? "#38bdf8" : "#0ea5e9")} stroke={displayLayer.isViolation ? "#ef4444" : "#0284c7"} strokeWidth="2" opacity="0.9" /> )}
                                      {selectedFloorId !== 'base' && <circle cx={(displayLayer.pivot?.x || 0) * scale} cy={(displayLayer.pivot?.y || 0) * scale} r="4" fill="#ef4444" stroke="white" strokeWidth="1" />}
                                  </g>
                              </svg>
                          </div>
                      </div>
                      </>
                  ) : (
                    <div className="w-full h-full overflow-y-auto p-4 pt-16 overscroll-contain" style={{ overscrollBehaviorX: 'contain' }}>
                      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 pb-20">
                          <div onClick={() => onSelectFloor('base')} className={`aspect-square rounded-xl border-2 transition-all cursor-pointer flex flex-col items-center justify-center relative bg-stone-50 hover:bg-white hover:shadow hover:border-indigo-400 ${isDarkMode ? 'bg-slate-800/50 border-slate-700 hover:bg-slate-700' : 'border-stone-200'}`}>
                              <span className="absolute top-2 left-2 text-xs font-bold text-stone-500 bg-stone-100 px-1.5 rounded">基地</span>
                              <svg width={100} height={100} viewBox={`-${baseWidthM*baseItemScale/2+20} -${baseDepthM*baseItemScale/2+20} ${baseWidthM*baseItemScale+40} ${baseDepthM*baseItemScale+40}`} className="overflow-visible"> {currentBasePoints ? ( <> <path d={generateSvgPath(currentBasePoints, baseCurves, baseItemScale)} fill="none" stroke={isDarkMode ? "#cbd5e1" : "#475569"} strokeWidth="2" /> </> ) : ( <> <rect x={-baseWidthM*baseItemScale/2} y={-baseDepthM*baseItemScale/2} width={baseWidthM*baseItemScale} height={baseDepthM*baseItemScale} fill="none" stroke={isDarkMode ? "#cbd5e1" : "#475569"} strokeWidth="2" /> </> )} </svg>
                              <div className="absolute bottom-2 text-[10px] text-stone-400 font-mono">{formatNum(inputs.baseArea)}m²</div>
                          </div>
                          <div onClick={() => onSelectFloor('excavation')} className={`aspect-square rounded-xl border-2 border-dashed transition-all cursor-pointer flex flex-col items-center justify-center relative bg-amber-50/50 hover:bg-white hover:shadow hover:border-amber-400 ${isDarkMode ? 'bg-slate-800/50 border-slate-700 hover:bg-slate-700' : 'border-amber-200'}`}>
                              <span className="absolute top-2 left-2 text-xs font-bold text-amber-600 bg-amber-100 px-1.5 rounded">開挖範圍</span> <div className="text-amber-300 mb-2"><Shovel size={24}/></div> <div className="text-xs text-stone-500 font-bold">設定開挖邊界</div> {excavationPoints && <div className="text-[10px] text-stone-400 mt-1">自訂形狀已啟用</div>}
                          </div>
                          {basements.map((b, i) => { if (!b.active) return null; const baseDim = 100; const scale = baseDim / Math.max(baseWidthM, baseDepthM); const baseW = baseWidthM * scale; const baseH = baseDepthM * scale; let pts = excavationPoints; if (!pts && basePoints) { const scaleRate = Math.sqrt(inputs.excavationRatio / 100); const { points: newPts } = scalePolygon(basePoints, baseCurves, scaleRate); pts = newPts; } return ( <div key={b.id} onClick={() => onSelectFloor(b.id)} className={`aspect-square rounded-xl border-2 transition-all cursor-pointer flex flex-col items-center justify-center relative bg-white/50 hover:bg-white hover:shadow-lg hover:border-indigo-400 ${isDarkMode ? 'bg-slate-800/50 border-slate-700 hover:bg-slate-700' : 'border-stone-200'}`}> <span className="absolute top-2 left-2 text-xs font-bold text-stone-500 bg-stone-100 px-1.5 rounded">{b.id}</span> <svg width={baseDim} height={baseDim} viewBox={`-${baseW/2+10} -${baseH/2+10} ${baseW+20} ${baseH+20}`} className="overflow-visible"> {currentBasePoints ? ( <path d={generateSvgPath(currentBasePoints, baseCurves, scale)} fill="none" stroke={isDarkMode ? "#475569" : "#cbd5e1"} strokeWidth="1" /> ) : ( <rect x={-baseW/2} y={-baseH/2} width={baseW} height={baseH} fill="none" stroke={isDarkMode ? "#475569" : "#cbd5e1"} strokeWidth="1" /> )} <g> {pts ? ( <path d={generateSvgPath(pts, null, scale)} fill={isDarkMode ? "#334155" : "#cbd5e1"} opacity="0.8" /> ) : ( <rect x={-(baseW * Math.sqrt(inputs.excavationRatio/100))/2} y={-(baseH * Math.sqrt(inputs.excavationRatio/100))/2} width={baseW * Math.sqrt(inputs.excavationRatio/100)} height={baseH * Math.sqrt(inputs.excavationRatio/100)} fill={isDarkMode ? "#334155" : "#cbd5e1"} opacity="0.8"/> )} </g> </svg> <div className="absolute bottom-2 text-[10px] text-stone-400 font-mono">{formatNum(toPing(b.area))}坪</div> </div> ); })}
                          {layers.map((layer, idx) => { const baseDim = 100; const scale = baseDim / Math.max(baseWidthM, baseDepthM); const baseW = baseWidthM * scale; const baseH = baseDepthM * scale; const shiftX_M = layer.shiftX / scale3d; const shiftY_M = layer.shiftYPx / scale3d; const xPos = shiftX_M * scale; const yPos = shiftY_M * scale; return ( <div key={layer.id} onClick={() => onSelectFloor(layer.id)} className={`aspect-square rounded-xl border-2 transition-all cursor-pointer flex flex-col items-center justify-center relative bg-white/50 hover:bg-white hover:shadow-lg hover:border-indigo-400 ${isDarkMode ? 'bg-slate-800/50 border-slate-700 hover:bg-slate-700' : 'border-stone-200'}`}> <span className="absolute top-2 left-2 text-xs font-bold text-stone-500 bg-stone-100 px-1.5 rounded">{layer.id}</span> {layer.isViolation && <AlertTriangle size={14} className="absolute top-2 right-2 text-red-500" />} <svg width={baseDim} height={baseDim} viewBox={`-${baseW/2+10} -${baseH/2+10} ${baseW+20} ${baseH+20}`} className="overflow-visible"> {currentBasePoints ? ( <path d={generateSvgPath(currentBasePoints, baseCurves, scale)} fill="none" stroke={isDarkMode ? "#475569" : "#cbd5e1"} strokeWidth="1" /> ) : ( <rect x={-baseW/2} y={-baseH/2} width={baseW} height={baseH} fill="none" stroke={isDarkMode ? "#475569" : "#cbd5e1"} strokeWidth="1" /> )} <g transform={`translate(${xPos}, ${yPos}) rotate(${layer.rotation || 0})`}> {layer.points ? ( <path d={generateSvgPath(layer.points, layer.curves, scale)} fill={layer.isViolation ? "#fca5a5" : "#bae6fd"} opacity="0.8" /> ) : ( <rect x={-(layer.realWidth * scale)/2} y={-(layer.realDepth * scale)/2} width={layer.realWidth * scale} height={layer.realDepth * scale} fill={layer.isViolation ? "#fca5a5" : "#bae6fd"} opacity="0.8"/> )} </g> </svg> <div className="absolute bottom-2 text-[10px] text-stone-400 font-mono">{formatNum(toPing(layer.realArea))}坪</div> </div> ); })}
                      </div>
                    </div>
                  )}
                  {displayLayer && ( <EditMenu2D data={displayLayer} isDarkMode={isDarkMode} onUpdateSetting={updateSetting} onReset={(id) => updateSetting(id, 'reset')} isOpen={true} onClose={onClose} scale3d={scale3d} inputs={inputs} basePoints={basePoints} isRoadSelectMode={isRoadSelectMode} onToggleRoadSelectMode={() => setIsRoadSelectMode(!isRoadSelectMode)} interactionMode={interactionMode} setInteractionMode={setInteractionMode} selectedCurveIdx={selectedCurveForEdit} onUpdateRoads={onUpdateRoads} onUpdateInputs={onUpdateInputs} isAreaLocked={isAreaLocked} setIsAreaLocked={setIsAreaLocked} unitSettings={unitSettings} onUpdateUnitSettings={onUpdateUnitSettings} /> )}
              </div>
          );
      };

      const InfoItem = ({ label, value, unit, isDarkMode }) => (
          <div className="flex flex-col">
              <span className={`${isDarkMode ? 'text-slate-400' : 'text-stone-400'} text-[10px]`}>{label}</span>
              <span className={`${isDarkMode ? 'text-slate-200' : 'text-stone-700'} font-bold text-sm whitespace-nowrap`}>{value} <span className="text-[10px] font-normal opacity-70">{unit}</span></span>
          </div>
      );

      const LegendItem = ({ color, label, value, textColor, valueColor, type = 'box' }) => (
          <div className="flex items-center gap-2">
              {type === 'line' ? (
                   <div className={`w-4 h-0.5 ${color.replace('bg-', 'bg-')}`}></div>
              ) : (
                   <div className={`w-3 h-3 rounded-sm border ${color}`}></div>
              )}
              <div className="flex flex-col leading-none">
                  <span className={`text-[10px] font-bold ${textColor}`}>{label}</span>
                  {value && <span className={`text-[10px] ${valueColor}`}>{value}</span>}
              </div>
          </div>
      );

      const normalizeWithCurves = (points, curves) => {
          if (!points) return { points: null, curves: null, centroid: {x:0, y:0} };
          const centroid = getPolygonCentroid(points);
          const newPoints = points.map(p => ({ x: p.x - centroid.x, y: p.y - centroid.y }));
          let newCurves = null;
          if (curves) {
              newCurves = {};
              Object.keys(curves).forEach(k => {
                   const cp = curves[k];
                   newCurves[k] = { x: cp.x - centroid.x, y: cp.y - centroid.y };
              });
          }
          return { points: newPoints, curves: newCurves, centroid };
      };

        const splitPolygon = (points, axis, ratio, gap) => {
            if (!points || points.length < 3) return [points];
            const xs = points.map(p => p.x); const ys = points.map(p => p.y);
            const minX = Math.min(...xs); const maxX = Math.max(...xs);
            const minY = Math.min(...ys); const maxY = Math.max(...ys);
            const w = maxX - minX; const h = maxY - minY;
            const cutVal = axis === 'x' ? (minX + w * ratio) : (minY + h * ratio);
            const limit1 = cutVal - gap/2;
            const limit2 = cutVal + gap/2;
            
            const clip = (pts, isKeep, limit) => {
                const newPts = [];
                for (let i = 0; i < pts.length; i++) {
                    const p1 = pts[i]; const p2 = pts[(i + 1) % pts.length];
                    const v1 = axis === 'x' ? p1.x : p1.y; const v2 = axis === 'x' ? p2.x : p2.y;
                    const in1 = isKeep(v1); const in2 = isKeep(v2);
                    if (in1) {
                        newPts.push(p1);
                        if (!in2 && v2 !== v1) {
                            const alpha = (limit - v1) / (v2 - v1);
                            newPts.push({ x: p1.x + (p2.x - p1.x) * alpha, y: p1.y + (p2.y - p1.y) * alpha });
                        }
                    } else if (in2 && v2 !== v1) {
                        const alpha = (limit - v1) / (v2 - v1);
                        newPts.push({ x: p1.x + (p2.x - p1.x) * alpha, y: p1.y + (p2.y - p1.y) * alpha });
                    }
                }
                return newPts.length >= 3 ? newPts : null;
            };
            const p1 = clip(points, (v) => v <= limit1, limit1);
            const p2 = clip(points, (v) => v >= limit2, limit2);
            return [p1, p2].filter(p => p !== null);
        };

        const splitPolygonByCount = (points, axis, count, gap) => {
            if (!points || points.length < 3) return [points];
            const safeCount = Math.max(1, Math.round(count || 1));
            if (safeCount === 1) return [points];
            const xs = points.map(p => p.x); const ys = points.map(p => p.y);
            const minX = Math.min(...xs); const maxX = Math.max(...xs);
            const minY = Math.min(...ys); const maxY = Math.max(...ys);
            const len = axis === 'x' ? (maxX - minX) : (maxY - minY);
            const totalGap = Math.max(0, gap) * (safeCount - 1);
            const usable = len - totalGap;
            if (usable <= 0) return [points];
            const segLen = usable / safeCount;
            
            const clip = (pts, isKeep, limit) => {
                const newPts = [];
                for (let i = 0; i < pts.length; i++) {
                    const p1 = pts[i]; const p2 = pts[(i + 1) % pts.length];
                    const v1 = axis === 'x' ? p1.x : p1.y; const v2 = axis === 'x' ? p2.x : p2.y;
                    const in1 = isKeep(v1); const in2 = isKeep(v2);
                    if (in1) {
                        newPts.push(p1);
                        if (!in2 && v2 !== v1) {
                            const alpha = (limit - v1) / (v2 - v1);
                            newPts.push({ x: p1.x + (p2.x - p1.x) * alpha, y: p1.y + (p2.y - p1.y) * alpha });
                        }
                    } else if (in2 && v2 !== v1) {
                        const alpha = (limit - v1) / (v2 - v1);
                        newPts.push({ x: p1.x + (p2.x - p1.x) * alpha, y: p1.y + (p2.y - p1.y) * alpha });
                    }
                }
                return newPts.length >= 3 ? newPts : null;
            };
            
            const results = [];
            for (let i = 0; i < safeCount; i++) {
                const segStart = (axis === 'x' ? minX : minY) + i * (segLen + gap);
                const segEnd = segStart + segLen;
                let seg = clip(points, (v) => v >= segStart, segStart);
                if (seg) seg = clip(seg, (v) => v <= segEnd, segEnd);
                if (seg) results.push(seg);
            }
            return results.length > 0 ? results : [points];
        };

        const getSplitUnits = (points, settings) => {
            if (!points || !settings) return null;
            const mode = settings.mode || 'ratio';
            const axis = settings.axis || 'x';
            const gap = settings.gap || 0;
            if (mode === 'ratio') {
                return splitPolygon(points, axis, settings.ratio || 0.5, gap);
            }
            let count = settings.count || 1;
            if (mode === 'area') {
                const perUnit = parseFloat(settings.areaPerUnit || 0);
                if (perUnit > 0) {
                    const totalPing = toPing(calculatePolygonArea(points));
                    count = Math.max(1, Math.round(totalPing / perUnit));
                } else {
                    count = 1;
                }
            }
            return splitPolygonByCount(points, axis, count, gap);
        };

      const Visualizer3D = ({ inputs, res, onUpdateBaseDim, onResetAll, onUpdateRoads, onUpdateInputs, showCheckLines, setShowCheckLines, showHeightRatio, setShowHeightRatio, showWeiLao, setShowWeiLao, showBackyard, setShowBackyard, isConstraintMode, setIsConstraintMode, onUnusedAreaChange }) => {
  const [animate, setAnimate] = useState(false);
  const [isDarkMode, setIsDarkMode] = useState(false);
  // Internal constraint mode state removed (lifted to parent) 
        const [viewMode, setViewMode] = useState('3d');
        const [selectedFloor, setSelectedFloor] = useState(null);
        const [focusOffset, setFocusOffset] = useState({ x: 0, y: 0, z: 0 });
        const [floorSettings, setFloorSettings] = useState({});
        // Task: Unit Settings State
        const [unitSettings, setUnitSettings] = useState({ enabled: false, axis: 'x', ratio: 0.5, gap: 0, mode: 'ratio', count: 2, areaPerUnit: 20 });

        const floorsBelow = Math.max(0, parseInt(inputs.floorsBelow) || 0);
        const [basementState, setBasementState] = useState({}); 
        const [parkingOn1F, setParkingOn1F] = useState(true);
        const volumeLimit = res.totalCFA;
        const carsPerBasement = (res.basementAreaPerFloor || 0) / (inputs.avgCarArea || 35);
        const recommendedBasementCount = carsPerBasement > 0 ? Math.ceil(res.statutoryParking / carsPerBasement) : 0;
        
        const [basePoints, setBasePoints] = useState(null);
        const [baseCurves, setBaseCurves] = useState(null); 
        const [excavationPoints, setExcavationPoints] = useState(null);
        const [excavationCurves, setExcavationCurves] = useState(null);
        const [manualFloorsOverride, setManualFloorsOverride] = useState(null);
        
        const [frontageIndices, setFrontageIndices] = useState(new Set());
        const [edgeTypes, setEdgeTypes] = useState({}); 

        const [view2D, setView2D] = useState({ x: 0, y: 0, k: 1 });

        const basements = useMemo(() => Array.from({length: floorsBelow}).map((_, i) => ({ id: `B${i+1}`, area: res.basementAreaPerFloor, active: true, recommended: (i + 1) <= recommendedBasementCount })), [floorsBelow, res.basementAreaPerFloor, recommendedBasementCount]);
        const activeBasementArea = basements.filter(b => b.active).reduce((acc, b) => acc + b.area, 0);
        const toggleBasement = (id) => {}; // Removed toggle
        const toggleParkingLocation = () => setParkingOn1F(prev => !prev);
        
        useEffect(() => {
             if (selectedFloor && selectedFloor.id.startsWith('B')) {
                 const bNum = parseInt(selectedFloor.id.substring(1));
                 if (bNum > floorsBelow) setSelectedFloor(null);
             }
        }, [floorsBelow]);
        
        useEffect(() => {
            if (basePoints) {
                const scaleRate = Math.sqrt(inputs.excavationRatio / 100);
                const { points: newPts, curves: newCurves } = scalePolygon(basePoints, baseCurves, scaleRate);
                setExcavationPoints(newPts);
                setExcavationCurves(newCurves); 
            }
        }, [basePoints, baseCurves, inputs.excavationRatio]);

        useEffect(() => {
            const bw = parseFloat(inputs.baseWidthM);
            const bd = parseFloat(inputs.baseDepthM);
            if (bw > 0 && bd > 0) {
                const newScale3d = Math.min(600 / bw, 600 / bd);
                const currentScale3d = parseFloat(inputs.scale3d);
                if (isNaN(currentScale3d) || Math.abs(currentScale3d - newScale3d) > 0.001) {
                    onUpdateInputs('scale3d', parseFloat(newScale3d.toFixed(4)));
                }
            }
        }, [inputs.baseWidthM, inputs.baseDepthM]);

        const toggleConstraints = () => { setIsConstraintMode(!isConstraintMode); if (!isConstraintMode) setShowCheckLines(true); };
        const [rotationZ, setRotationZ] = useState(-45);
        const [viewAngleX, setViewAngleX] = useState(58);
        const [isSettingNorth, setIsSettingNorth] = useState(false);
        const compassRef = useRef(null);
        const [zoom, setZoom] = useState(1);
        const [isDragging, setIsDragging] = useState(false);
        const lastMousePos = useRef({ x: 0, y: 0 });
        const lastPinchDist = useRef(null); 
        const viewportRef = useRef(null);
        const [isMobile, setIsMobile] = useState(false);
        const [isSummaryOpen, setIsSummaryOpen] = useState(true);
        const isLandscapeMode = isMobile && !isSummaryOpen;
        const rafRef = useRef(null);

        useEffect(() => { const checkMobile = () => setIsMobile(window.innerWidth < 768); checkMobile(); window.addEventListener('resize', checkMobile); return () => window.removeEventListener('resize', checkMobile); }, []);
        useEffect(() => { setAnimate(true); const timer = setTimeout(() => setAnimate(false), 1000); return () => clearTimeout(timer); }, [res.floorsAbove]);

        useEffect(() => {
          const element = viewportRef.current;
          if (!element) return;
          const handleNativeWheel = (e) => { 
              if(e.cancelable) e.preventDefault(); 
              e.stopPropagation(); 
              const sensitivity = 0.002; 
              const delta = -e.deltaY * sensitivity; 
              
              if (viewMode === '2d') {
                  setView2D(v => {
                      const newK = Math.min(5, Math.max(0.5, v.k + delta * 200)); // Adjusted sensitivity for 2D
                      return { ...v, k: newK };
                  });
              } else {
                  setZoom(prev => Math.min(3, Math.max(0.2, prev + delta))); 
              }
          };
          element.addEventListener('wheel', handleNativeWheel, { passive: false });
          return () => element.removeEventListener('wheel', handleNativeWheel);
        }, [viewMode]); 
        
        const getTouchDistance = (touches) => Math.hypot(touches[0].pageX - touches[1].pageX, touches[0].pageY - touches[1].pageY);
        const handleMouseDown = (e) => { if (viewMode === '2d') return; setIsDragging(true); lastMousePos.current = { x: e.clientX, y: e.clientY }; };
        const updateNorthFromEvent = (e) => {
            if (!compassRef.current) return;
            const rect = compassRef.current.getBoundingClientRect();
            const cx = rect.left + rect.width / 2;
            const cy = rect.top + rect.height / 2;
            const dx = e.clientX - cx;
            const dy = e.clientY - cy;
            let angle = (Math.atan2(dy, dx) * 180) / Math.PI + 90;
            if (angle < 0) angle += 360;
            onUpdateInputs('northAngle', parseFloat(angle.toFixed(1)));
        };
        const handleCompassPointerDown = (e) => {
            e.stopPropagation();
            if (e.currentTarget?.setPointerCapture) e.currentTarget.setPointerCapture(e.pointerId);
            setViewAngleX(90);
            setIsSettingNorth(true);
            updateNorthFromEvent(e);
        };
        const handleCompassPointerMove = (e) => {
            if (!isSettingNorth) return;
            e.stopPropagation();
            updateNorthFromEvent(e);
        };
        const handleCompassPointerUp = (e) => {
            if (e.currentTarget?.releasePointerCapture) e.currentTarget.releasePointerCapture(e.pointerId);
            setIsSettingNorth(false);
        };
        const handleTouchStart = (e) => {
          if (viewMode === '2d') {
              if (e.touches.length === 2) { lastPinchDist.current = getTouchDistance(e.touches); }
              return;
          }
          if (e.touches.length === 2) { lastPinchDist.current = getTouchDistance(e.touches); setIsDragging(false); } 
          else if(e.touches.length === 1) { setIsDragging(true); lastMousePos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY }; }
        };
        const handleMouseMove = (e) => {
          if (!isDragging) return;
          const deltaX = e.clientX - lastMousePos.current.x;
          const deltaY = e.clientY - lastMousePos.current.y;
          let effectiveDeltaX = isLandscapeMode ? deltaY : deltaX;
          let effectiveDeltaY = isLandscapeMode ? -deltaX : deltaY;
          setRotationZ(prev => prev + effectiveDeltaX * 0.5);
          setViewAngleX(prev => Math.min(85, Math.max(10, prev - effectiveDeltaY * 0.5)));
          lastMousePos.current = { x: e.clientX, y: e.clientY };
        };
        const handleTouchMove = (e) => {
          if (e.touches.length === 2 && lastPinchDist.current !== null) { 
              const currentDist = getTouchDistance(e.touches); 
              const delta = currentDist - lastPinchDist.current; 
              if (viewMode === '2d') {
                  setView2D(v => ({ ...v, k: Math.min(5, Math.max(0.5, v.k + delta * 0.005)) }));
              } else {
                  setZoom(prev => Math.min(3, Math.max(0.2, prev + delta * 0.005))); 
              }
              lastPinchDist.current = currentDist; 
              return; 
          }
          if (!isDragging || e.touches.length !== 1) return;
          if (rafRef.current) return;
          const clientX = e.touches[0].clientX; const clientY = e.touches[0].clientY;
          rafRef.current = requestAnimationFrame(() => {
              const deltaX = clientX - lastMousePos.current.x; const deltaY = clientY - lastMousePos.current.y; let effectiveDeltaX = isLandscapeMode ? deltaY : deltaX; let effectiveDeltaY = isLandscapeMode ? -deltaX : deltaY; setRotationZ(prev => prev + effectiveDeltaX * 0.5); setViewAngleX(prev => Math.min(85, Math.max(10, prev - effectiveDeltaY * 0.5))); lastMousePos.current = { x: clientX, y: clientY }; rafRef.current = null;
          });
        };
        const handleMouseUp = () => { setIsDragging(false); lastPinchDist.current = null; };
        const handleZoomIn = () => { if (viewMode === '2d') { setView2D(v => ({ ...v, k: Math.min(5, v.k * 1.2) })); } else { setZoom(prev => Math.min(3, prev + 0.2)); } };
        const handleZoomOut = () => { if (viewMode === '2d') { setView2D(v => ({ ...v, k: Math.max(0.5, v.k / 1.2) })); } else { setZoom(prev => Math.max(0.2, prev - 0.2)); } };
        const handleLayerClick = (e, layer) => { e.stopPropagation(); if (selectedFloor && selectedFloor.id === layer.id) return; const settings = floorSettings[layer.id] || {}; setSelectedFloor({ ...layer, rotation: layer.rotation || 0, pivot: settings.pivot || { x: 0, y: 0 }, alignment: settings.alignment || { x: 'left', y: 'back' }, violations: layer.violations || [], points: settings.points || null, curves: settings.curves || null }); const targetZ = layer.z + layer.height * 0.5; setFocusOffset({ x: -layer.shiftX, y: -layer.shiftYPx, z: -targetZ }); setZoom(2.5); };
        const handleBgClick = () => { if (selectedFloor) { setSelectedFloor(null); } }; 
        const toggleFullscreen = () => { if (isSummaryOpen) { setIsSummaryOpen(false); } else { setIsSummaryOpen(true); } };

        // 更新樓層設定 (Update floor settings)
        // 處理來自平面分析區的數據更新 (Handle data updates from 2D analysis)
        const updateFloorSetting = (floorId, field, value) => {
           if (isConstraintMode && !(floorId && floorId.startsWith('B'))) return; 
           if (floorId === 'base') {
                if (field === 'points') {
                    // 更新基地點座標 (Update base points)
                    setBasePoints(value);
                    if (value) {
                         // 重置其他樓層設定，因為基地形狀改變可能導致幾何失效
                         // (Reset other floor settings as base shape change invalidates geometry)
                         setFloorSettings(prev => { const next = { ...prev }; Object.keys(next).forEach(k => { if (k !== 'base') { delete next[k].points; delete next[k].curves; delete next[k].manualArea; delete next[k].manualDim; delete next[k].width; delete next[k].depth; delete next[k].offset; delete next[k].rotation; delete next[k].pivot; delete next[k].alignment; } }); return next; });
                         setExcavationPoints(null); setExcavationCurves(null);
                    }
                } else if (field === 'curves') { setBaseCurves(value); } else if (field === 'reset') { setBasePoints(null); setBaseCurves(null); setFrontageIndices(new Set()); setEdgeTypes({}); }
                return;
           }
           if (floorId === 'excavation') { if (field === 'points') setExcavationPoints(value); if (field === 'reset') { setExcavationPoints(null); setExcavationCurves(null); } return; }
           if (field === 'reset') { setFloorSettings(prev => { const copy = {...prev}; delete copy[floorId]; return copy; }); return; }
           setFloorSettings(prev => { const current = prev[floorId] || {}; let newData = { ...current }; if (field.startsWith('align_')) { const axis = field.split('_')[1]; const alignment = { ...(current.alignment || { x: 'left', y: 'back' }), [axis]: value }; newData.alignment = alignment; } else if (field.startsWith('pivot')) { const axis = field === 'pivotX' ? 'x' : 'y'; const pivot = { ...(current.pivot || { x: 0, y: 0 }), [axis]: value }; newData.pivot = pivot; } else if (field === 'area') { newData.area = value; newData.manualArea = true; } else if (field === 'points') { if (value && value.length >= 3) { let area = calculatePolygonArea(value); newData.area = area; newData.manualArea = true; } newData.points = value; } else if (field === 'curves') { newData.curves = value; } else if (field === 'units') { newData.units = value; newData.manualArea = true; } else if (field === 'offset_delta') { const currentOff = current.offset || { x: 0, y: 0 }; newData.offset = { x: currentOff.x + value.x, y: currentOff.y + value.y }; } else { newData[field] = value; if (field === 'width' || field === 'depth') newData.manualDim = true; } return { ...prev, [floorId]: newData }; });
        };
        
        const handleBaseEditEnd = (floorId, points) => {
             if (floorId === 'base' && points) {
                 const normalized = normalizeWithCurves(points, baseCurves);
                 if (normalized.points) {
                     setBasePoints(normalized.points);
                     setBaseCurves(normalized.curves);
                 }
                const shift = normalized.centroid || { x: 0, y: 0 };
                if (Math.abs(shift.x) > 0.0001 || Math.abs(shift.y) > 0.0001) {
                    setFloorSettings(prev => {
                        const next = { ...prev };
                        let changed = false;
                        Object.keys(next).forEach(k => {
                            if (k === 'base') return;
                            const cur = next[k];
                            if (!cur) return;
                            let updated = null;
                            if (cur.points && cur.points.length > 0) {
                                const shiftedPoints = cur.points.map(p => ({ x: p.x - shift.x, y: p.y - shift.y }));
                                updated = { ...(updated || cur), points: shiftedPoints };
                            }
                            if (cur.curves) {
                                const shiftedCurves = {};
                                Object.keys(cur.curves).forEach(idx => {
                                    const cp = cur.curves[idx];
                                    shiftedCurves[idx] = { x: cp.x - shift.x, y: cp.y - shift.y };
                                });
                                updated = { ...(updated || cur), curves: shiftedCurves };
                            }
                            if (updated) {
                                next[k] = updated;
                                changed = true;
                            }
                        });
                        return changed ? next : prev;
                    });
                    setExcavationPoints(prev => {
                        if (!prev || prev.length === 0) return prev;
                        return prev.map(p => ({ x: p.x - shift.x, y: p.y - shift.y }));
                    });
                    setExcavationCurves(prev => {
                        if (!prev) return prev;
                        const next = {};
                        Object.keys(prev).forEach(k => {
                            const cp = prev[k];
                            next[k] = { x: cp.x - shift.x, y: cp.y - shift.y };
                        });
                        return next;
                    });
                }
                 const area = calculatePolygonArea(points);
                 const currentArea = parseFloat(inputs.baseArea || 0);
                 if (Math.abs(area - currentArea) > 0.01) {
                     onUpdateBaseDim('baseArea', parseFloat(area.toFixed(2)));
                 }
                 const xs = points.map(p => p.x); const w = Math.max(...xs) - Math.min(...xs); 
                 const currentW = parseFloat(inputs.baseWidth || 0);
                 if (Math.abs(w - currentW) > 0.01) {
                     onUpdateInputs('baseWidth', parseFloat(w.toFixed(2)));
                 }
                const bounds = getPolygonBounds(points);
                if (bounds) {
                    const baseWidthM = bounds.maxX - bounds.minX;
                    const baseDepthM = bounds.maxY - bounds.minY;
                    onUpdateInputs('baseWidthM', parseFloat(baseWidthM.toFixed(2)));
                    onUpdateInputs('baseDepthM', parseFloat(baseDepthM.toFixed(2)));
                }
             }
        };

        const resetFloor = (floorId) => { setFloorSettings(prev => { const copy = { ...prev }; delete copy[floorId]; return copy; }); };

        const updateEdgeTypes = (index, type) => { setEdgeTypes(prev => { if (index === null && typeof type === 'object') { return type; } const next = { ...prev }; if (next[index] === type) { delete next[index]; } else { next[index] = type; } return next; }); };

        const canvasSize = isMobile ? (isLandscapeMode ? 320 : 200) : 280; 
        const inputBaseWidthM = parseFloat(inputs.baseWidthM || inputs.baseWidth);
        const baseWidthM = inputBaseWidthM > 0 ? inputBaseWidthM : Math.sqrt(inputs.baseArea || 100);
        let baseDepthM = parseFloat(inputs.baseDepthM);
        if (!(baseDepthM > 0)) baseDepthM = (inputs.baseArea || 100) / baseWidthM;
        if (basePoints && basePoints.length > 0) { const ys = basePoints.map(p => p.y); const bboxH = Math.max(...ys) - Math.min(...ys); if (bboxH > baseDepthM) baseDepthM = bboxH; }
        
        const scale = (parseFloat(inputs.scale3d) > 0 ? parseFloat(inputs.scale3d) : (canvasSize / Math.max(baseWidthM, baseDepthM)));
        const w = baseWidthM * scale;
        const d = baseDepthM * scale;
        const frontM = parseFloat(inputs.frontYardDepth) || 0;
        const backM = parseFloat(inputs.backYardDepth) || 0;
        const sideM = parseFloat(inputs.sideYardDepth) || 0;
        const sideDir = inputs.sideYardDirection || 'right';
        const roadW_M = parseFloat(inputs.roads.find(r => r.type === 'primary')?.width || inputs.roads[0]?.width || 6);
        const byRatio = parseFloat(inputs.minBackyardDepthRatio) || 0;
        const arcadeM = (inputs.frontYardDepth == 0 && inputs.arcadeDepth) ? parseFloat(inputs.arcadeDepth) : 0; 
        const frontPx = frontM * scale; const backPx = backM * scale; const sidePx = sideM * scale; const roadW_Px = roadW_M * scale; const shiftX = sideDir === 'left' ? (sidePx / 2) : (-sidePx / 2);

        useEffect(() => {
            const roadList = inputs.roads || [];
            const primaryIndices = new Set();
            const secondaryIndices = new Set();
            
            roadList.forEach(r => {
                const indices = new Set();
                if (r.edgeIndices) r.edgeIndices.forEach(i => indices.add(i));
                if (r.edgeIndex !== undefined && r.edgeIndex !== "") indices.add(parseInt(r.edgeIndex));
                
                if (r.type === 'primary') {
                    indices.forEach(i => primaryIndices.add(i));
                } else {
                    indices.forEach(i => secondaryIndices.add(i));
                }
            });
            
            const workingPoints = (basePoints && basePoints.length > 2) ? basePoints : [{x: -baseWidthM/2, y: -baseDepthM/2}, {x: baseWidthM/2, y: -baseDepthM/2}, {x: baseWidthM/2, y: baseDepthM/2}, {x: -baseWidthM/2, y: baseDepthM/2}];
            const workingCurves = (basePoints && basePoints.length > 2) ? baseCurves : null;
            const edgeCount = workingPoints.length;
            
            const nextFront = new Set();
            if (primaryIndices.size > 0) {
                primaryIndices.forEach(i => nextFront.add(i));
            } else if (secondaryIndices.size > 0) {
                secondaryIndices.forEach(i => nextFront.add(i));
            } else if (frontageIndices && frontageIndices.size > 0) {
                frontageIndices.forEach(i => nextFront.add(i));
            }
            
            const filteredFront = new Set();
            nextFront.forEach(i => {
                if (Number.isInteger(i) && i >= 0 && i < edgeCount) filteredFront.add(i);
            });
            
            const nextEdgeTypes = {};
            Object.keys(edgeTypes || {}).forEach(k => {
                const idx = parseInt(k);
                if (!Number.isNaN(idx) && idx >= 0 && idx < edgeCount && !filteredFront.has(idx)) {
                    nextEdgeTypes[idx] = edgeTypes[k];
                }
            });
            
            secondaryIndices.forEach(idx => {
                if (idx >= 0 && idx < edgeCount && !filteredFront.has(idx) && !nextEdgeTypes[idx]) {
                    nextEdgeTypes[idx] = 'side';
                }
            });
            
            const hasBack = Object.values(nextEdgeTypes).includes('back');
            if (!hasBack && filteredFront.size > 0) {
                const normalized = normalizeWithCurves(workingPoints, workingCurves);
                if (normalized.points && normalized.points.length > 2) {
                    const discretized = discretizePolygon(normalized.points, normalized.curves, 20);
                    const pts = discretized.points;
                    const edgeMap = discretized.edgeMap;
                    const centroid = getPolygonCentroid(pts);
                    let frontNormal = { x: 0, y: 0 };
                    let count = 0;
                    
                    pts.forEach((p, i) => {
                        const orig = edgeMap[i];
                        if (filteredFront.has(orig)) {
                            const p2 = pts[(i + 1) % pts.length];
                            const n = getSegmentNormal(p, p2, centroid);
                            frontNormal.x += n.x;
                            frontNormal.y += n.y;
                            count++;
                        }
                    });
                    
                    if (count > 0) {
                        const len = Math.sqrt(frontNormal.x * frontNormal.x + frontNormal.y * frontNormal.y);
                        if (len > 0) {
                            frontNormal.x /= len;
                            frontNormal.y /= len;
                            
                            pts.forEach((p, i) => {
                                const orig = edgeMap[i];
                                if (filteredFront.has(orig)) return;
                                const p2 = pts[(i + 1) % pts.length];
                                const n = getSegmentNormal(p, p2, centroid);
                                const dot = n.x * frontNormal.x + n.y * frontNormal.y;
                                if (dot < -0.5 && !nextEdgeTypes[orig]) {
                                    nextEdgeTypes[orig] = 'back';
                                }
                            });
                        }
                    }
                }
            }
            
            const sameFront = (a, b) => {
                if (!a || !b || a.size !== b.size) return false;
                for (const v of a) if (!b.has(v)) return false;
                return true;
            };
            const sameEdgeTypes = (a, b) => {
                const aKeys = Object.keys(a || {});
                const bKeys = Object.keys(b || {});
                if (aKeys.length !== bKeys.length) return false;
                for (const k of aKeys) if (a[k] !== b[k]) return false;
                return true;
            };
            
            if (!sameFront(frontageIndices || new Set(), filteredFront)) setFrontageIndices(filteredFront);
            if (!sameEdgeTypes(edgeTypes || {}, nextEdgeTypes)) setEdgeTypes(nextEdgeTypes);
        }, [basePoints, baseCurves, baseWidthM, baseDepthM, inputs.roads, frontageIndices, edgeTypes]);

        // 標準化點座標 (Normalize points)
        const normalizePoints = (points) => {
            if (!points) return null;
            const centroid = getPolygonCentroid(points);
            return points.map(p => ({ x: p.x - centroid.x, y: p.y - centroid.y }));
        };

        // 核心修正: 預先計算標準化的基地數據 (Core Fix: Pre-calculate normalized base data)
        // 確保所有樓層和退縮計算都基於同一個中心點 (0,0)，避免基地形狀改變時發生位移
        const normalizedData = useMemo(() => {
             if (!basePoints) {
                 const hw = baseWidthM / 2; const hd = baseDepthM / 2;
                 const pts = [{x: -hw, y: -hd}, {x: hw, y: -hd}, {x: hw, y: hd}, {x: -hw, y: hd}];
                 return { points: pts, curves: null, centroid: {x:0, y:0} };
             }
             return normalizeWithCurves(basePoints, baseCurves);
        }, [basePoints, baseCurves, baseWidthM, baseDepthM]);

        // 樓層量體生成邏輯 (Massing generation logic)
        const massingLayers = useMemo(() => {
            const layers = [];
            const limitCFA = res.totalCFA;
            const taxableBasementArea = Math.max(0, activeBasementArea - res.exemptBasement);
            const availableForSuperstructure = Math.max(0, limitCFA - taxableBasementArea);
            
            let remainingAreaM2 = availableForSuperstructure; 
            
            let currentZM = 0;
            let floorCount = 0;
            let currentTotalUsed = taxableBasementArea; 
            
            const inputFloorsAbove = parseFloat(inputs.floorsAbove || 0);
            const targetFloorsAbove = manualFloorsOverride !== null ? manualFloorsOverride : (inputFloorsAbove > 0 ? inputFloorsAbove : res.floorsAbove);
            const fullFloorsTarget = Math.floor(targetFloorsAbove);
            const fractionalFloorRatio = Math.max(0, targetFloorsAbove - fullFloorsTarget);
            const maxSimulatedFloors = Math.min(targetFloorsAbove, 100);
            const buildBackM = backM;
            const buildFrontM = baseDepthM - frontM;
            const buildWidthM = Math.max(0, baseWidthM - sideM);
            const originHeightRatioY = baseDepthM + roadW_M; 
            const originWeiLaoY = baseDepthM + roadW_M / 2;
            
            // 1. Identify Front/Side indices strictly from Roads configuration (Source of Truth)
            const primaryIndices = new Set();
            const secondaryIndices = new Set();
            
            if (inputs.roads) {
                inputs.roads.forEach(r => {
                    const indices = new Set();
                    if (r.edgeIndices) r.edgeIndices.forEach(i => indices.add(i));
                    if (r.edgeIndex !== undefined && r.edgeIndex !== "") indices.add(parseInt(r.edgeIndex));
                    
                    if (r.type === 'primary') {
                        indices.forEach(i => primaryIndices.add(i));
                    } else {
                        indices.forEach(i => secondaryIndices.add(i));
                    }
                });
            }

            const effectiveFrontIndices = new Set();
            
            // LOGIC FIX: Prioritize Roads over manual frontageIndices state
            if (primaryIndices.size > 0) {
                 primaryIndices.forEach(i => effectiveFrontIndices.add(i));
            } else if (secondaryIndices.size > 0) {
                 secondaryIndices.forEach(i => effectiveFrontIndices.add(i));
            } else if (frontageIndices && frontageIndices.size > 0) {
                 // Only fallback to manual state if no roads define edges
                 frontageIndices.forEach(i => effectiveFrontIndices.add(i));
            }

            // Prepare combined edge types (Secondary -> Side)
            const combinedEdgeTypes = { ...edgeTypes };
            secondaryIndices.forEach(idx => {
                if (!effectiveFrontIndices.has(idx) && !combinedEdgeTypes[idx]) {
                    combinedEdgeTypes[idx] = 'side';
                }
            });

            // --- Auto-Detect Back/Side Edges Logic (Sync with CheckLines) ---
            // 使用標準化數據確保計算一致性 (Use normalized data for consistency)
            if (normalizedData.points && normalizedData.points.length > 2) {
                const normPoints = normalizedData.points;
                const discretized = discretizePolygon(normPoints, normalizedData.curves, 20);
                const workingPoints = discretized.points;
                const workingEdgeIndices = discretized.edgeMap;
                const centroid = getPolygonCentroid(workingPoints);
                
                let frontNormal = { x: 0, y: 0 };
                let count = 0;
                
                workingPoints.forEach((p, i) => {
                    const orig = workingEdgeIndices[i];
                    if (effectiveFrontIndices.has(orig)) {
                        const p2 = workingPoints[(i + 1) % workingPoints.length];
                        const n = getSegmentNormal(p, p2, centroid);
                        frontNormal.x += n.x;
                        frontNormal.y += n.y;
                        count++;
                    }
                });

                if (count > 0) {
                    const len = Math.sqrt(frontNormal.x*frontNormal.x + frontNormal.y*frontNormal.y);
                    if (len > 0) {
                        frontNormal.x /= len; frontNormal.y /= len;
                        
                        const hasExplicitBack = Object.values(combinedEdgeTypes).includes('back');
                        if (!hasExplicitBack) {
                            workingPoints.forEach((p, i) => {
                                const origIdx = workingEdgeIndices[i];
                                if (!effectiveFrontIndices.has(origIdx) && !combinedEdgeTypes[origIdx]) {
                                    const p2 = workingPoints[(i + 1) % workingPoints.length];
                                    const n = getSegmentNormal(p, p2, centroid);
                                    const dot = n.x * frontNormal.x + n.y * frontNormal.y;
                                    if (dot < -0.5) { 
                                        combinedEdgeTypes[origIdx] = 'back'; 
                                    }
                                }
                            });
                        }

                        const hasExplicitSide = Object.values(combinedEdgeTypes).includes('side');
                        if (!hasExplicitSide && sideM > 0) {
                            const desiredSign = sideDir === 'left' ? 1 : -1;
                            const candidates = [];
                            workingPoints.forEach((p, i) => {
                                const origIdx = workingEdgeIndices[i];
                                if (effectiveFrontIndices.has(origIdx) || combinedEdgeTypes[origIdx]) return;
                                const p2 = workingPoints[(i + 1) % workingPoints.length];
                                const n = getSegmentNormal(p, p2, centroid);
                                const dot = n.x * frontNormal.x + n.y * frontNormal.y;
                                const cross = frontNormal.x * n.y - frontNormal.y * n.x;
                                candidates.push({ origIdx, dot, cross });
                            });
                            let selected = candidates.filter(c => Math.abs(c.dot) < 0.3 && desiredSign * c.cross > 0);
                            if (selected.length === 0) {
                                selected = candidates.filter(c => desiredSign * c.cross > 0).sort((a, b) => Math.abs(a.dot) - Math.abs(b.dot));
                            }
                            selected.forEach(c => { combinedEdgeTypes[c.origIdx] = 'side'; });
                        }
                    }
                }
            }
            // -----------------------------------------------------------

            // Initial 1F Footprint (using static setbacks)
            let oneFFootprint = null;
            if (normalizedData.points) { 
                const res = offsetPolygon(normalizedData.points, combinedEdgeTypes, { front: frontM, back: backM, side: sideM }, effectiveFrontIndices, normalizedData.curves); 
                oneFFootprint = res ? res.points : null;
            }

            // Fix: Strict Area/Floor limit check to avoid generating unused residual areas
            while ((remainingAreaM2 > 0.1 || floorCount < targetFloorsAbove) && floorCount < maxSimulatedFloors) {
                if (remainingAreaM2 <= 0.1 && manualFloorsOverride === null) break;
                const floorId = `${floorCount + 1}F`;
                const settings = floorSettings[floorId] || {};
                const h = (floorCount === 0) ? (parseFloat(inputs.floorHeight1F) || 4.2) : (parseFloat(inputs.floorHeightOther) || 3.6);
                
                // IMPORTANT: Check constraints at the TOP of the current floor
                const checkZ = currentZM + h; 
                
                // --- Dynamic Setback Calculation ---
                let currentFrontM = frontM;
                let effectiveBackM = backM;
                
                // Base Setbacks (Without Review Lines) for comparison
                let baseFrontM = frontM;
                let baseBackM = backM;
                
                // Arcade handling
                if (floorCount === 0 && arcadeM > 0) {
                     currentFrontM = Math.max(currentFrontM, arcadeM);
                     baseFrontM = Math.max(baseFrontM, arcadeM);
                }

                if (isConstraintMode) {
                     // 1. Height Ratio (Front)
                     const reqFrontHR = (checkZ / 3.6) - roadW_M;
                     if (reqFrontHR > currentFrontM) currentFrontM = reqFrontHR;

                     // 2. Wei Lao (Front) - if active
                     if (showWeiLao) {
                         const reqFrontWL = (checkZ / 5.0) - (roadW_M / 2);
                         if (reqFrontWL > currentFrontM) currentFrontM = reqFrontWL;
                     }
                }

                if ((isConstraintMode || showCheckLines) && byRatio > 0) {
                    const reqBack = checkZ / byRatio;
                    if (effectiveBackM < reqBack) effectiveBackM = reqBack;
                }
                
                const maxBaseBackM = Math.max(0, baseDepthM - baseFrontM);
                if (baseBackM > maxBaseBackM) baseBackM = maxBaseBackM;
                
                const maxFrontM = Math.max(0, baseDepthM - baseBackM);
                if (currentFrontM > maxFrontM) currentFrontM = maxFrontM;
                
                const maxBackM = Math.max(0, baseDepthM - currentFrontM);
                if (effectiveBackM > maxBackM) effectiveBackM = maxBackM;

                // Recalculate polygon OR Box dimensions based on dynamic setbacks
                let floorPolygon = null;
                let floorPolygonArea = 0;
                
                // Calculate Static Polygon (Before Review Cuts) for Unused Area display
                let staticPolygon = null;
                let staticArea = 0;
                
                // --- Box Mode Calculation Variables ---
                let boxWidthM = 0;
                let boxDepthM = 0;
                let shiftX_M = 0;
                let shiftY_M = 0;

                if (normalizedData.points) {
                    // Polygon Mode
                    // 1. Calculate Actual Floor (Dynamic)
                    if (isConstraintMode || (showCheckLines && byRatio > 0) || currentFrontM > frontM || effectiveBackM > backM || (floorCount === 0 && arcadeM > 0)) {
                         const res = offsetPolygon(normalizedData.points, combinedEdgeTypes, { front: currentFrontM, back: effectiveBackM, side: sideM }, effectiveFrontIndices, normalizedData.curves);
                         floorPolygon = res ? res.points : null;
                    } else {
                         floorPolygon = oneFFootprint; // Reuse 1F if no change
                    }
                    floorPolygonArea = floorPolygon ? calculatePolygonArea(floorPolygon) : 0;
                    
                    // 2. Calculate Static Floor (Base Constraints Only)
                    if (currentFrontM > baseFrontM || effectiveBackM > baseBackM) {
                        const staticRes = offsetPolygon(normalizedData.points, combinedEdgeTypes, { front: baseFrontM, back: baseBackM, side: sideM }, effectiveFrontIndices, normalizedData.curves);
                        staticPolygon = staticRes ? staticRes.points : null;
                        staticArea = staticPolygon ? calculatePolygonArea(staticPolygon) : 0;
                    } else {
                        staticPolygon = floorPolygon;
                        staticArea = floorPolygonArea;
                    }
                } else {
                    // Box Mode
                    // Dynamic
                    boxWidthM = Math.max(0, baseWidthM - sideM);
                    boxDepthM = Math.max(0, baseDepthM - currentFrontM - effectiveBackM);
                    floorPolygonArea = boxWidthM * boxDepthM;

                    // Static
                    const staticDepthM = Math.max(0, baseDepthM - baseFrontM - baseBackM);
                    staticArea = boxWidthM * staticDepthM;
                    // We don't have points for Box Mode easily without generating rects, 
                    // but BuildingLayer handles box mode via width/depth.
                    // We can pass `staticDepth` to layer.

                    // Calculate Shift for Box (Relative to Center)
                    shiftY_M = (effectiveBackM - currentFrontM) / 2;
                    
                    // X Shift: Based on Side Direction
                    if (sideDir === 'left') shiftX_M = sideM / 2;
                    else if (sideDir === 'right') shiftX_M = -sideM / 2;
                }
                
                const coverageLimit = parseFloat(res.maxBuildingArea) || 0;
                const maxFloorAreaM2 = coverageLimit > 0 ? Math.min(floorPolygonArea, coverageLimit) : floorPolygonArea; 
                
                // Task 2: Do not generate tiny fragments (Unused Area rule)
                if (maxFloorAreaM2 <= 3.0 && !settings.manualDim && !settings.manualArea) break; 
                
                let visualWidthM = boxWidthM;
                let visualDepthM = boxDepthM;
                let rotation = settings.rotation || 0;
                let usedAreaM2 = 0;

                // Determine Area Usage
                if (settings.manualDim && settings.width !== undefined && settings.depth !== undefined) { 
                    visualWidthM = settings.width; visualDepthM = settings.depth; usedAreaM2 = visualWidthM * visualDepthM; 
                } 
                else if (settings.manualArea && settings.area !== undefined) { 
                    usedAreaM2 = settings.area; 
                } 
                else { 
                    const isFractionalFloor = fractionalFloorRatio > 0 && floorCount === fullFloorsTarget;
                    const perFloorAreaCap = isFractionalFloor ? maxFloorAreaM2 * fractionalFloorRatio : maxFloorAreaM2;
                    usedAreaM2 = Math.min(remainingAreaM2, perFloorAreaCap);
                }
                
                if (isConstraintMode) {
                     usedAreaM2 = Math.min(usedAreaM2, maxFloorAreaM2);
                }
                
                // Calculate Final Geometry
                let layerPoints = settings.points || null;
                let layerCurves = settings.curves || null;

                if (layerPoints && normalizedData.centroid) {
                     const c = normalizedData.centroid;
                     layerPoints = layerPoints.map(p => ({ x: p.x - c.x, y: p.y - c.y }));
                     if (layerCurves) {
                         const newC = {};
                         Object.keys(layerCurves).forEach(k => {
                             const cp = layerCurves[k];
                             newC[k] = { x: cp.x - c.x, y: cp.y - c.y };
                         });
                         layerCurves = newC;
                     }
                }

                if (!layerPoints && floorPolygon) {
                    layerPoints = floorPolygon;
                    // If we need to scale down (e.g. not enough remaining area)
                    if (usedAreaM2 < floorPolygonArea - 0.1) {
                         const scaleRate = Math.sqrt(usedAreaM2 / floorPolygonArea);
                         const polyCentroid = getPolygonCentroid(floorPolygon);
                         const { points: newPts, curves: newCurves } = scalePolygon(floorPolygon, null, scaleRate, polyCentroid);
                         layerPoints = newPts;
                         layerCurves = newCurves;
                    }
                } else if (!layerPoints && !normalizedData.points) {
                    // Box Mode Scaling (if using less than max area)
                    const usageRatio = maxFloorAreaM2 > 0 ? usedAreaM2 / maxFloorAreaM2 : 0; 
                    const scaleFactor = Math.sqrt(usageRatio); 
                    visualWidthM = boxWidthM * scaleFactor; 
                    visualDepthM = boxDepthM * scaleFactor;
                }
                
                // Manual Offsets (User dragging)
                const alignPref = settings.alignment || { x: 'left', y: 'back' };
                const getOffsets = () => {
                    if (settings.offset) return settings.offset;
                    return { x: 0, y: 0 };
                }
                const userOff = getOffsets();

                let finalShiftYPx, finalShiftX;
                if (layerPoints) { 
                    // Polygon Mode
                    finalShiftYPx = userOff.y * scale; 
                    finalShiftX = userOff.x * scale; 
                } else { 
                    // Box Mode: Combine calculated shift with user offset
                    finalShiftX = (shiftX_M * scale) + (settings.offset?.x || 0);
                    finalShiftYPx = (shiftY_M * scale) + (settings.offset?.y || 0);
                }

                const violations = []; 
                
                // Task 3: Unit Division Support
                let splitUnits = null;
                let isAutoSplit = false;

                if (unitSettings?.enabled && floorPolygon) {
                     splitUnits = getSplitUnits(floorPolygon, unitSettings);
                     isAutoSplit = true;
                } else if (settings.units && settings.units.length > 0) {
                     // Manual units
                     splitUnits = settings.units;
                }

                if (splitUnits && splitUnits.length > 0) {
                    splitUnits.forEach((uPts, uIdx) => {
                         let finalUPts = uPts;
                         
                         const uArea = calculatePolygonArea(finalUPts);
                         const uUsed = Math.min(uArea, remainingAreaM2); // Cap by FAR
                         
                         layers.push({
                             id: `${floorId}-${String.fromCharCode(65+uIdx)}`, // A, B, C...
                             z: currentZM * scale,
                             height: h * scale,
                             widthPx: visualWidthM * scale, 
                             depthPx: visualDepthM * scale,
                             shiftX: finalShiftX,
                             shiftYPx: finalShiftYPx,
                             rotation: rotation,
                             pivot: settings.pivot,
                             realArea: uUsed,
                             realWidth: visualWidthM, // Approx
                             realDepth: visualDepthM, // Approx
                             realHeight: h,
                             maxGeometricArea: uArea,
                             isViolation: violations.length > 0,
                             violations: violations,
                             points: finalUPts,
                             curves: null, // Curves not supported in split yet
                             staticPoints: null, // Manual mode implies no auto-ghosting
                             unusedReviewArea: 0
                         });
                         remainingAreaM2 -= uUsed;
                         currentTotalUsed += uUsed;
                    });
                } else {
                    layers.push({
                        id: floorId, 
                        z: currentZM * scale, 
                        height: h * scale, 
                        
                        widthPx: visualWidthM * scale,
                        depthPx: visualDepthM * scale,
                        
                        shiftX: finalShiftX,
                        shiftYPx: finalShiftYPx,
                        
                        rotation: rotation, 
                        pivot: settings.pivot, 
                        realArea: usedAreaM2, 
                        realWidth: visualWidthM, 
                        realDepth: visualDepthM, 
                        realHeight: h, 
                        maxGeometricArea: maxFloorAreaM2, 
                        isViolation: violations.length>0, 
                        violations: violations, 
                        points: layerPoints, 
                        curves: layerCurves,
                        
                        // Task 2 Data
                        staticPoints: staticPolygon,
                        unusedReviewArea: Math.max(0, staticArea - floorPolygonArea)
                    });
                    remainingAreaM2 -= usedAreaM2; currentTotalUsed += usedAreaM2;
                }
                currentZM += h; floorCount++;
            }
            return { layers, totalFloors: floorCount, totalHeight: currentZM, currentTotalUsed, remainingArea: Math.max(0, remainingAreaM2) };
        }, [res.totalCFA, res.exemptBasement, activeBasementArea, baseDepthM, baseWidthM, frontM, backM, sideM, roadW_M, inputs.floorHeight1F, inputs.floorHeightOther, showCheckLines, showWeiLao, byRatio, scale, floorSettings, arcadeM, isConstraintMode, manualFloorsOverride, normalizedData, edgeTypes, frontageIndices, res.floorsAbove, inputs.roads, inputs.minBackyardDepthRatio, sideDir, unitSettings]); 

          const handleAddFloor = () => { 
    if (massingLayers.currentTotalUsed >= res.totalCFA) {
        alert("已達最大允建總樓地板面積 (Total CFA) 上限，無法新增樓層。");
        return;
    }
              setManualFloorsOverride((prev) => { const base = prev !== null ? prev : massingLayers.totalFloors; const next = base + 1; onUpdateInputs('floorsAbove', next); return next; }); 
          };
        const handleRemoveFloor = () => { const newFloorsAbove = Math.max(1, (manualFloorsOverride !== null ? manualFloorsOverride : massingLayers.totalFloors) - 1); setManualFloorsOverride(newFloorsAbove); onUpdateInputs('floorsAbove', newFloorsAbove); if (selectedFloor && !['base', 'excavation'].includes(selectedFloor.id)) { const floorNum = parseInt(selectedFloor.id); if (!isNaN(floorNum) && floorNum > newFloorsAbove) { setSelectedFloor(null); } } };
        const handleSetFloorsAbove = (value) => { const numeric = Number.isFinite(value) ? value : parseFloat(value); const safe = Math.max(1, Number.isFinite(numeric) ? numeric : 1); setManualFloorsOverride(safe); onUpdateInputs('floorsAbove', safe); if (selectedFloor && !['base', 'excavation'].includes(selectedFloor.id)) { const floorNum = parseInt(selectedFloor.id); if (!isNaN(floorNum) && floorNum > safe) { setSelectedFloor(null); } } };
        const handleApplyAllFloors = (payload) => {
            if (!payload || !payload.area || payload.area <= 0) return;
            const taxableBasementArea = Math.max(0, activeBasementArea - res.exemptBasement);
            const availableForSuperstructure = Math.max(0, res.totalCFA - taxableBasementArea);
            let areaPerFloor = payload.area;
            if (availableForSuperstructure > 0 && areaPerFloor > availableForSuperstructure) areaPerFloor = availableForSuperstructure;
            const targetFloors = availableForSuperstructure > 0 ? Math.max(1, Math.floor(availableForSuperstructure / areaPerFloor)) : 1;
            const finalFloors = targetFloors;
            setManualFloorsOverride(finalFloors);
            onUpdateInputs('floorsAbove', finalFloors);
            setFloorSettings(prev => {
                const next = { ...prev };
                for (let i = 1; i <= finalFloors; i++) {
                    const floorId = `${i}F`;
                    const current = next[floorId] || {};
                    if (payload.mode === 'polygon' && payload.points && payload.points.length >= 3) {
                        let points = payload.points;
                        let curves = payload.curves || null;
                        const currentArea = calculatePolygonArea(payload.points);
                        if (currentArea > 0 && Math.abs(currentArea - areaPerFloor) > 0.01) {
                            const scaleRate = Math.sqrt(areaPerFloor / currentArea);
                            const scaled = scalePolygon(payload.points, payload.curves || null, scaleRate);
                            points = scaled.points;
                            curves = scaled.curves;
                        }
                        next[floorId] = { ...current, points, curves, area: areaPerFloor, manualArea: true, manualDim: false };
                        delete next[floorId].width;
                        delete next[floorId].depth;
                    } else {
                        const baseW = payload.width || baseWidthM;
                        const baseD = payload.depth || baseDepthM;
                        const baseArea = baseW * baseD;
                        let width = baseW;
                        let depth = baseD;
                        if (baseArea > 0 && Math.abs(baseArea - areaPerFloor) > 0.01) {
                            const scaleRate = Math.sqrt(areaPerFloor / baseArea);
                            width = baseW * scaleRate;
                            depth = baseD * scaleRate;
                        }
                        next[floorId] = { ...current, width, depth, manualDim: true, manualArea: false, area: width * depth };
                        delete next[floorId].points;
                        delete next[floorId].curves;
                    }
                }
                Object.keys(next).forEach(k => {
                    const m = /^(\d+)F$/.exec(k);
                    if (m && parseInt(m[1]) > finalFloors) delete next[k];
                });
                return next;
            });
            if (selectedFloor && !['base', 'excavation'].includes(selectedFloor.id)) {
                const floorNum = parseInt(selectedFloor.id);
                if (!isNaN(floorNum) && floorNum > finalFloors) setSelectedFloor(null);
            }
        };

        useEffect(() => { if (selectedFloor) { const layer = massingLayers.layers.find(l => l.id === selectedFloor.id); if (layer) { setSelectedFloor({ ...layer, rotation: floorSettings[layer.id]?.rotation || 0, pivot: floorSettings[layer.id]?.pivot || { x: 0, y: 0 }, alignment: floorSettings[layer.id]?.alignment || { x: 'left', y: 'back' }, violations: layer.violations, points: floorSettings[layer.id]?.points || null, curves: floorSettings[layer.id]?.curves || null }); } } }, [floorSettings, isConstraintMode]);

        const floorLayers = massingLayers.layers;
        const colors = { bg: isDarkMode ? "#0f172a" : "#fafaf9", grid: isDarkMode ? "linear-gradient(#1e293b 1px, transparent 1px), linear-gradient(90deg, #1e293b 1px, transparent 1px)" : "linear-gradient(#e5e7eb 1px, transparent 1px), linear-gradient(90deg, #e5e7eb 1px, transparent 1px)", floor: showCheckLines ? (isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(255, 255, 255, 0.3)") : (isDarkMode ? "rgba(255, 255, 255, 0.9)" : "#ffffff"), stroke: showCheckLines ? "#fb923c" : (isDarkMode ? "#94a3b8" : "#a8a29e") };
        const visualTotalH_Px = massingLayers.totalHeight * scale;
        const visualFloorsAbove = massingLayers.totalFloors;
        const floorsAboveValue = manualFloorsOverride !== null ? manualFloorsOverride : (parseFloat(inputs.floorsAbove || 0) || res.floorsAbove);
        const totalAreaViolation = massingLayers.currentTotalUsed > volumeLimit; 
        const unusedArea = massingLayers.remainingArea;

        useEffect(() => {
            if (onUnusedAreaChange) onUnusedAreaChange(unusedArea);
        }, [unusedArea, onUnusedAreaChange]);

        // Pre-calculate Normalized Base Points for the entire visualization context
        // This ensures all layers share the same "Site Center" origin.
        // OLD: const normalizedBasePoints = useMemo(...) -> Replaced by normalizedData above

        const renderRoads = () => {
             // Use explicit base points OR default rect to render roads relative to something stable
             // Use the MEMOIZED normalized points to ensure alignment
             // 道路渲染邏輯 (Road rendering logic)
             // 使用與樓層一致的標準化數據 (Use same normalized data as floors)
             const normalizedPoints = normalizedData.points;
             const N = normalizedPoints.length;
             
             if (!inputs.roads || inputs.roads.length === 0) return null;

             const paths = [];
             const labels = [];
             
             // 1. Collect all road segments
             const allSegments = [];
             inputs.roads.forEach(road => {
                 const indices = new Set();
                 if (road.edgeIndices) road.edgeIndices.forEach(i => indices.add(i));
                 if (road.edgeIndex !== undefined) indices.add(road.edgeIndex);
                 
                 indices.forEach(idx => {
                     allSegments.push({
                         edgeIdx: idx,
                         width: parseFloat(road.width || 6),
                         name: road.name,
                         roadId: road.id,
                         type: road.type
                     });
                 });
             });
             
             if (allSegments.length === 0) return null;

             // 2. Sort by edge index
             allSegments.sort((a, b) => a.edgeIdx - b.edgeIdx);

             // 3. Group adjacent segments with same WIDTH
             const groups = [];
             if (allSegments.length > 0) {
                 let curGroup = [allSegments[0]];
                 for (let i = 1; i < allSegments.length; i++) {
                     const prev = curGroup[curGroup.length - 1];
                     const curr = allSegments[i];
                     // Check adjacency (curr.edgeIdx == prev.edgeIdx + 1) AND same width
                     if (curr.edgeIdx === prev.edgeIdx + 1 && Math.abs(curr.width - prev.width) < 0.01) {
                         curGroup.push(curr);
                     } else {
                         groups.push(curGroup);
                         curGroup = [curr];
                     }
                 }
                 // Check wrapping (Last -> First)
                 if (groups.length > 0) {
                     const first = groups[0][0];
                     const last = curGroup[curGroup.length - 1];
                     if (last.edgeIdx === N - 1 && first.edgeIdx === 0 && Math.abs(last.width - first.width) < 0.01) {
                          groups[0] = [...curGroup, ...groups[0]];
                     } else {
                          groups.push(curGroup);
                     }
                 } else {
                      groups.push(curGroup);
                 }
             }

             // 4. Render groups
             groups.forEach((grp, gIdx) => {
                 const roadRW = grp[0].width;
                 const isLoop = (grp.length === N);
                 const shouldExtend = !isLoop;
                 const EXT_LEN = 50; 
                 
                 let rawPoints = [];
                 let rawCurves = [];
                 grp.forEach(seg => {
                     rawPoints.push(normalizedPoints[seg.edgeIdx % N]);
                     rawCurves.push(normalizedData.curves?.[seg.edgeIdx % N]);
                 });
                 const lastSeg = grp[grp.length-1];
                 rawPoints.push(normalizedPoints[(lastSeg.edgeIdx + 1) % N]); // End point

                 let finalPoints = [...rawPoints];
                 let finalCurves = [...rawCurves];

                 if (shouldExtend && rawPoints.length >= 2) {
                     const p0 = rawPoints[0];
                     const p1 = rawPoints[1];
                     const c0 = rawCurves[0];
                     
                     let startDir = { x: p1.x - p0.x, y: p1.y - p0.y };
                     if (c0) {
                         startDir = { x: c0.x - p0.x, y: c0.y - p0.y };
                     }
                     const lenStart = Math.sqrt(startDir.x*startDir.x + startDir.y*startDir.y);
                     if (lenStart > 0) {
                         const extP = { 
                             x: p0.x - (startDir.x/lenStart) * EXT_LEN, 
                             y: p0.y - (startDir.y/lenStart) * EXT_LEN 
                         };
                         finalPoints.unshift(extP);
                         finalCurves.unshift(null);
                     }

                     const pn = rawPoints[rawPoints.length-1];
                     const pn_1 = rawPoints[rawPoints.length-2];
                     const cn_1 = rawCurves[rawCurves.length-1];
                     
                     let endDir = { x: pn.x - pn_1.x, y: pn.y - pn_1.y };
                     if (cn_1) {
                         endDir = { x: pn.x - cn_1.x, y: pn.y - cn_1.y };
                     }
                     const lenEnd = Math.sqrt(endDir.x*endDir.x + endDir.y*endDir.y);
                     if (lenEnd > 0) {
                         const extP = {
                             x: pn.x + (endDir.x/lenEnd) * EXT_LEN,
                             y: pn.y + (endDir.y/lenEnd) * EXT_LEN
                         };
                         finalPoints.push(extP);
                         finalCurves.push(null);
                     }
                 }

                 const getOffsetLine = (p1, p2) => {
                     const centroid = {x:0, y:0};
                     const normal = getSegmentNormal(p1, p2, centroid); 
                     const vx = -normal.x * roadRW; 
                     const vy = -normal.y * roadRW;
                     return { start: {x: p1.x + vx, y: p1.y + vy}, dir: {x: p2.x - p1.x, y: p2.y - p1.y}, vec: {x: vx, y: vy} };
                 };
                 const getIntersection = (l1, l2) => {
                     const x1 = l1.start.x; const y1 = l1.start.y;
                     const x2 = x1 + l1.dir.x; const y2 = y1 + l1.dir.y;
                     const x3 = l2.start.x; const y3 = l2.start.y;
                     const x4 = x3 + l2.dir.x; const y4 = y3 + l2.dir.y;
                     const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                     if (Math.abs(den) < 1e-6) return null;
                     const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
                     return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1) };
                 };

                 const lines = [];
                 for(let i=0; i < finalPoints.length - 1; i++) {
                     lines.push(getOffsetLine(finalPoints[i], finalPoints[i+1]));
                 }

                 const outerPoints = [];
                 for(let i=0; i < finalPoints.length; i++) {
                     let pt;
                     if (isLoop && !shouldExtend) {
                         const l1 = lines[(i - 1 + lines.length) % lines.length];
                         const l2 = lines[i % lines.length];
                         pt = getIntersection(l1, l2) || { x: finalPoints[i].x + l1.vec.x, y: finalPoints[i].y + l1.vec.y };
                     } else {
                         if (i === 0) {
                             const l = lines[0];
                             pt = { x: finalPoints[0].x + l.vec.x, y: finalPoints[0].y + l.vec.y };
                         } else if (i === finalPoints.length - 1) {
                             const l = lines[lines.length - 1];
                             pt = { x: finalPoints[i].x + l.vec.x, y: finalPoints[i].y + l.vec.y };
                         } else {
                             const l1 = lines[i-1];
                             const l2 = lines[i];
                             pt = getIntersection(l1, l2) || { x: finalPoints[i].x + l1.vec.x, y: finalPoints[i].y + l1.vec.y };
                         }
                     }
                     outerPoints.push(pt);
                 }

                 let innerPathD = "";
                 let outerPathD = "";

                 finalPoints.forEach((p, i) => {
                     const x = p.x*scale + w/2; 
                     const y = p.y*scale + d/2;
                     if (i === 0) innerPathD += `M ${x} ${y}`;
                     else {
                         const curve = finalCurves[i-1];
                         if (curve) {
                             innerPathD += ` Q ${curve.x*scale + w/2} ${curve.y*scale + d/2}, ${x} ${y}`;
                         } else {
                             innerPathD += ` L ${x} ${y}`;
                         }
                     }
                 });

                 for(let i = outerPoints.length - 1; i >= 0; i--) {
                     const p = outerPoints[i];
                     const x = p.x*scale + w/2;
                     const y = p.y*scale + d/2;
                     
                     if (i === outerPoints.length - 1) outerPathD += ` L ${x} ${y}`;
                     else {
                         const curve = finalCurves[i];
                         if (curve) {
                             const l = lines[i];
                             const cp = { x: curve.x*scale + w/2 + l.vec.x*scale, y: curve.y*scale + d/2 + l.vec.y*scale };
                             outerPathD += ` Q ${cp.x} ${cp.y}, ${x} ${y}`;
                         } else {
                             outerPathD += ` L ${x} ${y}`;
                         }
                     }
                 }
                 
                 const fullD = innerPathD + outerPathD + " Z";
                 paths.push(
                     <path key={`road-path-${gIdx}`} d={fullD} fill={isDarkMode ? "rgba(71, 85, 105, 0.5)" : "rgba(229, 231, 235, 0.6)"} stroke={isDarkMode ? "#64748b" : "#d1d5db"} strokeWidth="1" strokeDasharray="5,5"/>
                 );
                 
                 // Label Logic: Use middle segment
                 const midSegIdx = Math.floor((rawPoints.length - 1) / 2);
                 const seg = grp[midSegIdx];
                 if (seg) {
                      const p1 = rawPoints[midSegIdx];
                      const p2 = rawPoints[midSegIdx+1];
                      const l = lines[midSegIdx + (shouldExtend ? 1 : 0)];
                      if (l) {
                         const labelX = (p1.x + p2.x)/2 * scale + w/2 + l.vec.x/2 * scale;
                         const labelY = (p1.y + p2.y)/2 * scale + d/2 + l.vec.y/2 * scale;
                         labels.push(
                             <Si key={`road-label-${gIdx}`} text={`${seg.name} ${seg.width}m`} x={labelX} y={labelY} z={2} rotationZ={rotationZ} baseRotation={inputs.northAngle || 0} viewAngleX={viewAngleX} visible={true} className={`text-[10px] font-bold bg-white/80 text-stone-600 px-1 rounded shadow-sm`} />
                         );
                      }
                 }
             });

             return (
                  <div style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', pointerEvents: 'none', zIndex: 5 }}>
                      <svg width="100%" height="100%" viewBox={`0 0 ${w} ${d}`} style={{overflow: 'visible'}}>
                           {paths}
                      </svg>
                      {labels}
                  </div>
             );
        };
        
        // 退縮範圍渲染邏輯 (Setback visualization logic)
        const renderPolygonSetbacks = () => {
             // 直接使用已計算好的標準化數據 (Use pre-calculated normalized data)
            const rawNormalized = normalizedData.points;
            if (!rawNormalized) return null;

            // 1. Discretize Base Points (Outer Ring) to match per-segment offset logic
            let { points: normalizedPoints, edgeMap } = discretizePolygon(rawNormalized, normalizedData.curves, 15);
             
             // Filter frontageIndices: Primary -> Front, Secondary -> Side (unless manually overridden)
             const primaryIndices = new Set();
             const secondaryIndices = new Set();
             
             if (inputs.roads) {
                 inputs.roads.forEach(r => {
                     const indices = new Set();
                     if (r.edgeIndices) r.edgeIndices.forEach(i => indices.add(i));
                     if (r.edgeIndex !== undefined && r.edgeIndex !== "") indices.add(parseInt(r.edgeIndex));
                     
                     if (r.type === 'primary') {
                         indices.forEach(i => primaryIndices.add(i));
                     } else {
                         indices.forEach(i => secondaryIndices.add(i));
                     }
                 });
             }
 
           const initialFront = new Set();
           
           if (frontageIndices && frontageIndices.size > 0) {
                frontageIndices.forEach(i => initialFront.add(i));
           } else if (primaryIndices.size > 0) {
                primaryIndices.forEach(i => initialFront.add(i));
           } else if (secondaryIndices.size > 0) {
                secondaryIndices.forEach(i => initialFront.add(i));
           }
 
            const edgeCount = rawNormalized.length;
            const frontIndices = new Set();
            initialFront.forEach(i => {
                if (Number.isInteger(i) && i >= 0 && i < edgeCount) frontIndices.add(i);
            });
            
            const combinedEdgeTypes = {};
            Object.keys(edgeTypes || {}).forEach(k => {
                const idx = parseInt(k);
                if (!Number.isNaN(idx) && idx >= 0 && idx < edgeCount && !frontIndices.has(idx)) {
                    combinedEdgeTypes[idx] = edgeTypes[k];
                }
            });
            secondaryIndices.forEach(idx => {
                if (idx >= 0 && idx < edgeCount && !frontIndices.has(idx) && !combinedEdgeTypes[idx]) {
                    combinedEdgeTypes[idx] = 'side';
                }
            });
            const hasExplicitBack = Object.values(combinedEdgeTypes).includes('back');
            if ((!hasExplicitBack || sideM > 0) && normalizedPoints.length > 2 && frontIndices.size > 0) {
                const centroid = getPolygonCentroid(normalizedPoints);
                let frontNormal = { x: 0, y: 0 };
                let count = 0;
                normalizedPoints.forEach((p, i) => {
                    const orig = edgeMap[i];
                    if (frontIndices.has(orig)) {
                        const p2 = normalizedPoints[(i + 1) % normalizedPoints.length];
                        const n = getSegmentNormal(p, p2, centroid);
                        frontNormal.x += n.x;
                        frontNormal.y += n.y;
                        count++;
                    }
                });
                if (count > 0) {
                    const len = Math.sqrt(frontNormal.x * frontNormal.x + frontNormal.y * frontNormal.y);
                    if (len > 0) {
                        frontNormal.x /= len;
                        frontNormal.y /= len;
                        if (!hasExplicitBack) {
                            normalizedPoints.forEach((p, i) => {
                                const origIdx = edgeMap[i];
                                if (!frontIndices.has(origIdx) && !combinedEdgeTypes[origIdx]) {
                                    const p2 = normalizedPoints[(i + 1) % normalizedPoints.length];
                                    const n = getSegmentNormal(p, p2, centroid);
                                    const dot = n.x * frontNormal.x + n.y * frontNormal.y;
                                    if (dot < -0.5) combinedEdgeTypes[origIdx] = 'back';
                                }
                            });
                        }
                        const hasExplicitSide = Object.values(combinedEdgeTypes).includes('side');
                        if (!hasExplicitSide && sideM > 0) {
                            const desiredSign = sideDir === 'left' ? 1 : -1;
                            const candidates = [];
                            normalizedPoints.forEach((p, i) => {
                                const origIdx = edgeMap[i];
                                if (frontIndices.has(origIdx) || combinedEdgeTypes[origIdx]) return;
                                const p2 = normalizedPoints[(i + 1) % normalizedPoints.length];
                                const n = getSegmentNormal(p, p2, centroid);
                                const dot = n.x * frontNormal.x + n.y * frontNormal.y;
                                const cross = frontNormal.x * n.y - frontNormal.y * n.x;
                                candidates.push({ origIdx, dot, cross });
                            });
                            let selected = candidates.filter(c => Math.abs(c.dot) < 0.3 && desiredSign * c.cross > 0);
                            if (selected.length === 0) {
                                selected = candidates.filter(c => desiredSign * c.cross > 0).sort((a, b) => Math.abs(a.dot) - Math.abs(b.dot));
                            }
                            selected.forEach(c => { combinedEdgeTypes[c.origIdx] = 'side'; });
                        }
                    }
                }
            }
            const centroid = getPolygonCentroid(normalizedPoints);
            const getDepthByType = (type) => {
                if (type === 'front') return arcadeM > 0 ? arcadeM : frontM;
                if (type === 'back') return backM;
                if (type === 'side') return sideM;
                return 0;
            };
            const getRegionType = (origIdx) => {
                if (frontIndices.has(origIdx)) return 'front';
                if (combinedEdgeTypes[origIdx] === 'back') return 'back';
                if (combinedEdgeTypes[origIdx] === 'side') return 'side';
                return null;
            };
            const buildOffsetPoints = (activeType) => {
                const shiftedLines = [];
                for (let i = 0; i < normalizedPoints.length; i++) {
                    const p1 = normalizedPoints[i];
                    const p2 = normalizedPoints[(i + 1) % normalizedPoints.length];
                    const origIdx = edgeMap[i];
                    const regionType = getRegionType(origIdx);
                    const depth = regionType === activeType ? getDepthByType(regionType) : 0;
                    const n = getSegmentNormal(p1, p2, centroid);
                    shiftedLines.push({
                        p1: { x: p1.x + n.x * depth, y: p1.y + n.y * depth },
                        p2: { x: p2.x + n.x * depth, y: p2.y + n.y * depth }
                    });
                }
                const newPoints = [];
                for (let i = 0; i < shiftedLines.length; i++) {
                    const l1 = shiftedLines[i];
                    const l2 = shiftedLines[(i + 1) % shiftedLines.length];
                    const intersect = getLineIntersection(l1.p1, l1.p2, l2.p1, l2.p2);
                    newPoints.push(intersect || l1.p2);
                }
                return newPoints;
            };
            const buildRingPath = (innerPts) => {
                if (!innerPts || innerPts.length < 3) return null;
                let dPath = "";
                normalizedPoints.forEach((p, i) => {
                    const x = p.x * scale + w / 2;
                    const y = p.y * scale + d / 2;
                    if (i === 0) dPath += `M ${x} ${y}`;
                    else dPath += ` L ${x} ${y}`;
                });
                dPath += " Z";
                const inner = [...innerPts].reverse();
                inner.forEach((p, i) => {
                    const x = p.x * scale + w / 2;
                    const y = p.y * scale + d / 2;
                    if (i === 0) dPath += ` M ${x} ${y}`;
                    else dPath += ` L ${x} ${y}`;
                });
                dPath += " Z";
                return dPath;
            };

            const paths = [];
             const hatchPalette = {
                 front: {
                     base: isDarkMode ? "rgba(244, 63, 94, 0.22)" : "rgba(244, 63, 94, 0.18)",
                     stripe: isDarkMode ? "rgba(244, 63, 94, 0.55)" : "rgba(244, 63, 94, 0.35)"
                 },
                 back: {
                     base: isDarkMode ? "rgba(16, 185, 129, 0.22)" : "rgba(16, 185, 129, 0.18)",
                     stripe: isDarkMode ? "rgba(16, 185, 129, 0.55)" : "rgba(16, 185, 129, 0.35)"
                 },
                 side: {
                     base: isDarkMode ? "rgba(59, 130, 246, 0.22)" : "rgba(59, 130, 246, 0.18)",
                     stripe: isDarkMode ? "rgba(59, 130, 246, 0.55)" : "rgba(59, 130, 246, 0.35)"
                 }
             };
             const hatchSize = Math.max(6, Math.min(16, scale * 0.8));
            const regionTypes = ['front', 'back', 'side'];
            const fillIds = { front: 'setback-front-hatch', back: 'setback-back-hatch', side: 'setback-side-hatch' };
            regionTypes.forEach(type => {
                const depth = getDepthByType(type);
                if (depth <= 0) return;
                let hasEdge = false;
                for (let i = 0; i < edgeMap.length; i++) {
                    if (getRegionType(edgeMap[i]) === type) { hasEdge = true; break; }
                }
                if (!hasEdge) return;
                const innerPts = buildOffsetPoints(type);
                const dPath = buildRingPath(innerPts);
                if (!dPath) return;
                paths.push(
                    <path key={`setback-area-${type}`} d={dPath} fill={`url(#${fillIds[type]})`} stroke="none" fillRule="evenodd" />
                );
            });

            const labels = [];
            const colorByType = { front: "#f43f5e", back: "#10b981", side: "#3b82f6" };
            const labelByType = { front: arcadeM > 0 ? "騎樓" : "前院", back: "後院", side: "側院" };
            const segmentsByOrig = new globalThis.Map();
            for (let i = 0; i < edgeMap.length; i++) {
                const orig = edgeMap[i];
                if (!segmentsByOrig.has(orig)) segmentsByOrig.set(orig, []);
                segmentsByOrig.get(orig).push(i);
            }
            segmentsByOrig.forEach((segments, origIdx) => {
                const regionType = getRegionType(origIdx);
                if (!regionType) return;
                const depth = getDepthByType(regionType);
                if (depth <= 0) return;
                const midSeg = segments[Math.floor(segments.length / 2)];
                const p1 = normalizedPoints[midSeg];
                const p2 = normalizedPoints[(midSeg + 1) % normalizedPoints.length];
                if (!p1 || !p2) return;
                const mid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                const n = getSegmentNormal(p1, p2, centroid);
                labels.push({
                    x: mid.x + n.x * depth * 0.5,
                    y: mid.y + n.y * depth * 0.5,
                    text: labelByType[regionType],
                    color: colorByType[regionType],
                    key: `${regionType}-${origIdx}`
                });
            });

            return (
                 <div style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', pointerEvents: 'none', zIndex: 10 }}>
                     <svg width="100%" height="100%" viewBox={`0 0 ${w} ${d}`} style={{overflow: 'visible'}}>
                          <defs>
                              <pattern id="setback-front-hatch" x="0" y="0" width={hatchSize} height={hatchSize} patternUnits="userSpaceOnUse" patternContentUnits="userSpaceOnUse" patternTransform="rotate(45)">
                                  <rect width={hatchSize} height={hatchSize} fill={hatchPalette.front.base} />
                                  <rect width={hatchSize / 2} height={hatchSize} fill={hatchPalette.front.stripe} />
                              </pattern>
                              <pattern id="setback-back-hatch" x="0" y="0" width={hatchSize} height={hatchSize} patternUnits="userSpaceOnUse" patternContentUnits="userSpaceOnUse" patternTransform="rotate(45)">
                                  <rect width={hatchSize} height={hatchSize} fill={hatchPalette.back.base} />
                                  <rect width={hatchSize / 2} height={hatchSize} fill={hatchPalette.back.stripe} />
                              </pattern>
                              <pattern id="setback-side-hatch" x="0" y="0" width={hatchSize} height={hatchSize} patternUnits="userSpaceOnUse" patternContentUnits="userSpaceOnUse" patternTransform="rotate(45)">
                                  <rect width={hatchSize} height={hatchSize} fill={hatchPalette.side.base} />
                                  <rect width={hatchSize / 2} height={hatchSize} fill={hatchPalette.side.stripe} />
                              </pattern>
                          </defs>
                          {paths}
                          {labels.map(label => (
                              <text key={label.key} x={label.x * scale + w / 2} y={label.y * scale + d / 2} textAnchor="middle" dominantBaseline="middle" fontSize="10" fill={label.color} opacity={0.9} className="select-none">
                                  {label.text}
                              </text>
                          ))}
                     </svg>
                 </div>
            );
        };

        const renderReviewSurfaces = () => {
            const paths = [];
            const offX = w / 2;
            const offY = d / 2;
            let workingPoints = [];
            let workingEdgeIndices = [];
            if (normalizedData.points && normalizedData.points.length > 2) {
                const discretized = discretizePolygon(normalizedData.points, normalizedData.curves, 20);
                workingPoints = discretized.points;
                workingEdgeIndices = discretized.edgeMap;
            } else {
                const hw = baseWidthM / 2; const hd = baseDepthM / 2;
                workingPoints = [{x: -hw, y: -hd}, {x: hw, y: -hd}, {x: hw, y: hd}, {x: -hw, y: hd}];
                workingEdgeIndices = [0, 1, 2, 3];
            }
            if (!workingPoints || workingPoints.length < 3) return null;
            const centroid = getPolygonCentroid(workingPoints);
            const primaryIndices = new Set();
            const secondaryIndices = new Set();
            if (inputs.roads) {
                inputs.roads.forEach(r => {
                    const indices = new Set();
                    if (r.edgeIndices) r.edgeIndices.forEach(i => indices.add(i));
                    if (r.edgeIndex !== undefined && r.edgeIndex !== "") indices.add(parseInt(r.edgeIndex));
                    if (r.type === 'primary') indices.forEach(i => primaryIndices.add(i));
                    else indices.forEach(i => secondaryIndices.add(i));
                });
            }
            const frontIndices = new Set();
            if (frontageIndices && frontageIndices.size > 0) frontageIndices.forEach(i => frontIndices.add(i));
            else if (primaryIndices.size > 0) primaryIndices.forEach(i => frontIndices.add(i));
            else if (secondaryIndices.size > 0) secondaryIndices.forEach(i => frontIndices.add(i));
            const combinedEdgeTypes = { ...edgeTypes };
            secondaryIndices.forEach(idx => {
                if (!frontIndices.has(idx) && !combinedEdgeTypes[idx]) combinedEdgeTypes[idx] = 'side';
            });
            const hasExplicitBack = Object.values(combinedEdgeTypes).includes('back');
            const autoBackIndices = new Set();
            if (!hasExplicitBack && workingPoints.length > 2 && frontIndices.size > 0) {
                let frontNormal = { x: 0, y: 0 };
                let count = 0;
                workingPoints.forEach((p, i) => {
                    const orig = workingEdgeIndices[i];
                    if (frontIndices.has(orig)) {
                        const p2 = workingPoints[(i + 1) % workingPoints.length];
                        const n = getSegmentNormal(p, p2, centroid);
                        frontNormal.x += n.x; frontNormal.y += n.y; count++;
                    }
                });
                if (count > 0) {
                    const len = Math.sqrt(frontNormal.x*frontNormal.x + frontNormal.y*frontNormal.y);
                    if (len > 0) {
                        frontNormal.x /= len; frontNormal.y /= len;
                        workingPoints.forEach((p, i) => {
                            const p2 = workingPoints[(i + 1) % workingPoints.length];
                            const n = getSegmentNormal(p, p2, centroid);
                            const dot = n.x * frontNormal.x + n.y * frontNormal.y;
                            if (dot < -0.5) autoBackIndices.add(workingEdgeIndices[i]);
                        });
                    }
                }
            }
            const buildRingPath = (outer, inner) => {
                if (!outer || !inner || outer.length < 2 || inner.length < 2) return null;
                let dPath = "";
                outer.forEach((p, i) => {
                    const x = p.x * scale + offX;
                    const y = p.y * scale + offY;
                    if (i === 0) dPath += `M ${x} ${y}`; else dPath += ` L ${x} ${y}`;
                });
                const rev = [...inner].reverse();
                rev.forEach((p, i) => {
                    const x = p.x * scale + offX;
                    const y = p.y * scale + offY;
                    if (i === 0) dPath += ` M ${x} ${y}`; else dPath += ` L ${x} ${y}`;
                });
                dPath += " Z";
                return dPath;
            };
            const groupsFrontOuter = [];
            const groupsFrontInner = [];
            const groupsBackOuter = [];
            const groupsBackInner = [];
            let curFrontOuter = []; let curFrontInner = [];
            let curBackOuter = []; let curBackInner = [];
            const getPrimaryRoadInfo = () => {
                let road = inputs.roads.find(r => r.type === 'primary');
                if (!road) return { widthM: 6 };
                return { widthM: parseFloat(road.width) };
            };
            const { widthM: primRoadW_M } = getPrimaryRoadInfo();
            const fD = parseFloat(inputs.frontYardDepth || 0);
            const minBYRatio = parseFloat(inputs.minBackyardDepthRatio || 0);
            const vizHeight = 30;
            for (let i = 0; i < workingPoints.length; i++) {
                const p1 = workingPoints[i];
                const p2 = workingPoints[(i + 1) % workingPoints.length];
                const originalIdx = workingEdgeIndices[i];
                const n = getSegmentNormal(p1, p2, centroid);
                if (frontIndices.has(originalIdx)) {
                    const p1Out = { x: p1.x - n.x * primRoadW_M, y: p1.y - n.y * primRoadW_M };
                    const p2Out = { x: p2.x - n.x * primRoadW_M, y: p2.y - n.y * primRoadW_M };
                    const p1In = { x: p1.x + n.x * fD, y: p1.y + n.y * fD };
                    const p2In = { x: p2.x + n.x * fD, y: p2.y + n.y * fD };
                    if (curFrontOuter.length === 0) {
                        curFrontOuter.push(p1Out);
                        curFrontInner.push(p1In);
                    }
                    curFrontOuter.push(p2Out);
                    curFrontInner.push(p2In);
                } else {
                    if (curFrontOuter.length > 0) { groupsFrontOuter.push(curFrontOuter); groupsFrontInner.push(curFrontInner); curFrontOuter = []; curFrontInner = []; }
                }
                const isBack = combinedEdgeTypes[originalIdx] === 'back' || autoBackIndices.has(originalIdx);
                if (minBYRatio > 0 && isBack) {
                    const reqDist = vizHeight / minBYRatio;
                    const p1Out = { x: p1.x, y: p1.y };
                    const p2Out = { x: p2.x, y: p2.y };
                    const p1In = { x: p1.x + n.x * reqDist, y: p1.y + n.y * reqDist };
                    const p2In = { x: p2.x + n.x * reqDist, y: p2.y + n.y * reqDist };
                    if (curBackOuter.length === 0) {
                        curBackOuter.push(p1Out);
                        curBackInner.push(p1In);
                    }
                    curBackOuter.push(p2Out);
                    curBackInner.push(p2In);
                } else {
                    if (curBackOuter.length > 0) { groupsBackOuter.push(curBackOuter); groupsBackInner.push(curBackInner); curBackOuter = []; curBackInner = []; }
                }
            }
            if (curFrontOuter.length > 0) { groupsFrontOuter.push(curFrontOuter); groupsFrontInner.push(curFrontInner); }
            if (curBackOuter.length > 0) { groupsBackOuter.push(curBackOuter); groupsBackInner.push(curBackInner); }
            const heightColor = isDarkMode ? "rgba(244,63,94,0.20)" : "rgba(244,63,94,0.18)";
            const backColor = isDarkMode ? "rgba(34,197,94,0.20)" : "rgba(34,197,94,0.18)";
            let frontPathD = "";
            let backPathD = "";
            if (showCheckLines && showHeightRatio) {
                for (let gi = 0; gi < groupsFrontOuter.length; gi++) {
                    const dEl = buildRingPath(groupsFrontOuter[gi], groupsFrontInner[gi]);
                    if (dEl) frontPathD += `${dEl} `;
                }
            }
            if (showCheckLines && showBackyard) {
                for (let gi = 0; gi < groupsBackOuter.length; gi++) {
                    const dEl = buildRingPath(groupsBackOuter[gi], groupsBackInner[gi]);
                    if (dEl) backPathD += `${dEl} `;
                }
            }
            if (frontPathD) paths.push(<path d={frontPathD.trim()} fill={heightColor} stroke="none" fillRule="evenodd" />);
            if (backPathD) paths.push(<path d={backPathD.trim()} fill={backColor} stroke="none" fillRule="evenodd" />);
            if (paths.length === 0) return null;
            return (
                <div style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', pointerEvents: 'none', zIndex: 9 }}>
                    <svg width="100%" height="100%" viewBox={`0 0 ${w} ${d}`} style={{overflow: 'visible'}}>
                        {paths}
                    </svg>
                </div>
            );
        };

        const calculateCheckLines = () => {
             const lines = [];
             const offX = w / 2;
             const offY = d / 2;

             // Helper to find primary road info
            const getPrimaryRoadInfo = () => {
                let road = inputs.roads.find(r => r.type === 'primary');
                if (!road) return { widthPx: 6 * scale, widthM: 6, isDefault: true, roadObj: null };
                return { widthPx: parseFloat(road.width) * scale, widthM: parseFloat(road.width), isDefault: false, roadObj: road };
            };
             
             const { widthPx: primRoadW_Px, widthM: primRoadW_M, roadObj: primRoad } = getPrimaryRoadInfo();

             // Use discretized points to handle curves correctly
             // We need to map edges back to original indices to check frontage/back types
            let workingPoints = [];
            let workingEdgeIndices = [];
            
            if (normalizedData.points && normalizedData.points.length > 2) {
                const discretized = discretizePolygon(normalizedData.points, normalizedData.curves, 20);
                workingPoints = discretized.points;
                workingEdgeIndices = discretized.edgeMap;
            } else {
                 const hw = baseWidthM / 2; const hd = baseDepthM / 2;
                 workingPoints = [{x: -hw, y: -hd}, {x: hw, y: -hd}, {x: hw, y: hd}, {x: -hw, y: hd}];
                 workingEdgeIndices = [0, 1, 2, 3];
            }

             if (!workingPoints || workingPoints.length < 3) return [];
             
             // --- Consistent Edge Logic Start ---
             const primaryIndices = new Set();
             const secondaryIndices = new Set();
             
             if (inputs.roads) {
                 inputs.roads.forEach(r => {
                     const indices = new Set();
                     if (r.edgeIndices) r.edgeIndices.forEach(i => indices.add(i));
                     if (r.edgeIndex !== undefined && r.edgeIndex !== "") indices.add(parseInt(r.edgeIndex));
                     
                     if (r.type === 'primary') {
                         indices.forEach(i => primaryIndices.add(i));
                     } else {
                         indices.forEach(i => secondaryIndices.add(i));
                     }
                 });
             }
 
             const frontIndices = new Set();
             if (frontageIndices && frontageIndices.size > 0) {
                  frontageIndices.forEach(i => frontIndices.add(i));
             } else {
                  primaryIndices.forEach(i => frontIndices.add(i));
                  if (primaryIndices.size === 0 && secondaryIndices.size > 0) {
                       secondaryIndices.forEach(i => frontIndices.add(i));
                  }
             }

             // Prepare combined edge types (Secondary -> Side)
             const combinedEdgeTypes = { ...edgeTypes };
             secondaryIndices.forEach(idx => {
                 if (!frontIndices.has(idx) && !combinedEdgeTypes[idx]) {
                     combinedEdgeTypes[idx] = 'side';
                 }
             });
             // --- Consistent Edge Logic End ---

             const centroid = getPolygonCentroid(workingPoints);

             // Iterate through discretized segments
             // Group segments by Original Index to consolidate labels
             const linesByEdge = {};
             
             // --- Auto-Detect Back Logic ---
             // If no edge is explicitly marked as 'back', find edges roughly opposite to the main road
             const hasExplicitBack = Object.values(combinedEdgeTypes).includes('back');
             const autoBackIndices = new Set();
             
             if (!hasExplicitBack && primRoad) {
                 let frontNormal = { x: 0, y: 0 };
                 let count = 0;
                 
                 workingPoints.forEach((p, i) => {
                     const orig = workingEdgeIndices[i];
                     if (frontIndices.has(orig)) {
                         const p2 = workingPoints[(i + 1) % workingPoints.length];
                         const n = getSegmentNormal(p, p2, centroid);
                         frontNormal.x += n.x;
                         frontNormal.y += n.y;
                         count++;
                     }
                 });
                 
                 if (count > 0) {
                     frontNormal.x /= count; frontNormal.y /= count;
                     const len = Math.sqrt(frontNormal.x*frontNormal.x + frontNormal.y*frontNormal.y);
                     frontNormal.x /= len; frontNormal.y /= len;
                     
                     workingPoints.forEach((p, i) => {
                         const p2 = workingPoints[(i + 1) % workingPoints.length];
                         const n = getSegmentNormal(p, p2, centroid);
                         const dot = n.x * frontNormal.x + n.y * frontNormal.y;
                         if (dot < -0.5) { // Roughly opposite (> 120 degrees)
                             autoBackIndices.add(workingEdgeIndices[i]);
                         }
                     });
                 }
             }
             // -----------------------------

             for (let i = 0; i < workingPoints.length; i++) {
                 const p1 = workingPoints[i];
                 const p2 = workingPoints[(i + 1) % workingPoints.length];
                 const originalIdx = workingEdgeIndices[i];
                 
                 const normal = getSegmentNormal(p1, p2, centroid); 
                 const mid = { x: (p1.x + p2.x)/2, y: (p1.y + p2.y)/2 };
                 
                 if (!linesByEdge[originalIdx]) linesByEdge[originalIdx] = [];

                 // 1. Height Ratio & WeiLao (Frontage)
                 if (frontIndices.has(originalIdx)) {
                     const fD = parseFloat(inputs.frontYardDepth || 0); 
                     
                     const p_out_M = { x: mid.x - normal.x * primRoadW_M, y: mid.y - normal.y * primRoadW_M };
                     const p_center_M = { x: mid.x - normal.x * (primRoadW_M / 2), y: mid.y - normal.y * (primRoadW_M / 2) };
                     const p_setback_M = { x: mid.x + normal.x * fD, y: mid.y + normal.y * fD };

                    if (showCheckLines && showHeightRatio) {
                         const hRatioH = 3.6 * (primRoadW_M + fD) * scale; 
                         linesByEdge[originalIdx].push({ 
                             id: `height-${i}`, 
                             type: 'height',
                             start: { x: offX + p_out_M.x * scale, y: offY + p_out_M.y * scale, z: 0 }, 
                             end: { x: offX + p_setback_M.x * scale, y: offY + p_setback_M.y * scale, z: hRatioH },
                             label: "高度比", 
                             color: "#f43f5e",
                             dashed: false,
                             thick: true
                         });
                     }
                     
                    if (showCheckLines && showWeiLao) {
                         const wlH = 5 * (0.5 * primRoadW_M + fD) * scale;
                         linesByEdge[originalIdx].push({ 
                             id: `weilao-${i}`, 
                             type: 'weilao',
                             start: { x: offX + p_center_M.x * scale, y: offY + p_center_M.y * scale, z: 0 },
                             end: { x: offX + p_setback_M.x * scale, y: offY + p_setback_M.y * scale, z: wlH },
                             label: "危老檢討", 
                             color: isDarkMode ? "#60a5fa" : "#3b82f6", 
                             dashed: true,
                             thick: true
                         });
                     }
                 }

                 // 2. Backyard Depth Ratio (Back)
                 const minBYRatio = parseFloat(inputs.minBackyardDepthRatio || 0);
                 const isBack = combinedEdgeTypes[originalIdx] === 'back' || autoBackIndices.has(originalIdx);

                if (minBYRatio > 0 && showCheckLines && showBackyard && isBack) {
                     const bD = parseFloat(inputs.backYardDepth || 0); 
                     
                     const startM = mid;
                     const vizHeight = 30; 
                     const reqDist = vizHeight / minBYRatio;
                     
                     const p_envelope_M = { x: mid.x + normal.x * reqDist, y: mid.y + normal.y * reqDist };
                     
                     linesByEdge[originalIdx].push({ 
                        id: `backyard-${i}`, 
                        type: 'backyard',
                        start: { x: offX + startM.x * scale, y: offY + startM.y * scale, z: 0 }, 
                        end: { x: offX + p_envelope_M.x * scale, y: offY + p_envelope_M.y * scale, z: vizHeight * scale }, 
                        label: `後院檢討 (1:${minBYRatio})`, 
                        color: "#22c55e", // Fixed Green
                        dashed: true,     // Fixed Dashed
                        thick: true       // Fixed Thick
                    });
                 }
             }
             
             Object.values(linesByEdge).forEach(groupLines => {
                 const byType = {};
                 groupLines.forEach(l => {
                     if (!byType[l.type]) byType[l.type] = [];
                     byType[l.type].push(l);
                 });
                 
                 Object.values(byType).forEach(subGroup => {
                     const midIdx = Math.floor(subGroup.length / 2);
                     subGroup.forEach((l, idx) => {
                         if (idx !== midIdx) l.label = null;
                         lines.push(l);
                     });
                 });
             });
             
             return lines;
        };



        const landscapeStyle = isLandscapeMode ? { position: 'fixed', top: 0, left: '100vw', width: '100dvh', height: '100vw', transform: 'rotate(90deg)', transformOrigin: 'top left', zIndex: 9999, margin: 0, borderRadius: 0, touchAction: 'none', backgroundColor: isDarkMode ? '#0f172a' : '#fafaf9' } : { backgroundImage: colors.grid, backgroundSize: '40px 40px', touchAction: 'none' };
        const controlBarClass = isLandscapeMode ? "absolute top-6 right-6 z-30 flex flex-col items-end gap-2" : "absolute top-4 right-4 z-30 flex flex-col items-end gap-2 sm:flex-row sm:items-center";
        const viewTransition = isDragging ? 'none' : 'transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1)';
        
        return (
          <div className="bg-[#fdfbf7] rounded-xl p-0 mb-6 shadow-md overflow-hidden relative min-h-[350px] md:min-h-[600px] flex flex-col md:flex-row border border-stone-300 font-['GenYoGothic',_sans-serif] md:sticky md:top-0 md:z-40">
             <div className="flex flex-col md:flex-row w-full h-full relative">
                
                <div ref={viewportRef} className={`flex-1 relative flex flex-col items-center justify-center perspective-1000 min-h-[350px] md:min-h-[600px] overflow-hidden transition-colors duration-500 touch-none ${isDragging ? 'cursor-grabbing' : 'cursor-grab'} ${isDarkMode ? 'bg-slate-900' : 'bg-[#fafaf9]'}`} style={{ ...landscapeStyle, ...(isLandscapeMode ? {} : { backgroundImage: colors.grid, backgroundSize: '40px 40px' }) }} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleMouseUp} onClick={handleBgClick}>
                  {/* ... same controls ... */}
                  <div className="absolute top-4 left-4 z-40 flex flex-col gap-2">
                      <div className="flex bg-white/90 backdrop-blur rounded-lg border border-stone-200 shadow-sm p-1 gap-1">
                          <button onClick={() => setViewMode('3d')} className={`flex items-center gap-1 px-3 py-1.5 rounded text-xs font-bold transition-colors ${viewMode === '3d' ? 'bg-stone-800 text-white' : 'text-stone-500 hover:bg-stone-100'}`}><Box size={14} /> 3D 模擬</button>
                          <button onClick={() => setViewMode('2d')} className={`flex items-center gap-1 px-3 py-1.5 rounded text-xs font-bold transition-colors ${viewMode === '2d' ? 'bg-stone-800 text-white' : 'text-stone-500 hover:bg-stone-100'}`}><LayoutTemplate size={14} /> 平面分析</button>
                      </div>
                  </div>
                  <div className={controlBarClass}>
                     <div className={`${isDarkMode ? 'bg-slate-800/80 border-slate-700' : 'bg-white/90 border-stone-200'} p-1.5 rounded-full border shadow-lg flex flex-row items-center gap-2 backdrop-blur-md transition-colors duration-300`}>
                        <button onClick={() => setIsDarkMode(prev => !prev)} className={`p-2 rounded-full transition-all ${isDarkMode ? 'text-amber-300 hover:bg-slate-600' : 'text-slate-600 hover:bg-stone-100'}`} title={isDarkMode ? "切換為亮色模式" : "切換為夜間模式"}>{isDarkMode ? <Sun size={18} /> : <Moon size={18} />}</button>
                        <button onClick={toggleFullscreen} className={`p-2 rounded-full transition-all ${isDarkMode ? 'text-indigo-400 hover:bg-slate-600' : 'text-indigo-600 hover:bg-stone-100'}`} title={isSummaryOpen ? "全螢幕模式 (隱藏面板)" : "顯示詳細面板"}>{isSummaryOpen ? <Maximize2 size={18} /> : <PanelRightOpen size={18} />}</button>
                     </div>
                  </div>
                  {isConstraintMode && viewMode === '3d' && (<div className="absolute bottom-24 right-6 z-20 pointer-events-none"><div className="bg-emerald-600/90 text-white px-3 py-1.5 rounded-full shadow-lg text-sm font-bold flex items-center gap-2 backdrop-blur border border-emerald-400 animate-pulse"><CheckCircle2 size={16} fill="white" className="text-emerald-700" />鎖定編輯 (法規檢討中)</div></div>)}
                  {viewMode === '2d' ? (
                      <PlanAnalysis2D layers={floorLayers} baseWidthM={baseWidthM} baseDepthM={baseDepthM} onSelectFloor={(id) => { if (id === 'base' || id === 'excavation') { setSelectedFloor({ id }); } else if (id) { const l = floorLayers.find(f => f.id === id); if (l) handleLayerClick({ stopPropagation: () => {} }, l); } }} selectedFloorId={selectedFloor?.id} isDarkMode={isDarkMode} onUpdateSetting={updateFloorSetting} floorSettings={floorSettings} inputs={inputs} scale3d={scale} basements={basements} onToggleBasement={toggleBasement} activeBasementArea={activeBasementArea} totalAllowedArea={res.totalCFA} showCheckLines={showCheckLines} volumeLimit={volumeLimit} parkingOn1F={parkingOn1F} onToggleParkingLocation={toggleParkingLocation} onClose={() => { if (selectedFloor) { setSelectedFloor(null); } else { setViewMode('3d'); } }} basePoints={basePoints} baseCurves={baseCurves} excavationPoints={excavationPoints} excavationCurves={excavationCurves} onAddRoad={onUpdateRoads} frontageIndices={frontageIndices} onUpdateFrontageIndices={setFrontageIndices} onAddFloor={handleAddFloor} onRemoveFloor={handleRemoveFloor} edgeTypes={edgeTypes} onUpdateEdgeTypes={updateEdgeTypes} view={view2D} onUpdateView={setView2D} onUpdateInputs={onUpdateInputs} onUpdateRoads={onUpdateRoads} onEditEnd={handleBaseEditEnd} unitSettings={unitSettings} onUpdateUnitSettings={setUnitSettings} onApplyAll={handleApplyAllFloors} floorsAboveValue={floorsAboveValue} onUpdateFloorsAbove={handleSetFloorsAbove} />
                  ) : (
                      <>
                          {!isConstraintMode && <FloorInfoCard data={selectedFloor} isDarkMode={isDarkMode} onReset={resetFloor} isConstraintMode={isConstraintMode} inputs={inputs}/>}
                          
                          <div ref={compassRef} onPointerDown={handleCompassPointerDown} onPointerMove={handleCompassPointerMove} onPointerUp={handleCompassPointerUp} onPointerLeave={handleCompassPointerUp} className={`absolute bottom-8 right-6 z-20 pointer-events-auto transition-opacity duration-300 ${isDragging ? 'opacity-40' : 'opacity-100'}`}>
                              <ArtisticCompass className="w-16 h-16" rotation={rotationZ - (inputs.northAngle || 0)} isDarkMode={isDarkMode} />
                          </div>

                          {totalAreaViolation && <div className="absolute top-8 left-1/2 transform -translate-x-1/2 z-20 pointer-events-none animate-pulse"><div className="bg-red-500/90 text-white px-3 py-1.5 rounded-full shadow-lg text-sm font-bold flex items-center gap-2 backdrop-blur"><AlertTriangle size={16} fill="white" className="text-red-500" />總容積超限! (量體 {formatNum(toPing(massingLayers.currentTotalUsed))} &gt; 法定 {formatNum(toPing(volumeLimit))}坪)</div></div>}
                          {isConstraintMode && unusedArea > 0.1 && (
                              <div className="absolute top-20 left-1/2 transform -translate-x-1/2 z-20 pointer-events-none">
                                  <div className="bg-emerald-600/90 text-white px-3 py-1.5 rounded-full shadow-lg text-sm font-bold flex items-center gap-2 backdrop-blur border border-emerald-400">
                                      <CheckCircle2 size={16} fill="white" className="text-emerald-700" />
                                      剩餘容積: {formatNum(toPing(unusedArea))} 坪 (可再增加樓層)
                                  </div>
                              </div>
                          )}
                          <div className="relative w-full h-full flex items-center justify-center pointer-events-none" style={{ perspective: '2500px', transformStyle: 'preserve-3d' }}>
                            <div style={{ transform: `scale(${zoom}) rotateX(${viewAngleX}deg) rotateZ(${rotationZ}deg)`, transformStyle: 'preserve-3d', transition: viewTransition }}>
                               <div style={{ position: 'relative', width: `${w}px`, height: `${d}px`, backgroundColor: 'transparent', transformStyle: 'preserve-3d', transition: 'background-color 0.5s', pointerEvents: 'auto' }} onMouseDown={handleMouseDown} onTouchStart={handleTouchStart}>
                                  {/* Base Layer with Stroke */}
                                  <div className="absolute inset-0" style={{ width: '100%', height: '100%' }}>
                                     {basePoints && basePoints.length > 0 && false}
                                    {basePoints ? (
                                        <svg width="100%" height="100%" viewBox={`0 0 ${w} ${d}`} style={{overflow: 'visible'}}>
                                            <path 
                                                d={generateSvgPath(normalizedData.points, normalizedData.curves, scale, w/2, d/2)} 
                                                 fill={isDarkMode ? 'rgba(30, 41, 59, 0.8)' : 'rgba(255, 255, 255, 0.9)'} 
                                                stroke={(basePoints && basePoints.length > 0) ? 'none' : (isDarkMode ? '#475569' : '#a8a29e')} 
                                                strokeWidth={(basePoints && basePoints.length > 0) ? 0 : "2"}
                                                 style={{ filter: isDarkMode ? 'drop-shadow(0 0 10px rgba(0,0,0,0.5))' : 'drop-shadow(0 0 10px rgba(0,0,0,0.1))' }}
                                             />
                                         </svg>
                                     ) : (
                                         <div className={`w-full h-full border-2 shadow-2xl transition-colors duration-500 ${isDarkMode ? 'bg-slate-800/80 border-slate-600' : 'bg-white/90 border-stone-300'}`} style={{ boxShadow: isDarkMode ? '0 0 20px rgba(0,0,0,0.5)' : 'none' }}></div>
                                     )}
                                  </div>
                                     {!basePoints && (
                                       <>
                                         <div
                                           style={{
                                             position: 'absolute',
                                             top: 0,
                                             left: 0,
                                             width: '100%',
                                             height: `${backPx}px`,
                                             background: isDarkMode
                                               ? 'repeating-linear-gradient(45deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.1) 10px, rgba(16, 185, 129, 0.2) 10px, rgba(16, 185, 129, 0.2) 20px)'
                                               : 'repeating-linear-gradient(45deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.1) 10px, rgba(16, 185, 129, 0.2) 10px, rgba(16, 185, 129, 0.2) 20px)',
                                             borderBottom: '2px dashed #10b981',
                                             pointerEvents: 'none'
                                           }}
                                         >
                                           <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-[10px] font-bold text-emerald-600/80 tracking-widest whitespace-nowrap bg-white/50 px-1 rounded backdrop-blur-sm">
                                             後院
                                           </div>
                                         </div>
                                         <div
                                           style={{
                                             position: 'absolute',
                                             bottom: 0,
                                             left: 0,
                                             width: '100%',
                                             height: `${Math.max(frontPx, (arcadeM * scale) || 0)}px`,
                                             background: isDarkMode
                                               ? 'repeating-linear-gradient(45deg, rgba(244, 63, 94, 0.1), rgba(244, 63, 94, 0.1) 10px, rgba(244, 63, 94, 0.2) 10px, rgba(244, 63, 94, 0.2) 20px)'
                                               : 'repeating-linear-gradient(45deg, rgba(244, 63, 94, 0.1), rgba(244, 63, 94, 0.1) 10px, rgba(244, 63, 94, 0.2) 10px, rgba(244, 63, 94, 0.2) 20px)',
                                             borderTop: '2px dashed #f43f5e',
                                             pointerEvents: 'none'
                                           }}
                                         >
                                           <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-[10px] font-bold text-rose-600/80 tracking-widest whitespace-nowrap bg-white/50 px-1 rounded backdrop-blur-sm">
                                             {arcadeM > 0 ? '騎樓' : '前院'}
                                           </div>
                                         </div>
                                         {sidePx > 0 && (
                                           <div
                                             style={{
                                               position: 'absolute',
                                               top: 0,
                                               left: sideDir === 'left' ? 0 : 'auto',
                                               right: sideDir === 'right' ? 0 : 'auto',
                                               width: `${sidePx}px`,
                                               height: '100%',
                                               background: isDarkMode
                                                 ? 'repeating-linear-gradient(45deg, rgba(59, 130, 246, 0.1), rgba(59, 130, 246, 0.1) 10px, rgba(59, 130, 246, 0.2) 10px, rgba(59, 130, 246, 0.2) 20px)'
                                                 : 'repeating-linear-gradient(45deg, rgba(59, 130, 246, 0.1), rgba(59, 130, 246, 0.1) 10px, rgba(59, 130, 246, 0.2) 10px, rgba(59, 130, 246, 0.2) 20px)',
                                               borderLeft: sideDir === 'left' ? '2px dashed #3b82f6' : 'none',
                                               borderRight: sideDir === 'right' ? '2px dashed #3b82f6' : 'none',
                                               pointerEvents: 'none'
                                             }}
                                           >
                                             <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-[10px] font-bold text-sky-600/80 tracking-widest whitespace-nowrap bg-white/50 px-1 rounded backdrop-blur-sm">
                                               側院
                                             </div>
                                           </div>
                                         )}
                                       </>
                                     )}
                                  </div>
                                  {renderRoads()} {renderReviewSurfaces()} {renderPolygonSetbacks()}
                                  {calculateCheckLines().map(line => (
                                      <CheckLine key={line.id} {...line} baseRotation={0} viewAngleX={viewAngleX} rotationZ={rotationZ} visible={true} dashed={line.dashed} thick={line.thick} isDarkMode={isDarkMode} labelPosRatio={0.2} />
                                  ))}
                                  {basements.map((b, i) => { if (!b.active) return null; let pts = excavationPoints; let crvs = excavationCurves; let wPx = w * 0.8; let dPx = d * 0.8; if (!pts && basePoints) { const scaleRate = Math.sqrt(inputs.excavationRatio / 100); const { points: newPts, curves: newCurves } = scalePolygon(basePoints, baseCurves, scaleRate); pts = normalizePoints(newPts); crvs = newCurves; } else if (pts) { pts = normalizePoints(pts); } return ( <BuildingLayer key={`bsmt-${b.id}-${inputs.baseVersion || 0}`} width={wPx} depth={dPx} height={3.6} x={0} y={0} z={-(i+1)*3.6*scale} rotation={0} scale={scale} points={pts} curves={crvs} color={isDarkMode ? "#334155" : "#cbd5e1"} strokeColor={isDarkMode ? "#475569" : "#94a3b8"} showFrame={false} opacity={0.9} visible={true} isSlabMode={false} isDarkMode={isDarkMode} isViolation={false} onClick={(e) => handleLayerClick(e, {id: b.id, z: -(i+1)*3.6*scale, height: 3.6})} /> ); })}
                                  {/* FIX: Do NOT use normalizePoints here. The layers are already calculated in the site coordinate system. */}
                                  {floorLayers.map((layer, i) => { const pts = layer.points; return (<BuildingLayer key={`fl-${i}-${inputs.baseVersion || 0}`} width={layer.widthPx} depth={layer.depthPx} height={layer.height} x={layer.shiftX} y={layer.shiftYPx} z={layer.z} rotation={layer.rotation} pivot={selectedFloor?.id === layer.id ? selectedFloor.pivot : floorSettings[layer.id]?.pivot} scale={scale} points={pts} curves={layer.curves} color={colors.floor} strokeColor={colors.stroke} showFrame={true} opacity={1} visible={true} isSlabMode={!showCheckLines} animate={animate} delay={i * 50} isDarkMode={isDarkMode} isSelected={selectedFloor && selectedFloor.id === layer.id} isViolation={layer.isViolation} onClick={(e) => handleLayerClick(e, layer)} />) })}
                               </div>
                           </div>
                       </>
                   )}
                </div>
                {/* Right Panel Summary (Same as before) */}
                <div className={`transition-all duration-500 ease-in-out border-l border-stone-200 bg-[#f8fafc] flex flex-col num-font z-10 relative overflow-hidden ${isSummaryOpen ? 'w-full md:w-96 opacity-100' : 'w-0 opacity-0 border-none'}`}>
                   <div className="flex-1 overflow-y-auto p-6">
                      <div className="mb-6 border-b border-stone-200 pb-4 sticky top-0 bg-white/95 backdrop-blur z-40 -mt-6 -mx-6 px-6 pt-6 shadow-sm">
                         <div className="flex items-center justify-between"><h3 className="text-stone-400 text-sm font-bold uppercase tracking-widest flex items-center gap-2"><Building2 size={16} /> Project Summary</h3><div className="w-6"></div> </div>
                         <div className="space-y-3 mt-4">
                            <SummaryRow label="專案名稱" value={inputs.projectName} />
                            <SummaryRow label="工程預算" value={`${formatNum(res.estimatedBudget)} 萬`} highlight />
                            <SummaryRow label="建築物高度" value={`${formatNum(massingLayers.totalHeight)} m`} />
                            <SummaryRow label="模擬樓層" value={`${visualFloorsAbove} 層`} subtext="(含退縮)" />
                            {showCheckLines && showHeightRatio && <SummaryRow label="高度比" value={formatNum(res.heightRatio, 2)} isAlert={res.isHighRise} alertText={res.isSuperHighRise ? "超高" : "高層"} />}
                            <div className="pt-2 border-t border-stone-200 mt-2">
                               <div className="flex justify-between items-center mb-2">
                                   <span className="text-stone-500 text-sm font-medium">檢討線顯示</span>
                                   <div className="flex items-center gap-1">
                                       <button onClick={() => setShowCheckLines(!showCheckLines)} className="px-3 py-1 rounded-full border shadow-sm flex items-center gap-2 text-xs font-bold transition-colors bg-white border-stone-200 text-stone-500">{showCheckLines ? <ToggleRight size={16} /> : <ToggleLeft size={16} />}{showCheckLines ? "開啟" : "關閉"}</button>
                                       {showCheckLines && (
                                           <>
                                               <button onClick={() => setShowHeightRatio(!showHeightRatio)} className={`px-3 py-1 rounded-full border shadow-sm flex items-center gap-2 text-xs font-bold transition-colors ${showHeightRatio ? 'bg-rose-50 border-rose-200 text-rose-600' : 'bg-white border-stone-200 text-stone-400'}`} title="高度比檢討線">
                                                   {showHeightRatio ? <CheckSquare size={14}/> : <Square size={14}/>} 高度比
                                               </button>
                                               <button onClick={() => setShowWeiLao(!showWeiLao)} className={`px-3 py-1 rounded-full border shadow-sm flex items-center gap-2 text-xs font-bold transition-colors ${showWeiLao ? 'bg-purple-50 border-purple-200 text-purple-600' : 'bg-white border-stone-200 text-stone-400'}`} title="危老檢討線 (1:5)">
                                                   {showWeiLao ? <CheckSquare size={14}/> : <Square size={14}/>} 危老
                                               </button>
                                               <button onClick={() => setShowBackyard(!showBackyard)} className={`px-3 py-1 rounded-full border shadow-sm flex items-center gap-2 text-xs font-bold transition-colors ${showBackyard ? 'bg-emerald-50 border-emerald-200 text-emerald-600' : 'bg-white border-stone-200 text-stone-400'}`} title="後院檢討線">
                                                   {showBackyard ? <CheckSquare size={14}/> : <Square size={14}/>} 後院
                                               </button>
                                           </>
                                       )}
                                   </div>
                               </div>
                            </div>
                         </div>
                      </div>
                      <div className="grid grid-cols-2 gap-3">
                         <div className="bg-white p-3 rounded-lg border border-stone-200"><div className="text-stone-400 text-[10px] uppercase mb-1">總樓地板 (坪)</div><div className={`font-bold text-lg num-font ${totalAreaViolation ? 'text-red-500' : 'text-stone-700'}`}>{formatNum(toPing(massingLayers.currentTotalUsed))} <span className="text-xs font-sans font-normal text-stone-400">/ {formatNum(toPing(volumeLimit))} Max</span></div></div>
                         <div className="bg-white p-3 rounded-lg border border-stone-200"><div className="text-stone-400 text-[10px] uppercase mb-1">預估坪效</div><div className="font-bold text-lg num-font text-emerald-600">{formatNum(res.efficiency)} <span className="text-xs font-sans font-normal text-stone-400">倍</span></div></div>
                         <div className="bg-white p-3 rounded-lg border border-stone-200"><div className="text-stone-400 text-[10px] uppercase mb-1">樓層</div><div className="font-bold text-lg num-font text-indigo-600">{visualFloorsAbove}F <span className="text-xs font-sans font-normal text-stone-400">/ B{inputs.floorsBelow}</span></div></div>
                         <div className="bg-white p-3 rounded-lg border border-stone-200"><div className="text-stone-400 text-[10px] uppercase mb-1">停車</div><div className="font-bold text-lg num-font text-stone-700">{res.possibleParking} <span className="text-xs font-sans font-normal text-stone-400">部</span></div></div>
                      </div>
                      {unusedArea > 0.1 && (
                          <div className="mt-3 bg-emerald-50 p-3 rounded-lg border border-emerald-100">
                              <div className="text-emerald-600 text-[10px] uppercase mb-1">未用容積 (坪)</div>
                              <div className="font-bold text-lg num-font text-emerald-700">{formatNum(toPing(unusedArea))}</div>
                          </div>
                      )}
                   </div>
                   <div className="p-6 bg-white border-t border-stone-200 mt-auto">
                      <div className="text-stone-400 text-sm font-bold uppercase mb-4 flex items-center gap-2"><Car size={14} /> 停車空間預估</div>
                      <div className="flex justify-between items-center">
                         <div className="flex items-center gap-3"><div className="p-2 bg-stone-100 rounded text-stone-600"><Car size={18} /></div><div><div className="text-xs text-stone-400">汽車位</div><div className="font-bold text-stone-800 text-lg num-font">{res.possibleParking}</div></div></div>
                         <div className="h-8 w-[1px] bg-stone-200"></div>
                         <div className="flex items-center gap-3"><div className="p-2 bg-stone-100 rounded text-stone-600"><Bike size={18} /></div><div><div className="text-xs text-stone-400">機車位</div><div className="font-bold text-stone-800 text-lg num-font">{Math.floor(res.possibleParking * 1.2)}</div></div></div>
                      </div>
                   </div>
                </div>
             </div>
          </div>
        );
      };

      const CheckLine = React.memo(({ start, end, color, label, rotationZ, baseRotation, viewAngleX, visible, dashed, thick, labelPosRatio = 0.5, isDarkMode }) => {
        const dx = end.x - start.x; const dy = end.y - start.y; const dz = end.z - start.z; const length = Math.sqrt(dx * dx + dy * dy + dz * dz); const lx = start.x + dx * labelPosRatio; const ly = start.y + dy * labelPosRatio; const lz = start.z + dz * labelPosRatio; const angleZ = Math.atan2(dy, dx) * (180 / Math.PI); const angleY = -Math.atan2(dz, Math.sqrt(dx * dx + dy * dy)) * (180 / Math.PI); const isSteep = viewAngleX > 75; const thickness = thick ? (isSteep ? "6px" : "3px") : (isSteep ? "4px" : "2px");
        return ( <> <div className="absolute origin-left" style={{ left: 0, top: 0, width: `${length}px`, height: thickness, backgroundColor: dashed ? 'transparent' : color, borderTop: dashed ? `2px dashed ${color}` : 'none', transform: `translate3d(${start.x}px, ${start.y}px, ${start.z}px) rotateZ(${angleZ}deg) rotateY(${angleY}deg)`, opacity: visible ? (isSteep ? 1 : 0.9) : 0, pointerEvents: 'none', boxShadow: isSteep ? `0 0 4px ${color}` : 'none', zIndex: 60 }}></div> {isSteep && (<div className="absolute origin-left" style={{ left: 0, top: 0, width: `${length}px`, height: thickness, backgroundColor: color, transform: `translate3d(${start.x}px, ${start.y}px, ${start.z}px) rotateZ(${angleZ}deg) rotateY(${angleY}deg) rotateX(90deg)`, opacity: visible ? 1 : 0, pointerEvents: 'none', zIndex: 60 }}></div>)} {visible && label && (<Si text={label} x={lx} y={ly} z={lz + 10} rotationZ={rotationZ} baseRotation={baseRotation} viewAngleX={viewAngleX} visible={visible} className={`text-[10px] px-2 py-0.5 rounded-full shadow-lg font-bold border ${isDarkMode ? 'bg-slate-900 border-slate-600 text-white' : 'bg-white/90 border-slate-200 text-slate-600'}`} />)} </> );
      });

      const Si = React.memo(({ text, x, y, z, rotationZ, baseRotation, viewAngleX, visible, className, lineConnector, isRoadLabel }) => (
        visible ? (<div className="absolute pointer-events-none" style={{ left: 0, top: 0, transform: `translate3d(${x}px, ${y}px, ${z}px) rotateZ(${isRoadLabel ? -(rotationZ + baseRotation) : -(rotationZ + baseRotation)}deg) rotateX(${-viewAngleX}deg)`, zIndex: 7000 }}><div className="flex items-center" style={{ transform: 'translate(-50%, -50%)' }}>{lineConnector && <div className="w-4 h-[1px] bg-stone-400"></div>}<div className={`whitespace-nowrap px-2 py-0.5 rounded shadow-sm text-sm backdrop-blur-sm num-font ${className}`}>{text}</div></div></div>) : null
      ));

      const CollapsibleSection = ({ title, icon, children, defaultOpen = true, className = "" }) => {
        const [isOpen, setIsOpen] = useState(defaultOpen);
        return ( <div className={`bg-white rounded-xl shadow-sm border border-stone-100 overflow-hidden ${className}`}><div className="flex items-center justify-between p-5 cursor-pointer hover:bg-stone-50 transition-colors border-b border-stone-100" onClick={() => setIsOpen(!isOpen)}><h3 className="font-bold text-stone-700 flex items-center gap-2">{icon} {title}</h3><div className="text-stone-400">{isOpen ? <ChevronUp size={20} /> : <ChevronDown size={20} />}</div></div><div className={`transition-all duration-300 ease-in-out overflow-hidden ${isOpen ? 'max-h-[1200px] opacity-100' : 'max-h-0 opacity-0'}`}><div className="p-5">{children}</div></div></div> );
      };

      const InputRow = ({ id, label, value, calculatedValue, formula, note, isEditMode, onOverride, highlight = false, subTotal = false, bold = false, paramKey, paramValue, onParamChange }) => {
        const isConflict = isEditMode && calculatedValue !== undefined && Math.abs(value - calculatedValue) > 0.01;
        const displayValue = formatNum(value);
        const displayPing = formatNum(toPing(value));
        return ( <tr className={`hover:bg-stone-50 ${subTotal ? 'bg-stone-50/80 italic text-stone-600' : ''}`}><td className={`p-4 pl-8 border-l-4 ${highlight ? 'border-emerald-400 font-bold text-emerald-700' : 'border-stone-300'} ${bold ? 'font-bold' : 'font-medium'}`}>{label}</td><td className={`p-4 text-right ${highlight ? 'font-bold text-emerald-700' : ''} ${bold ? 'font-bold' : ''}`}>{isEditMode ? (<div className="flex items-center justify-end gap-2 relative">{isConflict && <div className="absolute right-full mr-2 text-rose-500 animate-pulse" title="警告：數值與公式計算結果衝突"><AlertTriangle size={16} /></div>}<input type="number" value={value} onChange={(e) => onOverride(id, e.target.value)} className={`w-24 p-1 text-right border rounded outline-none focus:border-indigo-500 focus:ring-4 focus:ring-indigo-500/10 ${isConflict ? 'border-rose-300 bg-rose-50' : 'border-stone-300'} num-font`} /></div>) : (<span className="num-font">{displayValue}</span>)}</td><td className={`p-4 text-right text-stone-500 ${highlight ? 'font-bold text-emerald-700' : ''} ${bold ? 'font-bold' : ''} num-font`}>{displayPing}</td>{isEditMode && (<><td className="p-4 font-mono text-xs text-indigo-600/80 bg-indigo-50/10 border-l border-stone-100">{paramKey ? (<div className="flex items-center gap-2"><span className="text-stone-500">{paramKey === 'exemptRate' ? '免計率' : paramKey === 'stairRate' ? '梯廳率' : '陽台率'}:</span><input type="number" value={paramValue} onChange={(e) => onParamChange(paramKey, e.target.value)} className="w-16 p-1 border rounded text-center font-bold text-indigo-700 num-font" style={{ fontSize: '12px' }}/><span>%</span></div>) : formula}</td><td className="p-4 text-sm text-stone-500 bg-indigo-50/10">{note}</td></>)}</tr> );
      };

      const SectionHeader = ({ title }) => ( <tr className="bg-stone-200 text-stone-800"><td colSpan={10} className="p-2 pl-4 font-bold text-xs uppercase tracking-wider">{title}</td></tr> );

      const Cal = () => {
        const [lots, setLots] = useState([{ id: 1, lot: '___段___地號', area: 239.12 }]);
        const [inputs, setInputs] = useState({ projectName: '', district: '南投縣中興新村', roads: [{ id: 1, name: '向陽路', width: 10, orientation: 'bottom', type: 'primary', edgeIndex: 2 }], zoneType: '住宅區', urbanPlanName: '中興新村都市計畫區', coverageRatio: 50, floorRatio: 150, excavationRatio: 60, floorsBelow: 1, avgCarArea: 35, frontYardDepth: 4, sideYardDepth: 1.5, sideYardDirection: 'right', backYardDepth: 3, floorHeight1F: 4.2, floorHeightOther: 3.6, baseWidth: '', incentiveArea: 0, transferArea: 0, minBackyardDepthRatio: 0, arcadeDepth: 0, floorsAbove: 4, northAngle: 0 });
        const [params, setParams] = useState({ exemptRate: 15, stairRate: 5, balconyRate: 10, pricePerPing: 25 });
        const [isEditMode, setIsEditMode] = useState(false);
        const [overrides, setOverrides] = useState({});
        const [unusedArea, setUnusedArea] = useState(0);
        const [showDetail, setShowDetail] = useState(true);
  const [showCheckLines, setShowCheckLines] = useState(true);
  const [showHeightRatio, setShowHeightRatio] = useState(true);
  const [showWeiLao, setShowWeiLao] = useState(false);
  const [showBackyard, setShowBackyard] = useState(true);
  const [isConstraintMode, setIsConstraintMode] = useState(false);

  const toggleConstraints = () => setIsConstraintMode(!isConstraintMode);

  const updateLot = (id, field, value) => { setLots(prev => prev.map(l => l.id === id ? { ...l, [field]: field === 'area' ? (parseFloat(value) || 0) : value } : l)); };
        const addLot = () => { const newId = Math.max(...lots.map(l => l.id), 0) + 1; setLots([...lots, { id: newId, lot: '', area: 0 }]); };
        const removeLot = (id) => { if (lots.length > 1) setLots(lots.filter(l => l.id !== id)); };
        const updateRoad = (id, field, value) => { setInputs(prev => ({ ...prev, roads: prev.roads.map(r => r.id === id ? { ...r, [field]: value } : r) })); };
        const addRoad = () => { const newId = Math.max(...inputs.roads.map(r => r.id), 0) + 1; setInputs(prev => ({ ...prev, roads: [...prev.roads, { id: newId, name: '新道路', width: 6, orientation: 'custom', type: 'secondary' }] })); };
        const removeRoad = (id) => { if (inputs.roads.length > 1) setInputs(prev => ({ ...prev, roads: prev.roads.filter(r => r.id !== id) })); };
        const handleUpdateRoads = (newRoads) => { setInputs(prev => ({ ...prev, roads: newRoads })); };

        const totalBaseArea = useMemo(() => lots.reduce((acc, curr) => acc + curr.area, 0), [lots]);
        
        const results = useMemo(() => {
          const base = inputs.baseArea || totalBaseArea;
          const maxBuildingArea = base * (inputs.coverageRatio / 100);
          const statutoryFA = base * (inputs.floorRatio / 100); 
          const exempt15 = statutoryFA * (params.exemptRate / 100);
          const exemptStair = statutoryFA * (params.stairRate / 100);
          const exemptIndoor = exempt15 + exemptStair;
          const balcony = statutoryFA * (params.balconyRate / 100);
          const incentive = parseFloat(inputs.incentiveArea) || 0;
          const transfer = parseFloat(inputs.transferArea) || 0;
          const permittedIndoor = statutoryFA + exemptIndoor + incentive + transfer;
          const roofProtrusion = maxBuildingArea * 0.125 * 2;
          const basementAreaPerFloor = base * (inputs.excavationRatio / 100);
          const totalBasementArea = basementAreaPerFloor * inputs.floorsBelow;
          
          const statutoryParking = Math.floor((statutoryFA + incentive + transfer) / 150); 
          const possibleParking = Math.floor(totalBasementArea / inputs.avgCarArea);
          
          const exemptBasement = statutoryParking * 40;
          
          const totalCFA = permittedIndoor + balcony + roofProtrusion; 
          
          const efficiency = toPing(base) > 0 ? toPing(totalCFA + totalBasementArea) / toPing(base) : 0; 
          
          const calculatedFloors = maxBuildingArea > 0 ? permittedIndoor / maxBuildingArea : 0;
          const floorsAbove = Math.ceil(calculatedFloors);
          const estimatedBudget = toPing(totalCFA + totalBasementArea) * params.pricePerPing; 
          const fh1 = parseFloat(inputs.floorHeight1F) || 0;
          const fhO = parseFloat(inputs.floorHeightOther) || 0;
          const buildingHeight = fh1 + (fhO * Math.max(0, floorsAbove - 1)) + 9;
          const mainRoad = inputs.roads.find(r => r.type === 'primary') || inputs.roads[0];
          const roadWidth = mainRoad ? parseFloat(mainRoad.width) : 0;
          const frontYard = parseFloat(inputs.frontYardDepth) || 0;
          const backYard = parseFloat(inputs.backYardDepth) || 0;
          const heightRatio = (roadWidth + frontYard) > 0 ? buildingHeight / (roadWidth + frontYard) : 0;
          const backyardDepthRatio = backYard > 0 ? buildingHeight / backYard : 0;
          const isHighRise = buildingHeight > 24;
          const isSuperHighRise = buildingHeight > 100;
          const weiLaoRatio = (0.5 * roadWidth + frontYard) > 0 ? 5 / (0.5 * roadWidth + frontYard) : 0;

          return { base, maxBuildingArea, statutoryFA, exempt15, exemptStair, exemptIndoor, balcony, permittedIndoor, roofProtrusion, basementAreaPerFloor, totalBasementArea, totalCFA, efficiency, statutoryParking, possibleParking, calculatedFloors, floorsAbove, estimatedBudget, buildingHeight, heightRatio, backyardDepthRatio, isHighRise, isSuperHighRise, weiLaoRatio, exemptBasement };
        }, [inputs, totalBaseArea, params]);

        const finalRes = { ...results, ...overrides };
        
        useEffect(() => {
             setOverrides(prev => { const copy = {...prev}; delete copy.totalCFA; return copy; });
        }, [inputs.baseArea, inputs.floorRatio]);

        const handleInputChange = (e) => { const { name, value } = e.target; setInputs(prev => ({ ...prev, [name]: value })); };
        const handleOverride = (id, value) => { const val = parseFloat(value); if (!isNaN(val)) setOverrides(prev => ({ ...prev, [id]: val })); };
        const handleParamChange = (key, value) => { setParams(prev => ({ ...prev, [key]: parseFloat(value) || 0 })); };
        const updateBaseDim = (key, val) => { setInputs(prev => ({ ...prev, [key]: val })); };
        const handleUpdateInputs = (key, val) => { setInputs(prev => ({ ...prev, [key]: val })); };

        const inputClass = "w-full p-2 border border-stone-200 rounded-md outline-none transition-all focus:border-indigo-500 focus:ring-4 focus:ring-indigo-500/10 text-stone-700 text-sm num-font";
        const labelClass = "block text-sm font-bold text-stone-500 uppercase mb-1";

        return (
          <div className="min-h-screen bg-stone-50 p-4 md:p-8 text-stone-800">
            <div className="max-w-7xl mx-auto space-y-6">
              <header className="flex flex-col md:flex-row justify-between items-start md:items-center bg-white p-6 rounded-xl shadow-sm border border-stone-200">
                <div><h1 className="text-3xl font-serif font-bold flex items-center gap-3 text-stone-800"><Building2 className="text-stone-600" size={32} />自地自建評估計算書</h1><p className="text-stone-500 font-medium mt-1 ml-1">基地開發效益評估 / 容積獎勵檢討 / 停車空間規劃</p></div>
                <div className="flex items-center gap-4 mt-4 md:mt-0"><div className="flex flex-col mr-4"><label className="text-xs text-stone-400 font-bold uppercase">專案名稱</label><input type="text" name="projectName" value={inputs.projectName} onChange={handleInputChange} placeholder="輸入專案名稱" className="border-b border-stone-300 focus:border-stone-800 outline-none bg-transparent py-1 text-lg font-bold text-stone-800" /></div><button onClick={() => setIsEditMode(!isEditMode)} className={`w-12 h-12 flex items-center justify-center rounded-full transition-all duration-300 shadow-sm border ${isEditMode ? 'bg-stone-800 border-stone-800 text-white' : 'bg-white border-stone-200 text-stone-400 hover:border-stone-400'}`}>{isEditMode ? <Settings2 size={20} /> : <Pencil className="w-6 h-6" />}</button></div>
              </header>
              <Visualizer3D 
            inputs={{...inputs, baseArea: finalRes.base, floorsAbove: finalRes.floorsAbove}} 
            res={finalRes} 
            onUpdateBaseDim={updateBaseDim} 
            onUpdateRoads={handleUpdateRoads} 
            onUpdateInputs={handleUpdateInputs}
            showCheckLines={showCheckLines}
            setShowCheckLines={setShowCheckLines}
            showHeightRatio={showHeightRatio}
            setShowHeightRatio={setShowHeightRatio}
            showWeiLao={showWeiLao}
            setShowWeiLao={setShowWeiLao}
            showBackyard={showBackyard}
            setShowBackyard={setShowBackyard}
            isConstraintMode={isConstraintMode}
            setIsConstraintMode={setIsConstraintMode}
            onUnusedAreaChange={setUnusedArea}
        />
              <div className="grid grid-cols-1 xl:grid-cols-3 gap-6">
                <CollapsibleSection title="基本資料" icon={<MapPin size={18} className="text-rose-500" />} className="xl:col-span-1">
                  <div className="space-y-3">
                    <div><label className={labelClass}>行政區</label><input type="text" name="district" value={inputs.district} onChange={handleInputChange} className={inputClass} /></div>
                    <div className="space-y-2"><div className="flex justify-between items-center"><label className={labelClass}>地號與面積 (㎡)</label><button onClick={addLot} className="text-indigo-500 hover:text-indigo-700 text-sm flex items-center gap-1"><Plus size={12} /> 新增</button></div><div className="max-h-40 overflow-y-auto pr-1 space-y-2">{lots.map(l => (<div key={l.id} className="flex gap-2 items-center group"><input type="text" placeholder="地號" value={l.lot} onChange={(e) => updateLot(l.id, 'lot', e.target.value)} className={`${inputClass} text-sm`} /><input type="number" placeholder="面積" value={l.area} onChange={(e) => updateLot(l.id, 'area', e.target.value)} className={`${inputClass} text-sm w-24 text-right`} />{lots.length > 1 && <button onClick={() => removeLot(l.id)} className="text-stone-300 hover:text-rose-500"><Trash2 size={14} /></button>}</div>))}</div><div className="text-right text-sm font-bold text-stone-500 pt-1 border-t">合計: {formatNum(totalBaseArea)} ㎡ ({formatNum(toPing(totalBaseArea))} 坪)</div></div>
                    <div className="space-y-3 mt-4 pt-4 border-t border-stone-100"><div className="flex justify-between items-center"><label className={labelClass}>臨路狀況</label><button onClick={addRoad} className="text-indigo-500 hover:text-indigo-700 text-sm flex items-center gap-1"><Plus size={12} /> 新增道路</button></div><div className="space-y-2"><div className="grid grid-cols-12 gap-2 text-xs text-stone-400 font-bold mb-1 px-1"><div className="col-span-4">路名</div><div className="col-span-2 text-center">寬(M)</div><div className="col-span-3">方位</div><div className="col-span-2 text-center">主要</div><div className="col-span-1"></div></div><div className="max-h-40 overflow-y-auto pr-1 space-y-2">{inputs.roads.map(r => (<div key={r.id} className="grid grid-cols-12 gap-2 items-center bg-stone-50 p-2 rounded border border-stone-100"><div className="col-span-4"><input type="text" value={r.name} onChange={(e) => updateRoad(r.id, 'name', e.target.value)} className={`${inputClass} py-1 text-sm`} placeholder="路名"/></div><div className="col-span-2"><input type="number" value={r.width} onChange={(e) => updateRoad(r.id, 'width', e.target.value)} className={`${inputClass} py-1 text-sm text-center`} placeholder="M"/></div><div className="col-span-3 text-xs text-stone-500 text-center">{r.edgeIndex !== undefined ? `邊線 ${r.edgeIndex}` : (r.orientation==='custom'?'自訂':r.orientation)}</div><div className="col-span-2 flex justify-center"><input type="checkbox" checked={r.type === 'primary'} onChange={(e) => updateRoad(r.id, 'type', e.target.checked ? 'primary' : 'secondary')} className="w-4 h-4 rounded border-stone-300 text-indigo-600 focus:ring-indigo-500 cursor-pointer"/></div><div className="col-span-1 text-center">{inputs.roads.length > 1 && <button onClick={() => removeRoad(r.id)} className="text-stone-300 hover:text-rose-500"><Trash2 size={14} /></button>}</div></div>))}</div></div></div>
                    <div className="mt-4 pt-4 border-t border-stone-100"><div className="flex justify-between items-center mb-2"><h4 className="text-xs font-bold text-stone-500 uppercase flex items-center gap-1"><Ruler size={12} /> 基地形狀設定 (3D)</h4></div><div className="grid grid-cols-2 gap-2"><div><label className="text-[10px] text-stone-400 block">面寬 (Width)</label><input type="number" value={inputs.baseWidth || Math.sqrt(totalBaseArea || 100).toFixed(1)} onChange={(e) => updateBaseDim('baseWidth', e.target.value)} className="w-full border border-stone-200 rounded p-1 text-sm font-bold text-stone-700 bg-stone-50 focus:bg-white focus:ring-2 ring-indigo-100 outline-none num-font" /></div><div><label className="text-[10px] text-stone-400 block">深度 (Depth)</label><input type="number" value={((totalBaseArea || 100) / (parseFloat(inputs.baseWidth) || Math.sqrt(totalBaseArea || 100))).toFixed(1)} onChange={(e) => { const val = parseFloat(e.target.value); if (val > 0 && totalBaseArea > 0) updateBaseDim('baseWidth', (totalBaseArea/val).toFixed(2)); }} className="w-full border border-stone-200 rounded p-1 text-sm font-bold text-stone-700 bg-stone-50 focus:bg-white focus:ring-2 ring-indigo-100 outline-none num-font" /></div></div></div>
                  </div>
                </CollapsibleSection>
                <CollapsibleSection title="法規參數" icon={<FileText size={18} className="text-sky-500" />} className="xl:col-span-1">
                  <div className="space-y-3">
                    <div><label className={labelClass}>使用分區</label><input type="text" name="zoneType" value={inputs.zoneType} onChange={handleInputChange} className={inputClass} /></div>
                    <div><label className={labelClass}>都市計畫名稱</label><input type="text" name="urbanPlanName" value={inputs.urbanPlanName} onChange={handleInputChange} className={inputClass} /></div>
                    <div className="grid grid-cols-2 gap-3"><div><label className={`${labelClass} text-sky-600`}>建蔽率 (%)</label><input type="number" name="coverageRatio" value={inputs.coverageRatio} onChange={handleInputChange} className={`${inputClass} font-bold text-sky-700`} /></div><div><label className={`${labelClass} text-sky-600`}>容積率 (%)</label><input type="number" name="floorRatio" value={inputs.floorRatio} onChange={handleInputChange} className={`${inputClass} font-bold text-sky-700`} /></div></div>
                    <div><label className={`${labelClass} text-amber-600`}>地下室開挖率 (%)</label><input type="number" name="excavationRatio" value={inputs.excavationRatio} onChange={handleInputChange} className={`${inputClass} text-amber-700`} /></div>
                  </div>
                </CollapsibleSection>
                <CollapsibleSection title="樓層規劃" icon={<Layers size={18} className="text-indigo-500" />} className="xl:col-span-1">
                  <div className="space-y-3">
                    <div className="grid grid-cols-2 gap-3"><div><label className={labelClass}>地上樓層數 (預估)</label><div className={`${inputClass} bg-stone-50 font-bold text-indigo-600 flex items-center justify-between`}><span>{finalRes.floorsAbove}F</span><span className="text-xs text-stone-400 font-normal">(C8/A2={formatNum(finalRes.calculatedFloors)})</span></div></div><div><label className={labelClass}>地下樓層數</label><input type="number" name="floorsBelow" value={inputs.floorsBelow} onChange={handleInputChange} className={inputClass} /></div></div>
                    <div><label className={labelClass}>允建總樓地板面積 (Total CFA)</label><div className={`${inputClass} bg-stone-50 text-xl font-bold text-right flex items-center justify-between text-indigo-800`}><span className="text-xs text-indigo-300 font-normal">Auto Calc</span>{formatNum(finalRes.totalCFA)}</div></div>
                  </div>
                </CollapsibleSection>
              </div>
              <div className="bg-white rounded-xl shadow-sm overflow-hidden border border-stone-200">
                <div className="p-4 bg-stone-100 border-b border-stone-200 flex justify-between items-center cursor-pointer hover:bg-stone-100 transition-colors" onClick={() => setShowDetail(!showDetail)}><h3 className="font-bold text-stone-700 flex items-center gap-2"><FileText size={18} /> 詳細計算表</h3><div className="text-stone-500">{showDetail ? <ChevronUp size={20} /> : <ChevronDown size={20} />}</div></div>
                <div className={`transition-all duration-500 ease-in-out overflow-hidden ${showDetail ? 'max-h-[2500px] opacity-100' : 'max-h-0 opacity-0'}`}>
                   <div className="overflow-x-auto">
                      <table className="w-full text-left border-collapse num-font">
                         <thead><tr className="bg-stone-50 text-stone-600 text-sm border-b border-stone-300"><th className="p-4 w-1/4">評估項目</th><th className="p-4 w-1/6 text-right">數值/面積 (㎡)</th><th className="p-4 w-1/6 text-right">坪數 (坪)</th>{isEditMode && <><th className="p-4 text-indigo-700 bg-indigo-50/50 w-1/4">參數設定</th><th className="p-4 text-indigo-700 bg-indigo-50/50">註解與說明</th></>}</tr></thead>
                         <tbody className="text-stone-700 divide-y divide-stone-100">
                            <SectionHeader title="A. 基地基礎法規檢討" />
                            <InputRow id="base" label="1. 基地面積" value={finalRes.base} calculatedValue={results.base} formula="SUM(地號面積)" note="多筆地號加總" isEditMode={isEditMode} onOverride={handleOverride} />
                            <InputRow id="maxBuildingArea" label="2. 允建建築面積" value={finalRes.maxBuildingArea} calculatedValue={results.maxBuildingArea} formula="基地面積 × 法定建蔽率" note={`建蔽率 ${inputs.coverageRatio}%，單層最大面積`} isEditMode={isEditMode} onOverride={handleOverride} highlight />
                            <InputRow id="statutoryFA" label="3. 法定容積 (FA)" value={finalRes.statutoryFA} calculatedValue={results.statutoryFA} formula="基地面積 × 法定容積率" note={`容積率 ${inputs.floorRatio}%，不含獎勵`} isEditMode={isEditMode} onOverride={handleOverride} highlight />
                            <SectionHeader title="B. 免計容積與獎勵試算" />
                            <InputRow id="incentiveArea" label="4. 獎勵容積" value={inputs.incentiveArea} calculatedValue={inputs.incentiveArea} formula="自行輸入" note="都更、危老等獎勵" isEditMode={isEditMode} onOverride={handleInputChange} />
                            <InputRow id="transferArea" label="5. 移轉容積" value={inputs.transferArea} calculatedValue={inputs.transferArea} formula="自行輸入" note="容積移轉" isEditMode={isEditMode} onOverride={handleInputChange} />
                            <InputRow id="exempt15" label={`6. 免計容積 (${params.exemptRate}%)`} value={finalRes.exempt15} calculatedValue={results.exempt15} formula="法定容積 FA × 免計率" note="機電設備、安全梯等 (法規上限)" isEditMode={isEditMode} onOverride={handleOverride} paramKey="exemptRate" paramValue={params.exemptRate} onParamChange={handleParamChange} />
                            <InputRow id="exemptStair" label="7. 免計梯廳" value={finalRes.exemptStair} calculatedValue={results.exemptStair} formula={`法定容積 FA × ${params.stairRate}%`} note="梯廳獎勵，需視設計而定" isEditMode={isEditMode} onOverride={handleOverride} paramKey="stairRate" paramValue={params.stairRate} onParamChange={handleParamChange} />
                            <InputRow id="exemptIndoor" label="8. 免計容積室內合計" value={finalRes.exemptIndoor} calculatedValue={results.exemptIndoor} formula="Item 6 + Item 7" note="免計容積總和" isEditMode={isEditMode} onOverride={handleOverride} subTotal />
                            <InputRow id="balcony" label="9. 免計容積陽台" value={finalRes.balcony} calculatedValue={results.balcony} formula={`法定容積 FA × ${params.balconyRate}%`} note="每層樓地板 1/8 或 FA 10%" isEditMode={isEditMode} onOverride={handleOverride} paramKey="balconyRate" paramValue={params.balconyRate} onParamChange={handleParamChange} />
                            <SectionHeader title="C. 允建面積總表" />
                            <InputRow id="permittedIndoor" label="10. 允建室內面積" value={finalRes.permittedIndoor} calculatedValue={results.permittedIndoor} formula="法定 + 獎勵 + 移轉 + 免計" note="不含陽台之室內實際使用空間" isEditMode={isEditMode} onOverride={handleOverride} bold />
                            <InputRow id="roofProtrusion" label="11. 允建屋突面積" value={finalRes.roofProtrusion} calculatedValue={results.roofProtrusion} formula="(建築面積 × 1/8) × 2層" note="屋頂突出物 (水箱、電梯機房)" isEditMode={isEditMode} onOverride={handleOverride} />
                            <InputRow id="totalBasementArea" label="12. 地下室總面積" value={finalRes.totalBasementArea} calculatedValue={results.totalBasementArea} formula="基地 × 開挖率 × 地下層數" note={`開挖率 ${inputs.excavationRatio}%，地下 ${inputs.floorsBelow} 層`} isEditMode={isEditMode} onOverride={handleOverride} />
                            <tr className="bg-amber-50 border-y-2 border-amber-200"><td className="p-4 font-bold text-stone-800 text-lg">13. 允建總樓地板面積 (Total CFA){unusedArea > 0.1 && <div className="text-xs text-emerald-600 font-normal mt-1">還有 {formatNum(toPing(unusedArea))} 坪 ({formatNum(unusedArea)} m²) 未使用</div>}</td><td className="p-4 text-right font-bold text-stone-800 text-lg">{isEditMode ? (<div className="flex items-center justify-end gap-2">{Math.abs(finalRes.totalCFA - results.totalCFA) > 0.01 && <div className="text-red-500 flex items-center text-xs" title="與公式計算值衝突"><AlertTriangle size={14}/></div>}<input type="number" value={finalRes.totalCFA} onChange={(e) => handleOverride('totalCFA', e.target.value)} className="w-24 p-1 text-right border border-stone-300 rounded bg-white"/></div>) : formatNum(finalRes.totalCFA)}</td><td className="p-4 text-right font-bold text-stone-800 text-lg">{formatNum(toPing(finalRes.totalCFA))}</td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-600">允建室內+陽台+屋突</td><td className="p-4 text-sm text-stone-600">鎖定上限 (含獎勵/免計)</td></>}</tr>
                            <tr className="bg-stone-100 border-y-2 border-stone-200"><td className="p-4 font-bold text-stone-700 text-lg">工程預算評估</td><td className="p-4 text-right font-bold text-stone-700 text-lg" colSpan={2}><div className="flex items-center justify-end gap-2"><span className="text-sm text-stone-500 font-normal mr-2">單價(萬/坪):</span>{isEditMode ? <input type="number" value={params.pricePerPing} onChange={(e) => handleParamChange('pricePerPing', e.target.value)} className="w-20 p-1 text-right border border-stone-300 rounded bg-white font-bold"/> : <span className="font-bold underline decoration-dotted decoration-stone-400">{params.pricePerPing}</span>}<span className="text-sm text-stone-500 mx-2">=</span><span>{formatNum(finalRes.estimatedBudget)} 萬</span></div></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">Total CFA (坪) × 單價</td><td className="p-4 text-sm text-stone-500">概估造價 (未含設計監造/稅)</td></>}</tr>
                            <SectionHeader title="D. 空間與停車檢討" />
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">12. 地上樓層估算</td><td className="p-4 text-right" colSpan={2}>約 <span className="font-bold text-indigo-600">{formatNum(finalRes.floorsAbove)}</span> 層</td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">C8 / A2</td><td className="p-4 text-sm text-stone-500">允建室內 / 允建建築面積</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">13. 地下層開挖檢討</td><td className="p-4 text-right" colSpan={2}>B1 ~ B{inputs.floorsBelow} (單層 {formatNum(toPing(finalRes.basementAreaPerFloor))} 坪)</td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">基地 × {inputs.excavationRatio}%</td><td className="p-4 text-sm text-stone-500">單層最大開挖面積</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium flex items-center gap-2"><Car size={16}/> 14. 停車空間檢討</td><td className="p-4 text-right" colSpan={2}>法定約 {formatNum(finalRes.statutoryParking)} 部 / 空間可停 {formatNum(finalRes.possibleParking)} 部</td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">總樓地板/150 (法定)</td><td className="p-4 text-sm text-stone-500">空間以每車 {inputs.avgCarArea}m² 預估</td></>}</tr>
                             <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">*. 地下室免計容積</td><td className="p-4 text-right" colSpan={2}>{formatNum(finalRes.exemptBasement)} ㎡ ({formatNum(toPing(finalRes.exemptBasement))} 坪)</td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">40 × 法定停車</td><td className="p-4 text-sm text-stone-500">地下室停車免計面積</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">15. 坪效分析 (倍數)</td><td className="p-4 text-right font-bold text-emerald-600" colSpan={2}>{formatNum(finalRes.efficiency)} 倍</td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">總銷坪 / 基地坪</td><td className="p-4 text-sm text-stone-500">投入 1 坪土地可蓋出的坪數</td></>}</tr>
                            <SectionHeader title="E. 高度比檢討" />
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">16. 前院深度</td><td className="p-4 text-right"><div className="flex items-center justify-end gap-2"><input type="number" name="frontYardDepth" value={inputs.frontYardDepth} onChange={handleInputChange} className="w-20 p-1 text-right border border-stone-300 rounded"/> m</div></td><td className="p-4 text-right text-stone-500"></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">自行輸入</td><td className="p-4 text-sm text-stone-500">3D圖面顯示退縮</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">17. 側院深度</td><td className="p-4 text-right"><div className="flex items-center justify-end gap-2"><select name="sideYardDirection" value={inputs.sideYardDirection || 'right'} onChange={handleInputChange} className="text-xs p-1 rounded border border-stone-300 bg-white"><option value="right">右側</option><option value="left">左側</option></select><input type="number" name="sideYardDepth" value={inputs.sideYardDepth || 0} onChange={handleInputChange} className="w-20 p-1 text-right border border-stone-300 rounded"/> m</div></td><td className="p-4 text-right text-stone-500"></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">自行輸入</td><td className="p-4 text-sm text-stone-500">設定側院方向與深度</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">18. 後院深度</td><td className="p-4 text-right"><div className="flex items-center justify-end gap-2"><input type="number" name="backYardDepth" value={inputs.backYardDepth} onChange={handleInputChange} className="w-20 p-1 text-right border border-stone-300 rounded"/> m</div></td><td className="p-4 text-right text-stone-500"></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">自行輸入</td><td className="p-4 text-sm text-stone-500">3D圖面顯示退縮</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">19. 樓層高度設定</td><td className="p-4 text-right" colSpan={2}><div className="flex flex-col gap-2 items-end"><div className="flex items-center gap-2"><span className="text-xs text-stone-500">1F:</span><input type="number" name="floorHeight1F" value={inputs.floorHeight1F} onChange={handleInputChange} className={`w-16 p-1 text-right border rounded ${inputs.zoneType === '住宅區' && parseFloat(inputs.floorHeight1F) > 4.2 ? 'border-rose-400 bg-rose-50' : 'border-stone-300'}`}/>{inputs.arcadeDepth > 0 && inputs.frontYardDepth == 0 && parseFloat(inputs.floorHeight1F) < 3 && <span className="text-[10px] text-red-500 font-bold bg-red-50 px-1 rounded animate-pulse">騎樓需&gt;3m</span>}</div><div className="flex items-center gap-2"><span className="text-xs text-stone-500">其他:</span><input type="number" name="floorHeightOther" value={inputs.floorHeightOther} onChange={handleInputChange} className={`w-16 p-1 text-right border rounded ${inputs.zoneType === '住宅區' && parseFloat(inputs.floorHeightOther) > 3.6 ? 'border-rose-400 bg-rose-50' : 'border-stone-300'}`}/></div></div></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">住宅區 1F≤4.2, 其他≤3.6</td><td className="p-4 text-sm text-stone-500">自行輸入 (超限變紅)</td></>}</tr>
                            <InputRow id="buildingHeight" label="20. 建築物高度" value={finalRes.buildingHeight} calculatedValue={finalRes.buildingHeight} formula="1F+(其他×(F-1))+9" note={finalRes.isSuperHighRise ? "超高層建築 (>100m)" : finalRes.isHighRise ? "高層建築 (>24m)" : "一般建築"} isEditMode={isEditMode} onOverride={handleOverride} highlight />
                            <InputRow id="heightRatio" label="21. 高度比" value={finalRes.heightRatio} calculatedValue={finalRes.heightRatio} formula="高度 / (路寬+前院)" note="建築高度 / (主路寬+前院深)" isEditMode={isEditMode} onOverride={handleOverride} highlight />
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">22. 最小後院深度比 (檢討)</td><td className="p-4 text-right"><div className="flex flex-col items-end gap-1"><div className="flex items-center justify-end gap-2"><input type="number" name="minBackyardDepthRatio" value={inputs.minBackyardDepthRatio || 0} onChange={handleInputChange} className="w-20 p-1 text-right border border-stone-300 rounded"/></div></div></td><td className="p-4 text-right text-stone-500"></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">自行輸入</td><td className="p-4 text-sm text-stone-500">設定比值 (如 2 代表深度 &gt; 高度/2)</td></>}</tr>
                            <InputRow id="weiLaoRatio" label="23. 危老評估 (路心比)" value={finalRes.weiLaoRatio} calculatedValue={finalRes.weiLaoRatio} formula="5 / (0.5×路寬 + 前院)" note="危老條例高度檢討係數" isEditMode={isEditMode} onOverride={handleOverride} highlight />
                            {inputs.frontYardDepth == 0 && (
                                <tr className="hover:bg-indigo-50/30 border-t-2 border-indigo-100">
                                   <td className="p-4 pl-8 border-l-4 border-indigo-400 font-bold text-indigo-700">24. 騎樓深度</td>
                                   <td className="p-4 text-right">
                                       <div className="flex items-center justify-end gap-2">
                                           <input type="number" name="arcadeDepth" value={inputs.arcadeDepth} onChange={handleInputChange} className="w-20 p-1 text-right border border-indigo-300 rounded font-bold text-indigo-600 bg-white"/> m
                                       </div>
                                   </td>
                                   <td className="p-4 text-right text-stone-500"></td>
                                   {isEditMode && <><td className="p-4 font-mono text-xs text-indigo-500">僅當前院=0時可用</td><td className="p-4 text-sm text-indigo-500">設定後1F自動退縮，樓高需&gt;3m</td></>}
                                </tr>
                            )}
                         </tbody>
                      </table>
                   </div>
                </div>
              </div>

            </div>
          </div>
        );
      };

      const root = createRoot(document.getElementById('root'));
      root.render(<Cal />);
    </script>
  </body>
</html>
