<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>自地自建評估計算書</title>

    <!-- 1. 引入 Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 2. 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Tailwind Config -->
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['GenYoGothic', 'sans-serif'],
            },
            cursor: {
              grab: 'grab',
              grabbing: 'grabbing',
            },
            colors: {
               stone: { 50: '#fafaf9', 100: '#f5f5f4', 200: '#e7e5e4', 300: '#d6d3d1', 400: '#a8a29e', 500: '#78716c', 600: '#57534e', 700: '#44403c', 800: '#292524', 900: '#1c1917' }
            }
          },
        },
      }
    </script>

    <style>
      @font-face {
        font-family: 'GenYoGothic';
        src: local('GenYoGothic'), local('源樣黑體'), local('Noto Sans TC');
      }
      body {
        background-color: #f5f5f4;
        font-family: 'GenYoGothic', sans-serif;
        overflow-x: hidden;
        overscroll-behavior-y: none; 
      }
      .num-font {
        font-variant-numeric: tabular-nums;
      }
      .no-scrollbar::-webkit-scrollbar {
        display: none;
      }
      .no-scrollbar {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }
      @keyframes riseUp {
        0% { transform: translate3d(var(--tx), var(--ty), -50px); opacity: 0; }
        100% { transform: translate3d(var(--tx), var(--ty), var(--tz)); opacity: 1; }
      }
      @keyframes slideUp {
        from { transform: translateY(100%); }
        to { transform: translateY(0); }
      }
      .animate-slide-up {
        animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      }
      @keyframes pulse-ring {
        0% { transform: scale(0.8); opacity: 0.8; }
        100% { transform: scale(1.5); opacity: 0; }
      }
      .animate-pulse-ring::before {
        content: '';
        position: absolute;
        left: -50%; top: -50%; width: 200%; height: 200%;
        border-radius: 50%;
        border: 2px solid #0ea5e9;
        animation: pulse-ring 1.5s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
      }
      /* Custom Cursor for Pan */
      .cursor-pan {
          cursor: grab;
      }
      .cursor-pan:active {
          cursor: grabbing;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
      import React, { useState, useMemo, useEffect, useRef, useCallback } from 'https://esm.sh/react@18.2.0';
      import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client';
      import { 
        MapPin, Ruler, FileText, Info, Building2, Car, Layers, 
        ArrowDownUp, AlertTriangle, Bike, Compass, Plus, Trash2, 
        ChevronDown, ChevronUp, ChevronRight, ChevronLeft, Map, LayoutDashboard, Settings2, 
        Pencil, RefreshCw, RotateCw, Eye, Maximize, ToggleLeft, 
        ToggleRight, Box, Sun, Moon, ZoomIn, ZoomOut, PanelRightClose, PanelRightOpen,
        AlignLeft, AlignCenter, AlignRight, AlignVerticalJustifyCenter, ArrowUpToLine, ArrowDownToLine,
        Edit3, RotateCcw, Undo2, CheckCircle2, GripHorizontal, Copy, Move, Maximize2, Lock, Unlock,
        Grid, X, LayoutTemplate, MoreVertical, Hexagon, CheckSquare, Square, Scaling, Settings,
        ParkingCircle, Warehouse, MousePointer2, PlusCircle, Shovel, MinusCircle, MousePointerClick, Crosshair,
        CornerUpLeft, Grip, Hand
      } from 'https://esm.sh/lucide-react@0.263.1';

      // --- Helper Functions ---
      const formatNum = (num, digits = 2) => {
        return new Intl.NumberFormat('zh-TW', {
          minimumFractionDigits: digits,
          maximumFractionDigits: digits
        }).format(num || 0);
      };

      const toSqm = (ping) => ping * 3.3058;
      const toPing = (sqm) => sqm * 0.3025;
      
      const generateSvgPath = (points, curves, scale = 1, offsetX = 0, offsetY = 0) => {
          if (!points || points.length === 0) return "";
          let d = `M ${(points[0].x * scale) + offsetX} ${(points[0].y * scale) + offsetY}`;
          for (let i = 0; i < points.length; i++) {
              const nextP = points[(i + 1) % points.length];
              const curve = curves ? curves[i] : null;
              if (curve) {
                  d += ` Q ${(curve.x * scale) + offsetX} ${(curve.y * scale) + offsetY}, ${(nextP.x * scale) + offsetX} ${(nextP.y * scale) + offsetY}`;
              } else {
                  d += ` L ${(nextP.x * scale) + offsetX} ${(nextP.y * scale) + offsetY}`;
              }
          }
          d += " Z";
          return d;
      };

      const calculatePolygonArea = (points) => {
          if (!points || points.length < 3) return 0;
          let area = 0;
          for (let i = 0; i < points.length; i++) {
              const j = (i + 1) % points.length;
              area += points[i].x * points[j].y;
              area -= points[j].x * points[i].y;
          }
          return Math.abs(area) / 2;
      };

      const getPolygonCentroid = (points) => {
          if (!points || points.length === 0) return { x: 0, y: 0 };
          let cx = 0, cy = 0, area = 0;
          for (let i = 0; i < points.length; i++) {
              const j = (i + 1) % points.length;
              const cross = points[i].x * points[j].y - points[j].x * points[i].y;
              cx += (points[i].x + points[j].x) * cross;
              cy += (points[i].y + points[j].y) * cross;
              area += cross;
          }
          area /= 2;
          if (area === 0) {
              const sum = points.reduce((acc, p) => ({x: acc.x + p.x, y: acc.y + p.y}), {x:0, y:0});
              return { x: sum.x / points.length, y: sum.y / points.length };
          }
          return { x: cx / (6 * area), y: cy / (6 * area) };
      };

      const scalePolygon = (points, curves, scale, centroid) => {
          if (!points) return { points: null, curves: null };
          const center = centroid || getPolygonCentroid(points);
          const newPoints = points.map(p => ({
              x: (p.x - center.x) * scale + center.x,
              y: (p.y - center.y) * scale + center.y
          }));
          let newCurves = null;
          if (curves) {
              newCurves = {};
              Object.keys(curves).forEach(k => {
                  const cp = curves[k];
                  newCurves[k] = {
                      x: (cp.x - center.x) * scale + center.x,
                      y: (cp.y - center.y) * scale + center.y
                  };
              });
          }
          return { points: newPoints, curves: newCurves };
      };

      const getSegmentNormal = (p1, p2, centroid) => {
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const len = Math.sqrt(dx * dx + dy * dy);
          if (len === 0) return { x: 0, y: 0 };
          
          let nx = -dy / len;
          let ny = dx / len;
          
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          const toCentroidX = centroid.x - midX;
          const toCentroidY = centroid.y - midY;
          
          // Ensure normal points inward
          if (nx * toCentroidX + ny * toCentroidY < 0) {
              nx = -nx;
              ny = -ny;
          }
          return { x: nx, y: ny };
      };

      const getLineIntersection = (p1, p2, p3, p4) => {
          const denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
          if (denom == 0) return null;
          const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;
          return { x: p1.x + ua * (p2.x - p1.x), y: p1.y + ua * (p2.y - p1.y) };
      };

      const discretizePolygon = (points, curves, steps = 10) => {
          if (!curves) return { points: points, edgeMap: points.map((_, i) => i) };
          const newPoints = [];
          const edgeMap = [];
          for (let i = 0; i < points.length; i++) {
              const p1 = points[i];
              const p2 = points[(i + 1) % points.length];
              const curve = curves[i];
              if (curve) {
                  for (let j = 0; j < steps; j++) {
                      const t = j / steps;
                      const invT = 1 - t;
                      const x = invT * invT * p1.x + 2 * invT * t * curve.x + t * t * p2.x;
                      const y = invT * invT * p1.y + 2 * invT * t * curve.y + t * t * p2.y;
                      newPoints.push({ x, y });
                      edgeMap.push(i);
                  }
              } else {
                  newPoints.push(p1);
                  edgeMap.push(i);
              }
          }
          return { points: newPoints, edgeMap };
      };

      const offsetPolygon = (points, edgeTypes, depths, frontageIndices, curves) => {
          if (!points || points.length < 3) return null;
          
          // 1. Discretize if curves exist
          const { points: densePoints, edgeMap } = discretizePolygon(points, curves, 15);
          
          const centroid = getPolygonCentroid(densePoints); // Use dense centroid
          
          const shiftedLines = [];
          for (let i = 0; i < densePoints.length; i++) {
              const p1 = densePoints[i];
              const p2 = densePoints[(i + 1) % densePoints.length];
              const normal = getSegmentNormal(p1, p2, centroid);
              
              let depth = 0; 
              const originalIdx = edgeMap[i];
              
              if (frontageIndices && frontageIndices.has(originalIdx)) {
                  depth = depths.front;
              } else if (edgeTypes && edgeTypes[originalIdx] === 'back') {
                  depth = depths.back;
              } else if (edgeTypes && edgeTypes[originalIdx] === 'side') {
                  depth = depths.side;
              }

              const shiftX = normal.x * depth;
              const shiftY = normal.y * depth;
              
              shiftedLines.push({
                  p1: { x: p1.x + shiftX, y: p1.y + shiftY },
                  p2: { x: p2.x + shiftX, y: p2.y + shiftY },
                  origIdx: originalIdx
              });
          }

          const newPoints = [];
          const newEdgeIndices = [];

          for (let i = 0; i < shiftedLines.length; i++) {
              const l1 = shiftedLines[i];
              const l2 = shiftedLines[(i + 1) % shiftedLines.length];
              const intersect = getLineIntersection(l1.p1, l1.p2, l2.p1, l2.p2);
              
              if (intersect) {
                  newPoints.push(intersect);
              } else {
                  newPoints.push(l1.p2);
              }
              newEdgeIndices.push(l1.origIdx);
          }
          
          return { points: newPoints, edgeIndices: newEdgeIndices };
      };

      const distToSegment = (p, v, w) => {
          const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
          if (l2 == 0) return Math.hypot(p.x - v.x, p.y - v.y);
          let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
          t = Math.max(0, Math.min(1, t));
          return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
      };

      const EditableInput = ({ value, onChange, className, step, disabled }) => {
        const [localVal, setLocalVal] = useState(value);
        const [isEditing, setIsEditing] = useState(false);

        useEffect(() => {
            if (!isEditing) {
                setLocalVal(typeof value === 'number' ? parseFloat(value.toFixed(2)) : value);
            }
        }, [value, isEditing]);

        const handleChange = (e) => {
            setLocalVal(e.target.value);
        };

        const handleBlur = () => {
            setIsEditing(false);
            if (localVal !== "" && !isNaN(parseFloat(localVal))) {
                onChange(parseFloat(localVal));
            } else {
                setLocalVal(parseFloat(value.toFixed(2)));
            }
        };

        const handleKeyDown = (e) => {
            if (e.key === 'Enter') e.target.blur();
        };

        return (
            <input
                type="number"
                value={localVal}
                onChange={handleChange}
                onFocus={() => setIsEditing(true)}
                onBlur={handleBlur}
                onKeyDown={handleKeyDown}
                step={step}
                className={className}
                disabled={disabled}
            />
        );
      };

      const ArtisticCompass = React.memo(({ className, rotation, isDarkMode }) => (
        <div className={`${className} relative flex items-center justify-center opacity-80 transition-transform duration-300 ease-out`} style={{ transform: `rotate(${rotation}deg)` }}>
          <svg viewBox="0 0 100 100" className="w-full h-full drop-shadow-lg">
            <circle cx="50" cy="50" r="46" fill={isDarkMode ? "#1e293b" : "#f8fafc"} stroke={isDarkMode ? "#475569" : "#94a3b8"} strokeWidth="1.5" />
            <circle cx="50" cy="50" r="42" fill="none" stroke={isDarkMode ? "#64748b" : "#cbd5e1"} strokeWidth="0.5" strokeDasharray="3 3" />
            <line x1="50" y1="4" x2="50" y2="96" stroke={isDarkMode ? "#334155" : "#e2e8f0"} strokeWidth="0.5" />
            <line x1="4" y1="50" x2="96" y2="50" stroke={isDarkMode ? "#334155" : "#e2e8f0"} strokeWidth="0.5" />
            <path d="M 50 10 L 55 50 L 50 50 L 45 50 Z" fill="#ef4444" />
            <text x="50" y="24" textAnchor="middle" fontSize="8" fontWeight="bold" fill={isDarkMode ? "#e2e8f0" : "#334155"} className="font-serif">N</text>
            <circle cx="50" cy="50" r="2" fill={isDarkMode ? "#e2e8f0" : "#475569"} />
          </svg>
        </div>
      ));

      const FloorInfoCard = ({ data, isDarkMode, onReset, isConstraintMode }) => {
        if (!data) return null;
        
        const isBase = data.id === 'base';
        const isExcavation = data.id === 'excavation';

        return (
          <div 
            className={`absolute z-50 pointer-events-auto transition-opacity duration-300 ease-out ${data ? 'opacity-100' : 'opacity-0'}`}
            style={{ 
                top: '56px', right: '16px',
            }}
          >
             <div className={`backdrop-blur-md border rounded-xl shadow-lg p-3 min-w-[140px] transform scale-90 origin-top-right ${isDarkMode ? 'bg-slate-800/90 border-slate-600 text-white' : 'bg-white/95 border-stone-200 text-stone-700'}`}>
                <div className="flex justify-between items-center mb-1 pb-1 border-b border-stone-200/20">
                    <h3 className="font-bold text-sm flex items-center gap-2">
                        {isBase ? <Map size={14} className="text-stone-500"/> : (isExcavation ? <Shovel size={14} className="text-amber-500"/> : <Layers size={14} className="text-indigo-500"/>)}
                        {isBase ? '基地範圍' : (isExcavation ? '開挖範圍' : `${data.id} 樓板`)}
                    </h3>
                    {!isConstraintMode && !isBase && !isExcavation && <button onClick={() => onReset(data.id)} className="p-0.5 hover:bg-black/10 rounded" title="重置設定"><Undo2 size={12}/></button>}
                </div>
                <div className="space-y-1 text-xs">
                    <div className="flex justify-between items-end">
                        <span className="opacity-60 text-[10px]">面積</span>
                        <span className="font-bold text-base num-font text-indigo-600">{formatNum(toPing(data.realArea))} <span className="text-[10px] text-stone-400 font-normal">坪</span></span>
                    </div>
                     {data.points && (
                         <div className="text-center py-0.5 text-[10px] text-stone-400 bg-stone-100/50 rounded mt-1">
                            自訂多邊形
                         </div>
                     )}
                </div>
             </div>
          </div>
        );
      };
      
      const CoordinatePopup = ({ point, idx, onChange, scale, isDarkMode }) => {
          if (!point) return null;
          return (
             <div 
                className={`absolute z-[60] p-2 rounded-lg shadow-xl border backdrop-blur-sm animate-riseUp ${isDarkMode ? 'bg-slate-800/90 border-slate-600 text-white' : 'bg-white/90 border-stone-200'}`}
                style={{ 
                    left: `calc(50% + ${point.x * scale}px)`, 
                    top: `calc(50% + ${point.y * scale}px)`,
                    transform: 'translate(10px, -50%)'
                }}
                onPointerDown={e => e.stopPropagation()}
             >
                 <div className="text-[10px] font-bold opacity-50 mb-1 flex justify-between items-center">
                     <span>點 {idx + 1} 座標</span>
                 </div>
                 <div className="flex flex-col gap-1">
                     <div className="flex items-center gap-1">
                         <span className="text-xs font-mono w-3 text-stone-400">X</span>
                         <EditableInput value={point.x} onChange={(v) => onChange('x', v)} className="w-16 p-1 text-xs border rounded bg-transparent text-right outline-none focus:border-indigo-500" />
                     </div>
                     <div className="flex items-center gap-1">
                         <span className="text-xs font-mono w-3 text-stone-400">Y</span>
                         <EditableInput value={point.y} onChange={(v) => onChange('y', v)} className="w-16 p-1 text-xs border rounded bg-transparent text-right outline-none focus:border-indigo-500" />
                     </div>
                 </div>
             </div>
          );
      };

      const ContextMenu = ({ x, y, isOpen, onClose, items, isDarkMode }) => {
          if (!isOpen) return null;
          return (
              <div className={`fixed z-[60] min-w-[160px] rounded-lg shadow-xl border overflow-hidden animate-in fade-in zoom-in-95 duration-100 ${isDarkMode ? 'bg-slate-800 border-slate-700 text-slate-200' : 'bg-white border-stone-200 text-stone-700'}`} style={{ top: y, left: x }}>
                  {items.map((item, i) => (
                      <button key={i} onClick={(e) => { e.stopPropagation(); item.action(); onClose(); }} className={`w-full text-left px-4 py-2 text-sm flex items-center gap-2 hover:bg-opacity-50 ${isDarkMode ? 'hover:bg-slate-700' : 'hover:bg-stone-50'} ${item.className || ''}`}>
                          {item.icon}
                          <span>{item.label}</span>
                      </button>
                  ))}
              </div>
          );
      };

      const EditMenu2D = ({ data, isDarkMode, onUpdateSetting, onReset, isOpen, onClose, scale3d, inputs, basePoints, isRoadSelectMode, onToggleRoadSelectMode, interactionMode, setInteractionMode, selectedCurveIdx, onUpdateRoads, onUpdateInputs, isAreaLocked, setIsAreaLocked }) => {
          const [activeTab, setActiveTab] = useState('shape');
          const [contextMenu, setContextMenu] = useState({ x: 0, y: 0, isOpen: false });

          useEffect(() => {
              const handleContextMenu = (e) => {
                  e.preventDefault();
                  setContextMenu({ x: e.clientX, y: e.clientY, isOpen: true });
              };
              document.addEventListener('contextmenu', handleContextMenu);
              return () => document.removeEventListener('contextmenu', handleContextMenu);
          }, []);

          const contextMenuItems = [
              { label: '形狀編輯', icon: <Edit3 size={14}/>, action: () => setActiveTab('shape') },
              { label: '道路設定', icon: <Compass size={14}/>, action: () => setActiveTab('roads') },
              { label: '位置移動', icon: <Move size={14}/>, action: () => setActiveTab('pos') },
              { label: '後院退縮', icon: <Square size={14} className="text-emerald-500"/>, action: () => setInteractionMode('set_back') },
              { label: '側院退縮', icon: <Square size={14} className="text-blue-500"/>, action: () => setInteractionMode('set_side') },
              { label: '完成編輯', icon: <CheckCircle2 size={14}/>, action: onClose, className: 'text-green-600 font-bold' }
          ];
          const [isCollapsed, setIsCollapsed] = useState(false);
          const [lockedParam, setLockedParam] = useState(null);
          const [position, setPosition] = useState({ x: 0, y: 0 });
          const [showHelp, setShowHelp] = useState(false);

          if (!data || !isOpen) return null;
          
          const isBase = data.id === 'base';
          const isExcavation = data.id === 'excavation';

          const pingValue = toPing(data.realArea);
          const points = data.points; 

          useEffect(() => {
              if (activeTab === 'shape' && !points && !isRoadSelectMode && !isBase) {
                  const w = data.realWidth; 
                  const d = data.realDepth;
                  
                  if (isExcavation && basePoints) {
                       const scaleRate = Math.sqrt(inputs.excavationRatio / 100);
                       const { points: newPts, curves: newCurves } = scalePolygon(basePoints, inputs.baseCurves, scaleRate);
                       onUpdateSetting(data.id, 'points', newPts);
                       onUpdateSetting(data.id, 'curves', newCurves);
                  } else {
                       const pts = [{x: -w/2, y: -d/2}, {x: w/2, y: -d/2}, {x: w/2, y: d/2}, {x: -w/2, y: d/2}];
                       onUpdateSetting(data.id, 'points', pts);
                  }
              }
          }, [activeTab]);

          // Removed local isAreaLocked state and ref

          const handleArea = (val) => {
              const newAreaSqm = toSqm(val);
              // if (isAreaLocked) lockedAreaRef.current = newAreaSqm; // Removed
              if (points) {
                  const currentArea = data.realArea;
                  const scale = Math.sqrt(newAreaSqm / currentArea);
                  const { points: newPoints, curves: newCurves } = scalePolygon(points, data.curves, scale, {x:0, y:0});
                  onUpdateSetting(data.id, 'points', newPoints);
                  if (newCurves) onUpdateSetting(data.id, 'curves', newCurves);
              } else {
                  if (lockedParam === 'width') onUpdateSetting(data.id, 'depth', newAreaSqm/data.realWidth);
                  else if (lockedParam === 'depth') onUpdateSetting(data.id, 'width', newAreaSqm/data.realDepth);
                  onUpdateSetting(data.id, 'area', newAreaSqm);
              }
          };

          const handleResetShape = () => {
              if (isBase) {
                  const w = data.realWidth; 
                  const d = data.realDepth;
                  const pts = [{x: -w/2, y: -d/2}, {x: w/2, y: -d/2}, {x: w/2, y: d/2}, {x: -w/2, y: d/2}];
                  onUpdateSetting(data.id, 'points', pts);
                  onUpdateSetting(data.id, 'curves', null);
              } else {
                  onUpdateSetting(data.id, 'points', null);
                  onUpdateSetting(data.id, 'curves', null);
              }
              onReset(data.id); 
          };
          
          const handleRevertCurve = () => {
              if (selectedCurveIdx !== null) {
                  const newCurves = { ...(data.curves || {}) };
                  delete newCurves[selectedCurveIdx];
                  onUpdateSetting(data.id, 'curves', newCurves);
              }
          };

          const toggleTab = (t) => {
              setActiveTab(prev => prev === t ? null : t);
          };
          const toggleLock = (p) => setLockedParam(prev => prev === p ? null : p);
          
          const LockBtn = ({p}) => (
              <button onClick={(e) => {e.stopPropagation(); toggleLock(p);}} className={`p-1 rounded ${lockedParam===p?'bg-indigo-100 text-indigo-600':'text-gray-400'}`}>
                  {lockedParam===p?<Lock size={12}/>:<Unlock size={12}/>}
              </button>
          );

          const handleToggleEdge = (roadId, edgeIdx) => {
              const newRoads = inputs.roads.map(r => {
                  if (r.id === roadId) {
                      const indices = new Set(r.edgeIndices || []);
                      if (r.edgeIndex !== undefined && r.edgeIndex !== null && r.edgeIndex !== "") indices.add(parseInt(r.edgeIndex));
                      
                      if (indices.has(edgeIdx)) indices.delete(edgeIdx);
                      else indices.add(edgeIdx);
                      
                      return { ...r, edgeIndices: Array.from(indices), edgeIndex: undefined };
                  }
                  return r;
              });
              onUpdateRoads(newRoads);
          };

          // Drag Logic
          const isDragging = useRef(false);
          const dragStart = useRef({ x: 0, y: 0 });
          const initialPos = useRef({ x: 0, y: 0 });

          const handleDragStart = (e) => {
              isDragging.current = true;
              dragStart.current = { x: e.clientX, y: e.clientY };
              initialPos.current = { ...position };
              e.target.setPointerCapture(e.pointerId);
          };

          const handleDragMove = (e) => {
              if (!isDragging.current) return;
              const dx = e.clientX - dragStart.current.x;
              const dy = e.clientY - dragStart.current.y;
              setPosition({ x: initialPos.current.x + dx, y: initialPos.current.y + dy });
          };

          const handleDragEnd = (e) => {
              isDragging.current = false;
              e.target.releasePointerCapture(e.pointerId);
          };

          return (
              <>
                  <div 
                      className={`absolute bottom-4 left-0 right-0 z-50 rounded-xl shadow-2xl border backdrop-blur-md transition-opacity duration-300 ease-in-out flex flex-col md:flex-row items-center justify-between p-1 gap-1 mx-auto w-fit ${isDarkMode ? 'bg-slate-800/95 border-slate-600 text-white' : 'bg-white/95 border-stone-200 text-stone-800'}`}
                      style={{ transform: `translate(${position.x}px, ${position.y}px)` }}
                      onClick={(e) => e.stopPropagation()}
                  >
                      {/* Drag Handle */}
                      <div className="absolute -top-6 left-1/2 -translate-x-1/2 flex items-center gap-2">
                          <div 
                            className="w-12 h-4 bg-white/50 rounded-full cursor-grab active:cursor-grabbing flex items-center justify-center border border-stone-200 shadow-sm"
                            onPointerDown={handleDragStart}
                            onPointerMove={handleDragMove}
                            onPointerUp={handleDragEnd}
                          >
                             <GripHorizontal size={12} className="text-stone-500" />
                          </div>
                          <button onClick={() => setIsCollapsed(!isCollapsed)} className="w-6 h-4 bg-white/50 rounded-full flex items-center justify-center border border-stone-200 shadow-sm hover:bg-white">
                              {isCollapsed ? <ChevronUp size={10}/> : <ChevronDown size={10}/>}
                          </button>
                      </div>

                      {/* Left: Info HUD */}
                      {!isCollapsed && (
                          <div className="flex items-center gap-2 px-2 w-full md:w-auto overflow-x-auto no-scrollbar animate-fade-in">
                              <div className="flex items-center gap-2 border-r pr-2 border-stone-300/30 flex-shrink-0">
                                  <span className="font-bold flex items-center gap-1 text-xs">
                                      {isBase ? <Map size={16} className="text-stone-500"/> : (isExcavation ? <Shovel size={16} className="text-amber-500"/> : <Layers size={16} className="text-indigo-500"/>)}
                                      <span className="hidden md:inline">{isBase ? '基地編輯' : (isExcavation ? '開挖範圍' : data.id)}</span>
                                  </span>
                              </div>
                              
                              <div className="flex flex-col items-center leading-none flex-shrink-0">
                                  <span className="text-[9px] opacity-50 uppercase tracking-wide">Area (坪)</span>
                                  <div className="flex items-baseline gap-1">
                                      <EditableInput value={pingValue} onChange={handleArea} step="0.5" className="w-20 p-0 text-center font-bold text-sm border-b border-transparent hover:border-indigo-400 focus:border-indigo-500 outline-none bg-transparent" />
                                      {!points && !isBase && <LockBtn p="area"/>}
                                      {points && (
                                          <button onClick={() => setIsAreaLocked(!isAreaLocked)} className={`p-1 rounded ${isAreaLocked?'bg-indigo-100 text-indigo-600':'text-gray-400'}`} title="鎖定面積 (形狀改變時維持面積)">
                                              {isAreaLocked ? <Lock size={12}/> : <Unlock size={12}/>}
                                          </button>
                                      )}
                                  </div>
                              </div>
                          </div>
                      )}

                      {/* Center: Tools */}
                      <div className="flex items-center gap-1 flex-shrink-0">
                          <button onClick={() => toggleTab('shape')} className={`flex items-center gap-1 px-2 py-1.5 rounded-lg transition-all ${activeTab==='shape' ? 'bg-indigo-600 text-white shadow-lg' : 'hover:bg-stone-100 text-stone-500'}`}>
                              <Hexagon size={14} className={activeTab==='shape'?'animate-pulse':''}/>
                              <span className="text-xs font-bold">形狀</span>
                          </button>

                          {isBase && (
                              <button onClick={() => toggleTab('roads')} className={`flex items-center gap-1 px-2 py-1.5 rounded-lg transition-all ${activeTab==='roads' ? 'bg-indigo-600 text-white shadow-lg' : 'hover:bg-stone-100 text-stone-500'}`}>
                                <Compass size={14}/>
                                <span className="text-xs font-bold">道路</span>
                              </button>
                          )}

                          {!isBase && (
                              <button onClick={() => toggleTab('pos')} className={`flex items-center gap-1 px-2 py-1.5 rounded-lg transition-all ${activeTab==='pos' ? 'bg-indigo-600 text-white shadow-lg' : 'hover:bg-stone-100 text-stone-500'}`}>
                                  <Move size={14}/>
                                  <span className="text-xs font-bold">位置</span>
                              </button>
                          )}
                          
                          {isBase && points && (
                              <>
                                  <button onClick={() => setInteractionMode(interactionMode === 'set_back' ? 'none' : 'set_back')} className={`flex items-center gap-1 px-2 py-1.5 rounded-lg transition-all border ${interactionMode === 'set_back' ? 'bg-emerald-500 text-white border-emerald-600 shadow-lg animate-pulse' : 'bg-white text-stone-600 border-stone-200 hover:bg-stone-50'}`}>
                                      <Square size={14} fill={interactionMode === 'set_back' ? "white" : "none"}/>
                                      <span className="text-xs font-bold">後院(綠)</span>
                                  </button>
                                  <button onClick={() => setInteractionMode(interactionMode === 'set_side' ? 'none' : 'set_side')} className={`flex items-center gap-1 px-2 py-1.5 rounded-lg transition-all border ${interactionMode === 'set_side' ? 'bg-blue-500 text-white border-blue-600 shadow-lg animate-pulse' : 'bg-white text-stone-600 border-stone-200 hover:bg-stone-50'}`}>
                                      <Square size={14} fill={interactionMode === 'set_side' ? "white" : "none"}/>
                                      <span className="text-xs font-bold">側院(藍)</span>
                                  </button>
                              </>
                          )}
                      </div>

                      {/* Right: Actions */}
                      <div className="flex items-center gap-1 border-l pl-2 border-stone-300/30 flex-shrink-0">
                          <button onClick={() => setShowHelp(!showHelp)} className={`p-1.5 rounded-lg transition-colors ${showHelp ? 'bg-indigo-100 text-indigo-600' : 'hover:bg-stone-100 text-stone-500'}`} title="說明">
                              <Info size={14}/>
                          </button>
                          <button onClick={onClose} className="flex items-center gap-1 px-3 py-1.5 rounded-lg bg-stone-800 text-white hover:bg-stone-700 shadow-md transition-colors">
                              <CheckCircle2 size={14}/>
                              <span className="text-xs font-bold">完成</span>
                          </button>
                      </div>

                      {activeTab && (
                          <div className={`absolute bottom-full mb-3 left-1/2 -translate-x-1/2 w-80 p-4 rounded-xl shadow-xl border animate-slide-up ${isDarkMode ? 'bg-slate-800 border-slate-600 text-white' : 'bg-white border-stone-200 text-stone-800'}`}>
                              
                              {activeTab === 'shape' && (
                                  <div className="space-y-3">
                                      <div className="flex justify-between items-center pb-2 border-b border-stone-100/10">
                                          <span className="text-xs font-bold opacity-70">形狀編輯工具</span>
                                          <div className="flex gap-2">
                                              {selectedCurveIdx !== null && (
                                                  <button onClick={handleRevertCurve} className="text-xs text-orange-500 hover:text-orange-600 flex items-center gap-1 px-2 py-1 rounded hover:bg-orange-50 bg-white border border-orange-200 shadow-sm"><RotateCcw size={12}/> 還原直線</button>
                                              )}
                                              <button onClick={handleResetShape} className="text-xs text-red-500 hover:text-red-600 flex items-center gap-1 px-2 py-1 rounded hover:bg-red-50"><Trash2 size={12}/> 重置</button>
                                          </div>
                                      </div>
                                      
                                      {/* Setback Info Summary */}
                                      {isBase && (
                                          <div className="flex items-center justify-between text-xs pb-2 border-b border-stone-100/10 mb-2 bg-stone-50/50 p-2 rounded">
                                              <span className="font-bold flex items-center gap-1 text-stone-600">退縮設定 (米)</span>
                                              <div className="flex gap-2 text-stone-500 font-mono">
                                                 <span title="前院退縮">前:{inputs.frontYardDepth || 0}</span>
                                                 <span title="後院退縮">後:{inputs.backYardDepth || 0}</span>
                                                 <span title="側院退縮">側:{inputs.sideYardDepth || 0}</span>
                                              </div>
                                          </div>
                                      )}
                                      {showHelp && (
                                          !points ? (
                                              <div className="text-center text-xs opacity-50 py-2">正在轉換為多邊形模式...</div>
                                          ) : (
                                              <div className="text-xs opacity-60 text-center py-1 space-y-1">
                                                  <p>拖曳頂點編輯 • 點擊頂點輸入座標</p>
                                                  <p>拖曳橘點建立曲線 • 雙擊橘點還原直線</p>
                                                  <p className="text-indigo-500 font-bold">Shift + 點擊線段 (或長按) 可輸入長度</p>
                                              </div>
                                          )
                                      )}
                                  </div>
                              )}
                              
                              {activeTab === 'roads' && isBase && points && (
                                  <div className="space-y-3">
                                      <div className="pb-2 border-b border-stone-100/10 flex justify-between items-center">
                                          <span className="text-xs font-bold opacity-70">道路方位設定</span>
                                          <button onClick={() => { const newId = Math.max(0, ...inputs.roads.map(r=>r.id)) + 1; onUpdateRoads([...inputs.roads, {id:newId, name:'新道路', width:6, type:'secondary'}]); }} className="text-[10px] bg-indigo-50 text-indigo-600 px-2 py-0.5 rounded border border-indigo-100 hover:bg-indigo-100 flex items-center gap-1">
                                              <Plus size={10}/> 新增
                                          </button>
                                      </div>
                                      
                                      <div className="flex items-center justify-between text-xs pb-2 border-b border-stone-100/10 mb-2 bg-stone-50/50 p-2 rounded">
                                          <span className="font-bold flex items-center gap-1 text-stone-600">退縮設定 (米)</span>
                                          <div className="flex gap-2 text-stone-500 font-mono">
                                             <span title="前院退縮">前:{inputs.frontYardDepth || 0}</span>
                                             <span title="後院退縮">後:{inputs.backYardDepth || 0}</span>
                                             <span title="側院退縮">側:{inputs.sideYardDepth || 0}</span>
                                          </div>
                                      </div>

                                      {showHelp && <p className="text-[10px] opacity-50">指定道路對應的基地邊線 (0 ~ {points.length-1})</p>}

                                      <div className="flex items-center justify-between text-xs pb-2 border-b border-stone-100/10 mb-2">
                                          <span className="font-bold flex items-center gap-1"><Compass size={14}/> 北向方位角</span>
                                          <div className="flex items-center gap-1">
                                              <input type="range" min="0" max="360" value={inputs.northAngle || 0} onChange={(e) => onUpdateInputs('northAngle', parseFloat(e.target.value))} className="w-20 accent-indigo-500" />
                                              <EditableInput value={inputs.northAngle || 0} onChange={(v) => onUpdateInputs('northAngle', v)} className="w-10 p-0.5 text-right border rounded bg-transparent" />
                                              <span>°</span>
                                          </div>
                                      </div>

                                      <div className="space-y-2 max-h-[150px] overflow-y-auto pr-1">
                                          {inputs.roads.map(road => (
                                              <div key={road.id} className="flex flex-col text-xs gap-1 border-b border-stone-100/10 pb-2 mb-2 last:border-0">
                                                  <div className="flex items-center gap-1">
                                                      <button onClick={() => onUpdateRoads(inputs.roads.filter(r => r.id !== road.id))} className="text-stone-300 hover:text-red-500 p-0.5"><Trash2 size={12}/></button>
                                                      <span className="font-bold truncate max-w-[80px]" title={road.name}>{road.name}</span>
                                                      <span className="text-stone-400">({road.width}m)</span>
                                                      <select 
                                                        value={road.type || 'secondary'} 
                                                        onChange={(e) => {
                                                            const newRoads = inputs.roads.map(r => r.id === road.id ? { ...r, type: e.target.value } : r);
                                                            onUpdateRoads(newRoads);
                                                        }}
                                                        className="ml-auto text-[10px] p-0.5 rounded border border-stone-200 bg-white text-stone-700 outline-none"
                                                      >
                                                        <option value="primary">主要</option>
                                                        <option value="secondary">一般</option>
                                                      </select>
                                                  </div>
                                                  <div className="flex flex-wrap gap-1 pl-4">
                                                      {points.map((_, i) => {
                                                          const isActive = (road.edgeIndices || []).includes(i) || road.edgeIndex == i;
                                                          return (
                                                              <button key={i} onClick={() => handleToggleEdge(road.id, i)} className={`text-[9px] px-1.5 py-0.5 rounded border transition-colors ${isActive ? 'bg-indigo-100 border-indigo-300 text-indigo-700 font-bold shadow-sm' : 'bg-white border-stone-200 text-stone-400 hover:bg-stone-50'}`} title={`切換邊線 ${i}`}>
                                                                  {i}
                                                              </button>
                                                          );
                                                      })}
                                                  </div>
                                              </div>
                                          ))}
                                          {inputs.roads.length === 0 && <div className="text-xs opacity-50 text-center">無道路資料</div>}
                                      </div>
                                  </div>
                              )}
                          </div>
                      )}
                  </div>
              </>
          );
      };

      const SummaryRow = ({ label, value, highlight, isAlert, alertText, subtext }) => (
          <div className="flex justify-between items-center py-1 border-b border-stone-100 last:border-0">
              <span className="text-stone-500 text-sm">{label}</span>
              <div className="text-right">
                   <div className={`font-bold num-font ${highlight ? 'text-emerald-600 text-lg' : (isAlert ? 'text-rose-500' : 'text-stone-800')}`}>
                       {value}
                       {isAlert && <span className="ml-2 text-[10px] bg-rose-100 text-rose-600 px-1 rounded">{alertText}</span>}
                   </div>
                   {subtext && <div className="text-[10px] text-stone-400">{subtext}</div>}
              </div>
          </div>
      );

      const BuildingLayer = React.memo(({ width, depth, height, x, y, z, rotation, pivot, scale, color, strokeColor, opacity, visible, showFrame, isSlabMode, animate, delay, isDarkMode, onClick, isSelected, isViolation, points, curves }) => {
        if (!visible) return null;
        const thickness = isSlabMode ? Math.max(1.5, height * 0.08) : height;
        const pivotX = (pivot?.x || 0) * scale;
        const pivotY = (pivot?.y || 0) * scale;
        
        let displayColor = color; let displayBorder = strokeColor; let displayOpacity = opacity;

        const highlightColor = isSelected ? (isDarkMode ? "#38bdf8" : "#0ea5e9") : displayBorder;
        const highlightBorder = isViolation ? `2px solid ${displayBorder}` : (isSelected ? `2px solid ${highlightColor}` : (showFrame ? `1px solid ${displayBorder}` : 'none'));
        const highlightBg = isSelected && !isViolation ? (isDarkMode ? "#0c4a6e" : "#bae6fd") : displayColor;
        const finalBorder = isSlabMode ? (showFrame ? `1px solid ${isViolation ? strokeColor : highlightColor}` : 'none') : highlightBorder;
        const finalOpacity = isSlabMode ? (isViolation ? 0.8 : 0.95) : opacity;

        // Logic for showing SVG stroke: Show if violation, selected, or showFrame is true
        const showStroke = isViolation || isSelected || showFrame;

        const face = (w, h, tx, ty, tz, rx, ry, rz, bg, border, op) => ({
          width: `${w}px`, height: `${h}px`, position: 'absolute', left: '50%', top: '50%', marginLeft: `-${w / 2}px`, marginTop: `-${h / 2}px`, backgroundColor: bg, border: border, boxSizing: 'border-box', transform: `translate3d(${tx}px, ${ty}px, ${tz}px) rotateX(${rx}deg) rotateY(${ry}deg) rotateZ(${rz}deg)`, opacity: op, pointerEvents: 'auto', cursor: 'pointer', transition: 'all 0.5s cubic-bezier(0.4, 0, 0.2, 1)', backfaceVisibility: 'visible', animation: isViolation ? 'pulse-red 3s infinite' : 'none', boxShadow: isDarkMode ? (isSlabMode ? "inset 0 0 15px rgba(255,255,255,0.1)" : "none") : (isSlabMode ? "inset 0 0 5px rgba(0,0,0,0.1)" : "none")
        });

        if (points && points.length > 0) {
            const ptsPx = points.map(p => ({ x: (p.x || 0) * scale, y: (p.y || 0) * scale }));
            if (ptsPx.some(p => isNaN(p.x) || isNaN(p.y))) return null;
            const minX = Math.min(...ptsPx.map(p=>p.x)); const maxX = Math.max(...ptsPx.map(p=>p.x)); const minY = Math.min(...ptsPx.map(p=>p.y)); const maxY = Math.max(...ptsPx.map(p=>p.y));
            const bCx = (maxX + minX) / 2; const bCy = (maxY + minY) / 2;
            const padding = 50; const contW = (maxX - minX) + padding * 2; const contH = (maxY - minY) + padding * 2;
            let d = `M ${(ptsPx[0].x - minX + padding)} ${(ptsPx[0].y - minY + padding)}`;
            for (let i = 0; i < ptsPx.length; i++) {
                const pNext = ptsPx[(i + 1) % ptsPx.length];
                const curve = curves ? curves[i] : null;
                const nextX = pNext.x - minX + padding; const nextY = pNext.y - minY + padding;
                if (curve) { const cpX = curve.x * scale - minX + padding; const cpY = curve.y * scale - minY + padding; d += ` Q ${cpX} ${cpY}, ${nextX} ${nextY}`; } else { d += ` L ${nextX} ${nextY}`; }
            }
            d += " Z";
            const clipPath = `path('${d}')`;
            const walls = []; const segmentsForCurve = 8; 
            for (let i = 0; i < ptsPx.length; i++) {
                const p1 = ptsPx[i]; const p2 = ptsPx[(i + 1) % ptsPx.length]; const curve = curves ? curves[i] : null;
                const generateWallSeg = (pt1, pt2, key) => {
                     const dx = pt2.x - pt1.x; const dy = pt2.y - pt1.y; const dist = Math.sqrt(dx*dx + dy*dy); const angle = Math.atan2(dy, dx) * (180 / Math.PI); const midX = (pt1.x + pt2.x) / 2; const midY = (pt1.y + pt2.y) / 2; const customTransform = `translate3d(${midX}px, ${midY}px, ${thickness/2}px) rotateZ(${angle}deg) rotateX(90deg)`;
                     walls.push( <div key={key} style={{ width: `${dist + 0.5}px`, height: `${thickness}px`, position: 'absolute', left: '50%', top: '50%', marginLeft: `-${(dist + 0.5) / 2}px`, marginTop: `-${thickness / 2}px`, backgroundColor: highlightBg, border: finalBorder, boxSizing: 'border-box', transform: customTransform, opacity: finalOpacity, pointerEvents: 'auto', cursor: 'pointer', transition: 'all 0.5s', backfaceVisibility: 'visible', boxShadow: isSlabMode ? "inset 0 0 5px rgba(0,0,0,0.1)" : "none" }} /> );
                };
                if (curve) {
                    const cp = { x: curve.x * scale, y: curve.y * scale }; let prevP = p1;
                    for(let k=1; k<=segmentsForCurve; k++) { const t = k / segmentsForCurve; const tx = (1-t)*(1-t)*p1.x + 2*(1-t)*t*cp.x + t*t*p2.x; const ty = (1-t)*(1-t)*p1.y + 2*(1-t)*t*cp.y + t*t*p2.y; const currP = { x: tx, y: ty }; generateWallSeg(prevP, currP, `${i}-${k}`); prevP = currP; }
                } else { generateWallSeg(p1, p2, i); }
            }
            // Lift stroke faces slightly to avoid z-fighting
            const topFaceStyle = { ...face(contW, contH, bCx, bCy, thickness, 0, 0, 0, highlightBg, 'none', finalOpacity + 0.1), clipPath: clipPath, filter: isSelected ? 'brightness(1.1)' : 'none' };
            const strokeFaceStyle = { ...face(contW, contH, bCx, bCy, thickness + 0.5, 0, 0, 0, 'transparent', 'none', 1), pointerEvents: 'none' };
            const bottomStrokeFaceStyle = { ...face(contW, contH, bCx, bCy, 0, 0, 0, 0, 'transparent', 'none', 1), pointerEvents: 'none' };
            const bottomFaceStyle = { ...face(contW, contH, bCx, bCy, 0, 0, 0, 0, highlightBg, 'none', finalOpacity), clipPath: clipPath };
            return ( <div className="absolute" onClick={onClick} style={{ left: '50%', top: '50%', width: 0, height: 0, transformStyle: 'preserve-3d', transform: `translate3d(${x}px, ${y}px, ${z}px) rotateZ(${rotation || 0}deg)`, animation: animate ? `riseUp 0.8s ease-out ${delay}ms backwards` : 'none', '--tx': `${x}px`, '--ty': `${y}px`, '--tz': `${z}px` }}> 
                {walls} 
                <div style={{...topFaceStyle, backfaceVisibility: 'hidden'}} className="hover:brightness-110" />
                {showStroke && (
                    <div style={strokeFaceStyle}>
                        <svg width={contW} height={contH} viewBox={`0 0 ${contW} ${contH}`} style={{position:'absolute', left:0, top:0, overflow:'visible'}}>
                            <path d={d} fill="none" stroke={displayBorder} strokeWidth="2" vectorEffect="non-scaling-stroke"/>
                        </svg>
                    </div>
                )}
                <div style={bottomFaceStyle} /> 
                {showStroke && (
                    <div style={bottomStrokeFaceStyle}>
                        <svg width={contW} height={contH} viewBox={`0 0 ${contW} ${contH}`} style={{position:'absolute', left:0, top:0, overflow:'visible'}}>
                            <path d={d} fill="none" stroke={displayBorder} strokeWidth="2" vectorEffect="non-scaling-stroke"/>
                        </svg>
                    </div>
                )}
            </div> );
        }
        const topFaceStyle = { ...face(width, depth, 0, 0, thickness, 0, 0, 0, highlightBg, finalBorder, finalOpacity + 0.1), filter: isSelected ? 'brightness(1.1)' : 'none' };
        return ( <div className="absolute" onClick={onClick} style={{ left: '50%', top: '50%', width: 0, height: 0, transformStyle: 'preserve-3d', transform: `translate3d(${x}px, ${y}px, ${z}px) rotateZ(${rotation || 0}deg)`, transformOrigin: `calc(50% + ${pivotX}px) calc(50% - ${pivotY}px)`, animation: animate ? `riseUp 0.8s ease-out ${delay}ms backwards` : 'none', '--tx': `${x}px`, '--ty': `${y}px`, '--tz': `${z}px` }}> <div style={face(width, thickness, 0, depth/2, thickness/2, 90, 0, 0, highlightBg, finalBorder, finalOpacity)} /> <div style={face(width, thickness, 0, -depth/2, thickness/2, -90, 0, 0, highlightBg, finalBorder, finalOpacity)} /> <div style={face(depth, thickness, width/2, 0, thickness/2, 0, 90, 90, highlightBg, finalBorder, finalOpacity)} /> <div style={face(depth, thickness, -width/2, 0, thickness/2, 0, 90, -90, highlightBg, finalBorder, finalOpacity)} /> <div style={topFaceStyle} className="hover:brightness-110" /> <div style={face(width, depth, 0, 0, 0, 0, 0, 0, highlightBg, finalBorder, finalOpacity)} /> </div> );
      });

      const PlanAnalysis2D = ({ layers, baseWidthM, baseDepthM, onSelectFloor, selectedFloorId, isDarkMode, onUpdateSetting, floorSettings, inputs, scale3d, basements, onToggleBasement, activeBasementArea, totalAllowedArea, showCheckLines, volumeLimit, parkingOn1F, onToggleParkingLocation, onClose, basePoints, baseCurves, onAddRoad, excavationPoints, excavationCurves, frontageIndices, onUpdateFrontageIndices, onAddFloor, onRemoveFloor, edgeTypes, onUpdateEdgeTypes, view, onUpdateView, onUpdateInputs, onUpdateRoads, onEditEnd }) => {
          
          // 1. Calculate Default Points (Temporary display only)
          const defaultBasePts = useMemo(() => {
              const w = baseWidthM;
              const d = baseDepthM;
              return [{x: -w/2, y: -d/2}, {x: w/2, y: -d/2}, {x: w/2, y: d/2}, {x: -w/2, y: d/2}];
          }, [baseWidthM, baseDepthM]);

          // Use default points if explicit basePoints are null, to prevent 3D state change
          const currentBasePoints = basePoints || defaultBasePts;

          let displayLayer = null;
          if (selectedFloorId === 'base') {
              // Ensure displayLayer always has points so EditMenu2D works without auto-initializing state
              displayLayer = { id: 'base', points: currentBasePoints, realWidth: baseWidthM, realDepth: baseDepthM, realArea: inputs.baseArea, isViolation: false, curves: baseCurves };
          } else if (selectedFloorId === 'excavation') {
               const defaultExcavationW = baseWidthM * Math.sqrt(inputs.excavationRatio/100); const defaultExcavationD = baseDepthM * Math.sqrt(inputs.excavationRatio/100);
               displayLayer = { id: 'excavation', points: excavationPoints, realWidth: defaultExcavationW, realDepth: defaultExcavationD, realArea: excavationPoints ? calculatePolygonArea(excavationPoints) : (defaultExcavationW * defaultExcavationD), isViolation: false, curves: excavationCurves };
          } else if (selectedFloorId) { displayLayer = layers.find(l => l.id === selectedFloorId); }

          const [containerSize, setContainerSize] = useState({ w: 800, h: 600 });
          useEffect(() => { const updateSize = () => { setContainerSize({ w: window.innerWidth, h: window.innerHeight * 0.7 }); }; updateSize(); window.addEventListener('resize', updateSize); return () => window.removeEventListener('resize', updateSize); }, []);

          const maxDim = Math.max(baseWidthM, baseDepthM); const padding = 40; 
          const scale = Math.min((containerSize.w - padding * 2) / maxDim, (containerSize.h - padding * 2) / maxDim);
          const baseW = baseWidthM * scale; const baseH = baseDepthM * scale;
          let xPos = 0, yPos = 0;
          if (displayLayer && selectedFloorId !== 'base' && selectedFloorId !== 'excavation') { const shiftX_M = displayLayer.shiftX / scale3d; const shiftY_M = displayLayer.shiftYPx / scale3d; xPos = shiftX_M * scale; yPos = shiftY_M * scale; }
          const containerRef = useRef(null);
          
          const onWheel = (e) => { 
             e.stopPropagation(); e.preventDefault(); 
             
             // Target Zoom (Zoom towards cursor)
             const rect = e.currentTarget.getBoundingClientRect();
             const mouseX = e.clientX - rect.left;
             const mouseY = e.clientY - rect.top;
             const centerX = rect.width / 2;
             const centerY = rect.height / 2;
             
             // Mouse position relative to center
             const mRelX = mouseX - centerX;
             const mRelY = mouseY - centerY;

             const s = Math.exp(-e.deltaY * 0.001); 
             const newK = Math.min(Math.max(0.5, view.k * s), 5); 
             
             // Calculate new translation to keep mouse point fixed
             // NewOffset = OldOffset * Ratio + MousePos * (1 - Ratio)
             const scaleRatio = newK / view.k;
             const newX = view.x * scaleRatio + mRelX * (1 - scaleRatio);
             const newY = view.y * scaleRatio + mRelY * (1 - scaleRatio);
             
             onUpdateView(v => ({ ...v, k: newK, x: newX, y: newY })); 
          };
          
          const [isPanning, setIsPanning] = useState(false);
          const panStart = useRef({ x: 0, y: 0 });

          const handlePanStart = (e) => { if (!isPanning) return; if (selectedPointForEdit) setSelectedPointForEdit(null); if (e.button !== 0 && e.button !== 1) return; panStart.current = { x: e.clientX, y: e.clientY }; e.target.setPointerCapture(e.pointerId); };
          const handlePanMove = (e) => { if (!isPanning) return; const dx = e.clientX - panStart.current.x; const dy = e.clientY - panStart.current.y; onUpdateView(v => ({ ...v, x: v.x + dx, y: v.y + dy })); panStart.current = { x: e.clientX, y: e.clientY }; };
          const handlePanEnd = (e) => { if (e.target && e.target.releasePointerCapture) e.target.releasePointerCapture(e.pointerId); };
          
          const isDragging = useRef(false);
          const lastPos = useRef({ x: 0, y: 0 });
          const dragStartPos = useRef({ x: 0, y: 0 });
          const dragStartPoint = useRef(null);
          
          const [isRoadSelectMode, setIsRoadSelectMode] = useState(false);
          const [interactionMode, setInteractionMode] = useState('none'); 
          const [selectedPointForEdit, setSelectedPointForEdit] = useState(null); 
          const [selectedCurveForEdit, setSelectedCurveForEdit] = useState(null);
          const longPressTimer = useRef(null);
          const [isAreaLocked, setIsAreaLocked] = useState(false); // Task 1 Area Lock
          const lockedAreaRef = useRef(null);

          const handleDragStart = (e) => { if (e.button !== 0) return; if (e.target.dataset.type === 'control-point' || e.target.dataset.type === 'edge-line' || e.target.dataset.type === 'curve-handle') return; e.stopPropagation(); isDragging.current = true; lastPos.current = { x: e.clientX, y: e.clientY }; e.target.setPointerCapture(e.pointerId); setSelectedPointForEdit(null); setSelectedCurveForEdit(null); };
          const handleDragMove = (e) => { if (!isDragging.current) return; if (selectedFloorId === 'base') return; const dxPx = (e.clientX - lastPos.current.x) / view.k; const dyPx = (e.clientY - lastPos.current.y) / view.k; const dxM = dxPx / scale; const dyM = dyPx / scale; if (selectedFloorId === 'excavation') return; onUpdateSetting(displayLayer.id, 'offset_delta', { x: dxM, y: dyM }); lastPos.current = { x: e.clientX, y: e.clientY }; };
          const handleDragEnd = (e) => { isDragging.current = false; e.target.releasePointerCapture(e.pointerId); };

          const draggingPointIdx = useRef(null); const draggingCurveIdx = useRef(null); const [selectedIndices, setSelectedIndices] = useState(new Set()); const [lockedEdgeIndices, setLockedEdgeIndices] = useState(new Set()); const draggingEdgeIdx = useRef(null);

          const handlePointPointerDown = (e, idx) => {
              e.stopPropagation(); e.target.setPointerCapture(e.pointerId);
              let newSelected;
              if (e.shiftKey) { newSelected = new Set(selectedIndices); if (newSelected.has(idx)) { newSelected.delete(idx); draggingPointIdx.current = null; } else { newSelected.add(idx); draggingPointIdx.current = idx; } } else { if (selectedIndices.has(idx) && selectedIndices.size > 1) { newSelected = new Set(selectedIndices); } else { newSelected = new Set([idx]); } draggingPointIdx.current = idx; }
              setSelectedIndices(newSelected); lastPos.current = { x: e.clientX, y: e.clientY }; dragStartPos.current = { x: e.clientX, y: e.clientY }; dragStartPoint.current = displayLayer.points[idx]; 
              setSelectedPointForEdit({ idx, point: displayLayer.points[idx] }); setSelectedCurveForEdit(null);
              // Area Lock Init
              if (isAreaLocked && displayLayer.points) lockedAreaRef.current = calculatePolygonArea(displayLayer.points);
          };

          const handleCurvePointerDown = (e, idx) => { e.stopPropagation(); e.target.setPointerCapture(e.pointerId); draggingCurveIdx.current = idx; lastPos.current = { x: e.clientX, y: e.clientY }; dragStartPos.current = { x: e.clientX, y: e.clientY }; dragStartPoint.current = displayLayer.curves?.[idx] || {x:0, y:0}; setSelectedCurveForEdit(idx); setSelectedPointForEdit(null); };

          const handlePointPointerMove = (e) => {
             if (draggingPointIdx.current === null && draggingEdgeIdx.current === null && draggingCurveIdx.current === null) return;
             e.stopPropagation();
             let dxPx = (e.clientX - lastPos.current.x) / view.k; let dyPx = (e.clientY - lastPos.current.y) / view.k;
             if (e.shiftKey && (draggingPointIdx.current !== null || draggingCurveIdx.current !== null)) { const totalDx = e.clientX - dragStartPos.current.x; const totalDy = e.clientY - dragStartPos.current.y; if (Math.abs(totalDx) > Math.abs(totalDy)) { dyPx = 0; } else { dxPx = 0; } }
             const dxM = dxPx / scale; const dyM = dyPx / scale; 
             let localDx = dxM; let localDy = dyM;
             if (displayLayer.rotation) { const rotRad = -(displayLayer.rotation || 0) * (Math.PI / 180); const cos = Math.cos(rotRad); const sin = Math.sin(rotRad); localDx = dxM * cos - dyM * sin; localDy = dxM * sin + dyM * cos; }

             if (draggingCurveIdx.current !== null) {
                 const currentCurves = { ...(displayLayer.curves || {}) }; const idx = draggingCurveIdx.current; const oldC = currentCurves[idx] || { x:0, y:0 }; currentCurves[idx] = { x: oldC.x + localDx, y: oldC.y + localDy }; onUpdateSetting(displayLayer.id, 'curves', currentCurves);
             } 
             else {
                 let currentPoints = [...displayLayer.points];
                 const indicesToMove = new Set();
                 if (draggingEdgeIdx.current !== null) { indicesToMove.add(draggingEdgeIdx.current); indicesToMove.add((draggingEdgeIdx.current + 1) % currentPoints.length); } else { indicesToMove.add(draggingPointIdx.current); selectedIndices.forEach(idx => indicesToMove.add(idx)); }
                 indicesToMove.forEach(idx => { const p = currentPoints[idx]; const newX = (p.x || 0) + localDx; const newY = (p.y || 0) + localDy; if (!isNaN(newX) && !isNaN(newY)) { currentPoints[idx] = { x: newX, y: newY }; } });
                 
                 // Task 1: Area Lock Logic
                if (isAreaLocked && lockedAreaRef.current) {
                    const newArea = Math.abs(calculatePolygonArea(currentPoints));
                    if (newArea > 0.001) {
                        const scaleFactor = Math.sqrt(Math.abs(lockedAreaRef.current) / newArea);
                         const centroid = getPolygonCentroid(currentPoints);
                         const scaled = scalePolygon(currentPoints, null, scaleFactor, centroid);
                         currentPoints = scaled.points;
                     }
                 }

                 onUpdateSetting(displayLayer.id, 'points', currentPoints);
                 if (draggingPointIdx.current !== null) { setSelectedPointForEdit({ idx: draggingPointIdx.current, point: currentPoints[draggingPointIdx.current] }); }
             }
             lastPos.current = { x: e.clientX, y: e.clientY };
          };

          const handlePointPointerUp = (e) => { 
              draggingPointIdx.current = null; draggingEdgeIdx.current = null; draggingCurveIdx.current = null; 
              if (e && e.target && e.target.releasePointerCapture) { e.target.releasePointerCapture(e.pointerId); }
              if (onEditEnd && selectedFloorId === 'base') { onEditEnd('base', displayLayer.points); }
          };
          const handleEdgeContextMenu = (e, idx) => { e.preventDefault(); e.stopPropagation(); const newLocked = new Set(lockedEdgeIndices); if (newLocked.has(idx)) newLocked.delete(idx); else newLocked.add(idx); setLockedEdgeIndices(newLocked); };
          const handleEdgePointerDown = (e, idx) => { if (isRoadSelectMode && selectedFloorId === 'base') return; longPressTimer.current = setTimeout(() => { handleSegmentEdit(idx); }, 800); if (!lockedEdgeIndices.has(idx)) return; e.stopPropagation(); e.target.setPointerCapture(e.pointerId); draggingEdgeIdx.current = idx; lastPos.current = { x: e.clientX, y: e.clientY }; dragStartPos.current = { x: e.clientX, y: e.clientY }; setSelectedPointForEdit(null); setSelectedCurveForEdit(null); };
          const handleEdgePointerUp = () => { if (longPressTimer.current) clearTimeout(longPressTimer.current); handlePointPointerUp(); };

          const handleSegmentEdit = (idx) => {
              // Ensure we use the current display layer points (default or explicit)
              const pts = displayLayer.points;
              if (!pts) return;
              const p1 = pts[idx]; const p2 = pts[(idx + 1) % pts.length]; const currentLen = Math.hypot(p2.x - p1.x, p2.y - p1.y);
              const newLenStr = prompt(`目前邊長: ${currentLen.toFixed(2)}m\n請輸入新長度 (m):`, currentLen.toFixed(2));
              if (newLenStr !== null) {
                  const newLen = parseFloat(newLenStr);
                  if (!isNaN(newLen) && newLen > 0) {
                      const ratio = newLen / currentLen;
                      const newP2 = { x: p1.x + (p2.x - p1.x) * ratio, y: p1.y + (p2.y - p1.y) * ratio };
                      const newPoints = [...pts]; newPoints[(idx + 1) % pts.length] = newP2; onUpdateSetting(displayLayer.id, 'points', newPoints);
                      if (onEditEnd && selectedFloorId === 'base') { onEditEnd('base', newPoints); }
                  }
              }
          };

          const handleLineClick = (e, idx1, idx2) => {
             e.stopPropagation();
             if (e.shiftKey) { handleSegmentEdit(idx1); return; }
             if (selectedFloorId === 'base') { if (isRoadSelectMode) return; if (interactionMode === 'set_back') { onUpdateEdgeTypes(idx1, 'back'); return; } if (interactionMode === 'set_side') { onUpdateEdgeTypes(idx1, 'side'); return; } }
             const pts = [...displayLayer.points]; const p1 = pts[idx1]; const p2 = pts[idx2]; const newP = { x: (p1.x + p2.x)/2, y: (p1.y + p2.y)/2 };
             const isClosing = (idx2 === 0 && idx1 === pts.length - 1); const insertIdx = isClosing ? pts.length : idx1 + 1;
             pts.splice(insertIdx, 0, newP); onUpdateSetting(displayLayer.id, 'points', pts);
             if (onEditEnd && selectedFloorId === 'base') { onEditEnd('base', pts); }
             
             if (selectedFloorId === 'base') {
                 const newRoads = inputs.roads.map(r => { if (r.edgeIndex === undefined) return r; if (r.edgeIndex >= insertIdx) { return { ...r, edgeIndex: r.edgeIndex + 1 }; } return r; }); onUpdateRoads(newRoads);
                 const newFrontage = new Set(); frontageIndices.forEach(idx => { if (idx >= insertIdx) newFrontage.add(idx + 1); else newFrontage.add(idx); }); onUpdateFrontageIndices(newFrontage);
                 const newEdgeTypes = {}; Object.keys(edgeTypes).forEach(key => { const k = parseInt(key); const type = edgeTypes[k]; if (k >= insertIdx) newEdgeTypes[k + 1] = type; else newEdgeTypes[k] = type; }); 
                 if (edgeTypes[idx1]) newEdgeTypes[insertIdx] = edgeTypes[idx1];
                 onUpdateEdgeTypes(null, newEdgeTypes);
             }
          };

          const handleDeletePoint = (e, idx) => { e.preventDefault(); e.stopPropagation(); const pts = [...displayLayer.points]; if (pts.length <= 3) return; pts.splice(idx, 1); onUpdateSetting(displayLayer.id, 'points', pts); if (selectedPointForEdit?.idx === idx) setSelectedPointForEdit(null); };
          const handlePointEdit = (axis, val) => { if (!selectedPointForEdit) return; const idx = selectedPointForEdit.idx; const pts = [...displayLayer.points]; pts[idx] = { ...pts[idx], [axis]: parseFloat(val) }; onUpdateSetting(displayLayer.id, 'points', pts); setSelectedPointForEdit({ idx, point: pts[idx] }); };
          const generatePath = () => { if (!displayLayer.points) return ""; const pts = displayLayer.points; const curves = displayLayer.curves || {}; let d = `M ${(pts[0].x * scale)} ${(pts[0].y * scale)}`; for (let i = 0; i < pts.length; i++) { const nextP = pts[(i + 1) % pts.length]; const curve = curves[i]; if (curve) { d += ` Q ${(curve.x * scale)} ${(curve.y * scale)}, ${(nextP.x * scale)} ${(nextP.y * scale)}`; } else { d += ` L ${(nextP.x * scale)} ${(nextP.y * scale)}`; } } d += " Z"; return d; };
          const renderCurveHandles = () => { if (!displayLayer.points) return null; return displayLayer.points.map((p, i) => { const nextI = (i + 1) % displayLayer.points.length; const nextP = displayLayer.points[nextI]; const curve = displayLayer.curves?.[i]; const isEdgeSelected = selectedIndices.has(i) && selectedIndices.has(nextI); if (isEdgeSelected || curve) { const cpX = curve ? curve.x : (p.x + nextP.x)/2; const cpY = curve ? curve.y : (p.y + nextP.y)/2; return ( <g key={`curve-${i}`} transform={`translate(${cpX * scale}, ${cpY * scale})`}> <line x1={(p.x - cpX)*scale} y1={(p.y - cpY)*scale} x2={0} y2={0} stroke="#93c5fd" strokeDasharray="3" strokeWidth="1" /> <line x1={(nextP.x - cpX)*scale} y1={(nextP.y - cpY)*scale} x2={0} y2={0} stroke="#93c5fd" strokeDasharray="3" strokeWidth="1" /> <circle data-type="curve-handle" r="6" fill="#f59e0b" stroke="white" strokeWidth="2" className="cursor-crosshair hover:scale-125 transition-transform" onPointerDown={(e) => { if (!curve) { const newCurves = { ...(displayLayer.curves || {}), [i]: {x: cpX, y: cpY} }; onUpdateSetting(displayLayer.id, 'curves', newCurves); } handleCurvePointerDown(e, i); }} onPointerMove={handlePointPointerMove} onPointerUp={handlePointPointerUp} onDoubleClick={(e) => { e.stopPropagation(); const newCurves = { ...(displayLayer.curves || {}) }; delete newCurves[i]; onUpdateSetting(displayLayer.id, 'curves', newCurves); setSelectedCurveForEdit(null); }} /> </g> ) } return null; }); };
          const baseItemScale = 80 / Math.max(baseWidthM, baseDepthM);

          // --- Visualization Logic for Edge Types ---
          const vizPrimaryIndices = new Set();
          const vizSecondaryIndices = new Set();
          if (inputs.roads) {
             inputs.roads.forEach(r => {
                 const indices = new Set();
                 if (r.edgeIndices) r.edgeIndices.forEach(i => indices.add(i));
                 if (r.edgeIndex !== undefined && r.edgeIndex !== "") indices.add(parseInt(r.edgeIndex));
                 if (r.type === 'primary') indices.forEach(i => vizPrimaryIndices.add(i));
                 else indices.forEach(i => vizSecondaryIndices.add(i));
             });
          }
          const vizFrontIndices = new Set();
          if (frontageIndices && frontageIndices.size > 0) {
               frontageIndices.forEach(i => vizFrontIndices.add(i));
          } else {
               vizPrimaryIndices.forEach(i => vizFrontIndices.add(i));
               if (vizPrimaryIndices.size === 0 && vizSecondaryIndices.size > 0) vizSecondaryIndices.forEach(i => vizFrontIndices.add(i));
          }
          const vizCombinedEdgeTypes = { ...edgeTypes };
          vizSecondaryIndices.forEach(idx => {
              if (!vizFrontIndices.has(idx) && !vizCombinedEdgeTypes[idx]) {
                  vizCombinedEdgeTypes[idx] = 'side';
              }
          });

          // Calculate Setback Polygon for Visualization
          const setbackPoly = useMemo(() => {
              // Always use currentBasePoints (which is either explicit or default rect) for visualization
              const pts = selectedFloorId === 'base' ? currentBasePoints : basePoints;

              if (selectedFloorId === 'base' && pts) {
                  const front = parseFloat(inputs.frontYardDepth || 0);
                  const back = parseFloat(inputs.backYardDepth || 0);
                  const side = parseFloat(inputs.sideYardDepth || 0);
                  const res = offsetPolygon(pts, vizCombinedEdgeTypes, { front, back, side }, vizFrontIndices, baseCurves);
                  return res ? res.points : null;
              }
              return null;
          }, [selectedFloorId, basePoints, currentBasePoints, baseCurves, vizCombinedEdgeTypes, vizFrontIndices, inputs.frontYardDepth, inputs.backYardDepth, inputs.sideYardDepth]);
          // ------------------------------------------
          
          return (
              <div className="w-full h-full flex flex-col relative overflow-hidden bg-stone-50" ref={containerRef} onPointerDown={(e) => { e.stopPropagation(); handlePanStart(e); }} onClick={(e) => e.stopPropagation()}>
                  {displayLayer && ( <button onClick={onClose} className="absolute top-4 left-4 p-2 bg-white/90 rounded-full hover:bg-red-50 text-stone-500 hover:text-red-500 z-50 shadow-md border border-stone-200 transition-colors" title="結束編輯"> <Undo2 size={20}/> </button> )}
                  {/* Zoom Buttons for Shape Edit Mode */}
                  <div className="absolute top-4 right-4 z-50 flex flex-col gap-2">
                      <div className="flex flex-col bg-white shadow rounded-lg border border-stone-200 overflow-hidden">
                          <button onClick={() => onUpdateView(v => ({ ...v, k: Math.min(5, v.k * 1.2) }))} className="p-2 hover:bg-stone-50 border-b border-stone-100" title="放大"><ZoomIn size={16}/></button>
                          <button onClick={() => onUpdateView(v => ({ ...v, k: Math.max(0.5, v.k / 1.2) }))} className="p-2 hover:bg-stone-50" title="縮小"><ZoomOut size={16}/></button>
                      </div>
                  </div>
                  {!displayLayer && ( <div className="absolute top-4 left-1/2 -translate-x-1/2 z-50 flex gap-2"> <div className="flex bg-white shadow rounded-full border border-stone-200 overflow-hidden"> <button onClick={onAddFloor} className="px-3 py-1.5 text-xs font-bold hover:bg-stone-50 border-r flex items-center gap-1"><Plus size={12}/> 上層</button> <button onClick={onRemoveFloor} className="px-3 py-1.5 text-xs font-bold hover:bg-stone-50 flex items-center gap-1"><MinusCircle size={12}/> 上層</button> </div> <div className="flex bg-white shadow rounded-full border border-stone-200 overflow-hidden"> <button onClick={() => onUpdateInputs('floorsBelow', inputs.floorsBelow + 1)} className="px-3 py-1.5 text-xs font-bold hover:bg-stone-50 border-r flex items-center gap-1"><Plus size={12}/> 地下</button> <button onClick={() => onUpdateInputs('floorsBelow', Math.max(0, inputs.floorsBelow - 1))} className="px-3 py-1.5 text-xs font-bold hover:bg-stone-50 flex items-center gap-1"><MinusCircle size={12}/> 地下</button> </div> </div> )}
                  {displayLayer ? (
                      <div className={`flex-1 flex items-center justify-center p-0 transition-all duration-300 overflow-hidden cursor-pan ${isPanning ? 'cursor-grabbing' : ''}`} onWheel={onWheel} onPointerDown={handlePanStart} onPointerMove={handlePanMove} onPointerUp={handlePanEnd} onPointerLeave={handlePanEnd}>
                          {selectedPointForEdit && ( <CoordinatePopup point={selectedPointForEdit.point} idx={selectedPointForEdit.idx} onChange={handlePointEdit} scale={view.k} isDarkMode={isDarkMode} /> )}
                          <div className="relative pointer-events-none" style={{ transform: `translate(${view.x}px, ${view.y}px) scale(${view.k})`, transformOrigin: 'center', transition: isPanning ? 'none' : 'transform 0.1s' }}>
                              <svg width={baseW + 400} height={baseH + 400} viewBox={`-${baseW/2 + 200} -${baseH/2 + 200} ${baseW + 400} ${baseH + 400}`} className="overflow-visible shadow-xl bg-white rounded-lg pointer-events-auto">
                                  <rect id="bg-rect" x={-baseW/2 - 200} y={-baseH/2 - 200} width={baseW + 400} height={baseH + 400} fill="transparent" />
                                  {/* Background Layer: Use currentBasePoints (Explicit or Default Rect) */}
                                  {selectedFloorId !== 'base' && ( 
                                     <path d={generateSvgPath(currentBasePoints, baseCurves, scale)} fill={isDarkMode ? "#1e293b" : "#f5f5f4"} stroke={isDarkMode ? "#475569" : "#d6d3d1"} strokeWidth="1" /> 
                                  )}

                                  {selectedFloorId !== 'excavation' && selectedFloorId !== 'base' && excavationPoints && ( <path d={generateSvgPath(excavationPoints, excavationCurves, scale)} fill="none" stroke="#f59e0b" strokeWidth="1" strokeDasharray="4,4" opacity="0.5"/> )}
                                  <g transform={`translate(${xPos}, ${yPos}) rotate(${displayLayer.rotation || 0})`} className="cursor-move" onPointerDown={handleDragStart} onPointerMove={handleDragMove} onPointerUp={handleDragEnd}>
                                      {displayLayer.points ? (
                                          <>
                                              <path d={generatePath()} fill={selectedFloorId === 'excavation' ? "rgba(245, 158, 11, 0.1)" : (displayLayer.isViolation ? "rgba(239, 68, 68, 0.5)" : (selectedFloorId === 'base' ? "#f5f5f4" : (isDarkMode ? "#38bdf8" : "#0ea5e9")))} stroke={selectedFloorId === 'excavation' ? "#f59e0b" : (displayLayer.isViolation ? "#ef4444" : (selectedFloorId === 'base' ? "#78716c" : "#0284c7"))} strokeWidth={selectedFloorId === 'excavation' ? "2" : "2"} strokeDasharray={selectedFloorId === 'excavation' ? "4,2" : "none"} opacity="0.9" />
                                              {displayLayer.points.map((p, i) => {
                                                  const nextI = (i + 1) % displayLayer.points.length; const nextP = displayLayer.points[nextI]; const isLocked = lockedEdgeIndices.has(i); const curve = displayLayer.curves?.[i];
                                                  const isFrontage = selectedFloorId === 'base' && vizFrontIndices.has(i);
                                                  const isBack = selectedFloorId === 'base' && vizCombinedEdgeTypes[i] === 'back'; const isSide = selectedFloorId === 'base' && vizCombinedEdgeTypes[i] === 'side';
                                                  let strokeColor = (isLocked ? "#ef4444" : "transparent"); if (isFrontage) strokeColor = "#ef4444"; else if (isBack) strokeColor = "#10b981"; else if (isSide) strokeColor = "#3b82f6";
                                                  const strokeWidth = (isFrontage || isBack || isSide) ? "4" : (isLocked ? "3" : "15"); const opacity = (isFrontage || isBack || isSide) ? 0.8 : 1;
                                                  let edgeD = `M ${p.x * scale} ${p.y * scale}`; if (curve) { edgeD += ` Q ${curve.x * scale} ${curve.y * scale}, ${nextP.x * scale} ${nextP.y * scale}`; } else { edgeD += ` L ${nextP.x * scale} ${nextP.y * scale}`; }
                                                  const roadNames = inputs.roads.filter(r => (r.edgeIndices || []).includes(i) || r.edgeIndex === i).map(r => r.name).join(', ');
                                                  // Task 5: Edge Index Label
                                                  const midX = curve ? (0.25*p.x + 0.5*curve.x + 0.25*nextP.x) : (p.x + nextP.x)/2;
                                                  const midY = curve ? (0.25*p.y + 0.5*curve.y + 0.25*nextP.y) : (p.y + nextP.y)/2;
                                                  return ( <g key={`line-group-${i}`}> {(isFrontage || isBack || isSide) && ( <path d={edgeD} stroke={isFrontage ? "#fee2e2" : (isBack ? "#d1fae5" : "#dbeafe")} strokeWidth="10" fill="none" strokeLinecap="round" /> )} <path key={`line-${i}`} d={edgeD} data-type="edge-line" stroke={strokeColor} strokeWidth={strokeWidth} fill="none" strokeLinecap="round" strokeOpacity={opacity} className={`${(isLocked || isFrontage || isBack || isSide) ? 'cursor-default' : (isRoadSelectMode || interactionMode !== 'none' ? 'cursor-pointer hover:stroke-indigo-400/50' : 'cursor-crosshair hover:stroke-black/10')}`} onContextMenu={(e) => handleEdgeContextMenu(e, i)} onPointerDown={(e) => isLocked ? handleEdgePointerDown(e, i) : handleEdgePointerDown(e, i)} onPointerUp={handleEdgePointerUp} onPointerMove={handlePointPointerMove} onClick={(e) => (!isLocked || isRoadSelectMode || interactionMode !== 'none') && handleLineClick(e, i, nextI)} /> {isFrontage && !baseCurves?.[i] && ( <text x={(p.x + nextP.x)/2 * scale} y={(p.y + nextP.y)/2 * scale} textAnchor="middle" dominantBaseline="middle" fontSize="8" fontWeight="bold" fill="#b91c1c" pointerEvents="none" className="select-none"> {`${roadNames || "道路"} (${i})`} </text> )} 
                                                  {!isFrontage && <text x={midX * scale} y={midY * scale} textAnchor="middle" dominantBaseline="middle" fontSize="8" fill={isDarkMode ? "#94a3b8" : "#64748b"} className="select-none pointer-events-none font-mono bg-white/50">{i}</text>}
                                                  </g> );
                                              })}
                                              {renderCurveHandles()} {displayLayer.points.map((p, i) => ( <g key={`pt-${i}`} transform={`translate(${p.x * scale}, ${p.y * scale})`}> <circle data-type="control-point" r="6" fill="white" stroke={selectedIndices.has(i) ? "#6366f1" : (selectedFloorId === 'excavation' ? "#f59e0b" : "#0284c7")} strokeWidth={selectedIndices.has(i) ? "3" : "2"} className={`cursor-grab relative ${selectedIndices.has(i) ? 'animate-pulse-ring' : ''}`} onPointerDown={(e) => handlePointPointerDown(e, i)} onPointerMove={handlePointPointerMove} onPointerUp={handlePointPointerUp} onContextMenu={(e) => handleDeletePoint(e, i)} /> </g> ))}
                                          </>
                                      ) : ( <rect x={-(displayLayer.realWidth * scale)/2} y={-(displayLayer.realDepth * scale)/2} width={displayLayer.realWidth * scale} height={displayLayer.realDepth * scale} fill={displayLayer.isViolation ? "rgba(239, 68, 68, 0.5)" : (isDarkMode ? "#38bdf8" : "#0ea5e9")} stroke={displayLayer.isViolation ? "#ef4444" : "#0284c7"} strokeWidth="2" opacity="0.9" /> )}
                                      {selectedFloorId !== 'base' && <circle cx={(displayLayer.pivot?.x || 0) * scale} cy={(displayLayer.pivot?.y || 0) * scale} r="4" fill="#ef4444" stroke="white" strokeWidth="1" />}
                                  </g>
                              </svg>
                          </div>
                      </div>
                  ) : (
                    <div className="w-full h-full overflow-y-auto p-4 pt-16 overscroll-contain" style={{ overscrollBehaviorX: 'contain' }}>
                      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 pb-20">
                          <div onClick={() => onSelectFloor('base')} className={`aspect-square rounded-xl border-2 transition-all cursor-pointer flex flex-col items-center justify-center relative bg-stone-50 hover:bg-white hover:shadow hover:border-indigo-400 ${isDarkMode ? 'bg-slate-800/50 border-slate-700 hover:bg-slate-700' : 'border-stone-200'}`}>
                              <span className="absolute top-2 left-2 text-xs font-bold text-stone-500 bg-stone-100 px-1.5 rounded">基地</span>
                              <svg width={100} height={100} viewBox={`-${baseWidthM*baseItemScale/2+20} -${baseDepthM*baseItemScale/2+20} ${baseWidthM*baseItemScale+40} ${baseDepthM*baseItemScale+40}`} className="overflow-visible"> {currentBasePoints ? ( <> <path d={generateSvgPath(currentBasePoints, baseCurves, baseItemScale)} fill="none" stroke={isDarkMode ? "#cbd5e1" : "#475569"} strokeWidth="2" /> </> ) : ( <> <rect x={-baseWidthM*baseItemScale/2} y={-baseDepthM*baseItemScale/2} width={baseWidthM*baseItemScale} height={baseDepthM*baseItemScale} fill="none" stroke={isDarkMode ? "#cbd5e1" : "#475569"} strokeWidth="2" /> </> )} </svg>
                              <div className="absolute bottom-2 text-[10px] text-stone-400 font-mono">{formatNum(inputs.baseArea)}m²</div>
                          </div>
                          <div onClick={() => onSelectFloor('excavation')} className={`aspect-square rounded-xl border-2 border-dashed transition-all cursor-pointer flex flex-col items-center justify-center relative bg-amber-50/50 hover:bg-white hover:shadow hover:border-amber-400 ${isDarkMode ? 'bg-slate-800/50 border-slate-700 hover:bg-slate-700' : 'border-amber-200'}`}>
                              <span className="absolute top-2 left-2 text-xs font-bold text-amber-600 bg-amber-100 px-1.5 rounded">開挖範圍</span> <div className="text-amber-300 mb-2"><Shovel size={24}/></div> <div className="text-xs text-stone-500 font-bold">設定開挖邊界</div> {excavationPoints && <div className="text-[10px] text-stone-400 mt-1">自訂形狀已啟用</div>}
                          </div>
                          {basements.map((b, i) => { if (!b.active) return null; const baseDim = 100; const scale = baseDim / Math.max(baseWidthM, baseDepthM); const baseW = baseWidthM * scale; const baseH = baseDepthM * scale; let pts = excavationPoints; if (!pts && basePoints) { const scaleRate = Math.sqrt(inputs.excavationRatio / 100); const { points: newPts } = scalePolygon(basePoints, baseCurves, scaleRate); pts = newPts; } return ( <div key={b.id} onClick={() => onSelectFloor(b.id)} className={`aspect-square rounded-xl border-2 transition-all cursor-pointer flex flex-col items-center justify-center relative bg-white/50 hover:bg-white hover:shadow-lg hover:border-indigo-400 ${isDarkMode ? 'bg-slate-800/50 border-slate-700 hover:bg-slate-700' : 'border-stone-200'}`}> <span className="absolute top-2 left-2 text-xs font-bold text-stone-500 bg-stone-100 px-1.5 rounded">{b.id}</span> <svg width={baseDim} height={baseDim} viewBox={`-${baseW/2+10} -${baseH/2+10} ${baseW+20} ${baseH+20}`} className="overflow-visible"> {currentBasePoints ? ( <path d={generateSvgPath(currentBasePoints, baseCurves, scale)} fill="none" stroke={isDarkMode ? "#475569" : "#cbd5e1"} strokeWidth="1" /> ) : ( <rect x={-baseW/2} y={-baseH/2} width={baseW} height={baseH} fill="none" stroke={isDarkMode ? "#475569" : "#cbd5e1"} strokeWidth="1" /> )} <g> {pts ? ( <path d={generateSvgPath(pts, null, scale)} fill={isDarkMode ? "#334155" : "#cbd5e1"} opacity="0.8" /> ) : ( <rect x={-(baseW * Math.sqrt(inputs.excavationRatio/100))/2} y={-(baseH * Math.sqrt(inputs.excavationRatio/100))/2} width={baseW * Math.sqrt(inputs.excavationRatio/100)} height={baseH * Math.sqrt(inputs.excavationRatio/100)} fill={isDarkMode ? "#334155" : "#cbd5e1"} opacity="0.8"/> )} </g> </svg> <div className="absolute bottom-2 text-[10px] text-stone-400 font-mono">{formatNum(toPing(b.area))}坪</div> </div> ); })}
                          {layers.map((layer, idx) => { const baseDim = 100; const scale = baseDim / Math.max(baseWidthM, baseDepthM); const baseW = baseWidthM * scale; const baseH = baseDepthM * scale; const shiftX_M = layer.shiftX / scale3d; const shiftY_M = layer.shiftYPx / scale3d; const xPos = shiftX_M * scale; const yPos = shiftY_M * scale; return ( <div key={layer.id} onClick={() => onSelectFloor(layer.id)} className={`aspect-square rounded-xl border-2 transition-all cursor-pointer flex flex-col items-center justify-center relative bg-white/50 hover:bg-white hover:shadow-lg hover:border-indigo-400 ${isDarkMode ? 'bg-slate-800/50 border-slate-700 hover:bg-slate-700' : 'border-stone-200'}`}> <span className="absolute top-2 left-2 text-xs font-bold text-stone-500 bg-stone-100 px-1.5 rounded">{layer.id}</span> {layer.isViolation && <AlertTriangle size={14} className="absolute top-2 right-2 text-red-500" />} <svg width={baseDim} height={baseDim} viewBox={`-${baseW/2+10} -${baseH/2+10} ${baseW+20} ${baseH+20}`} className="overflow-visible"> {currentBasePoints ? ( <path d={generateSvgPath(currentBasePoints, baseCurves, scale)} fill="none" stroke={isDarkMode ? "#475569" : "#cbd5e1"} strokeWidth="1" /> ) : ( <rect x={-baseW/2} y={-baseH/2} width={baseW} height={baseH} fill="none" stroke={isDarkMode ? "#475569" : "#cbd5e1"} strokeWidth="1" /> )} <g transform={`translate(${xPos}, ${yPos}) rotate(${layer.rotation || 0})`}> {layer.points ? ( <path d={generateSvgPath(layer.points, layer.curves, scale)} fill={layer.isViolation ? "#fca5a5" : "#bae6fd"} opacity="0.8" /> ) : ( <rect x={-(layer.realWidth * scale)/2} y={-(layer.realDepth * scale)/2} width={layer.realWidth * scale} height={layer.realDepth * scale} fill={layer.isViolation ? "#fca5a5" : "#bae6fd"} opacity="0.8"/> )} </g> </svg> <div className="absolute bottom-2 text-[10px] text-stone-400 font-mono">{formatNum(toPing(layer.realArea))}坪</div> </div> ); })}
                      </div>
                    </div>
                  )}
                  {displayLayer && ( <EditMenu2D data={displayLayer} isDarkMode={isDarkMode} onUpdateSetting={onUpdateSetting} onReset={(id) => onUpdateSetting(id, 'reset')} isOpen={true} onClose={onClose} scale3d={scale3d} inputs={inputs} basePoints={basePoints} isRoadSelectMode={isRoadSelectMode} onToggleRoadSelectMode={() => setIsRoadSelectMode(!isRoadSelectMode)} interactionMode={interactionMode} setInteractionMode={setInteractionMode} selectedCurveIdx={selectedCurveForEdit} onUpdateRoads={onUpdateRoads} onUpdateInputs={onUpdateInputs} isAreaLocked={isAreaLocked} setIsAreaLocked={setIsAreaLocked} /> )}
              </div>
          );
      };

      const InfoItem = ({ label, value, unit, isDarkMode }) => (
          <div className="flex flex-col">
              <span className={`${isDarkMode ? 'text-slate-400' : 'text-stone-400'} text-[10px]`}>{label}</span>
              <span className={`${isDarkMode ? 'text-slate-200' : 'text-stone-700'} font-bold text-sm whitespace-nowrap`}>{value} <span className="text-[10px] font-normal opacity-70">{unit}</span></span>
          </div>
      );

      const LegendItem = ({ color, label, value, textColor, valueColor, type = 'box' }) => (
          <div className="flex items-center gap-2">
              {type === 'line' ? (
                   <div className={`w-4 h-0.5 ${color.replace('bg-', 'bg-')}`}></div>
              ) : (
                   <div className={`w-3 h-3 rounded-sm border ${color}`}></div>
              )}
              <div className="flex flex-col leading-none">
                  <span className={`text-[10px] font-bold ${textColor}`}>{label}</span>
                  {value && <span className={`text-[10px] ${valueColor}`}>{value}</span>}
              </div>
          </div>
      );

      const Visualizer3D = ({ inputs, res, onUpdateBaseDim, onResetAll, onUpdateRoads, onUpdateInputs, showCheckLines, setShowCheckLines, showWeiLao, setShowWeiLao, isConstraintMode, setIsConstraintMode }) => {
  const [animate, setAnimate] = useState(false);
  const [isDarkMode, setIsDarkMode] = useState(false);
  // Internal constraint mode state removed (lifted to parent) 
        const [viewMode, setViewMode] = useState('3d');
        const [selectedFloor, setSelectedFloor] = useState(null);
        const [focusOffset, setFocusOffset] = useState({ x: 0, y: 0, z: 0 });
        const [floorSettings, setFloorSettings] = useState({});
        const floorsBelow = Math.max(0, parseInt(inputs.floorsBelow) || 0);
        const [basementState, setBasementState] = useState({}); 
        const [parkingOn1F, setParkingOn1F] = useState(true);
        const volumeLimit = res.totalCFA;
        const carsPerBasement = (res.basementAreaPerFloor || 0) / (inputs.avgCarArea || 35);
        const recommendedBasementCount = carsPerBasement > 0 ? Math.ceil(res.statutoryParking / carsPerBasement) : 0;
        
        const [basePoints, setBasePoints] = useState(null);
        const [baseCurves, setBaseCurves] = useState(null); 
        const [excavationPoints, setExcavationPoints] = useState(null);
        const [excavationCurves, setExcavationCurves] = useState(null);
        const [manualFloorsOverride, setManualFloorsOverride] = useState(null);
        
        const [frontageIndices, setFrontageIndices] = useState(new Set());
        const [edgeTypes, setEdgeTypes] = useState({}); 

        const [view2D, setView2D] = useState({ x: 0, y: 0, k: 1 });

        const basements = useMemo(() => Array.from({length: floorsBelow}).map((_, i) => ({ id: `B${i+1}`, area: res.basementAreaPerFloor, active: true, recommended: (i + 1) <= recommendedBasementCount })), [floorsBelow, res.basementAreaPerFloor, recommendedBasementCount]);
        const activeBasementArea = basements.filter(b => b.active).reduce((acc, b) => acc + b.area, 0);
        const toggleBasement = (id) => {}; // Removed toggle
        const toggleParkingLocation = () => setParkingOn1F(prev => !prev);
        
        useEffect(() => {
             if (selectedFloor && selectedFloor.id.startsWith('B')) {
                 const bNum = parseInt(selectedFloor.id.substring(1));
                 if (bNum > floorsBelow) setSelectedFloor(null);
             }
        }, [floorsBelow]);
        
        useEffect(() => {
            if (basePoints) {
                const scaleRate = Math.sqrt(inputs.excavationRatio / 100);
                const { points: newPts, curves: newCurves } = scalePolygon(basePoints, baseCurves, scaleRate);
                setExcavationPoints(newPts);
                setExcavationCurves(newCurves); 
            }
        }, [basePoints, baseCurves, inputs.excavationRatio]);

        const toggleConstraints = () => { setIsConstraintMode(!isConstraintMode); if (!isConstraintMode) setShowCheckLines(true); };
        const [rotationZ, setRotationZ] = useState(-45);
        const [viewAngleX, setViewAngleX] = useState(58);
        const [zoom, setZoom] = useState(1);
        const [isDragging, setIsDragging] = useState(false);
        const lastMousePos = useRef({ x: 0, y: 0 });
        const lastPinchDist = useRef(null); 
        const viewportRef = useRef(null);
        const [isMobile, setIsMobile] = useState(false);
        const [isSummaryOpen, setIsSummaryOpen] = useState(true);
        const isLandscapeMode = isMobile && !isSummaryOpen;
        const rafRef = useRef(null);

        useEffect(() => { const checkMobile = () => setIsMobile(window.innerWidth < 768); checkMobile(); window.addEventListener('resize', checkMobile); return () => window.removeEventListener('resize', checkMobile); }, []);
        useEffect(() => { setAnimate(true); const timer = setTimeout(() => setAnimate(false), 1000); return () => clearTimeout(timer); }, [res.floorsAbove]);

        useEffect(() => {
          const element = viewportRef.current;
          if (!element) return;
          const handleNativeWheel = (e) => { 
              if(e.cancelable) e.preventDefault(); 
              e.stopPropagation(); 
              const sensitivity = 0.002; 
              const delta = -e.deltaY * sensitivity; 
              
              if (viewMode === '2d') {
                  setView2D(v => {
                      const newK = Math.min(5, Math.max(0.5, v.k + delta * 200)); // Adjusted sensitivity for 2D
                      return { ...v, k: newK };
                  });
              } else {
                  setZoom(prev => Math.min(3, Math.max(0.2, prev + delta))); 
              }
          };
          element.addEventListener('wheel', handleNativeWheel, { passive: false });
          return () => element.removeEventListener('wheel', handleNativeWheel);
        }, [viewMode]); 
        
        const getTouchDistance = (touches) => Math.hypot(touches[0].pageX - touches[1].pageX, touches[0].pageY - touches[1].pageY);
        const handleMouseDown = (e) => { if (viewMode === '2d') return; setIsDragging(true); lastMousePos.current = { x: e.clientX, y: e.clientY }; };
        const handleTouchStart = (e) => {
          if (viewMode === '2d') return;
          if (e.touches.length === 2) { lastPinchDist.current = getTouchDistance(e.touches); setIsDragging(false); } 
          else if(e.touches.length === 1) { setIsDragging(true); lastMousePos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY }; }
        };
        const handleMouseMove = (e) => {
          if (!isDragging) return;
          const deltaX = e.clientX - lastMousePos.current.x;
          const deltaY = e.clientY - lastMousePos.current.y;
          let effectiveDeltaX = isLandscapeMode ? deltaY : deltaX;
          let effectiveDeltaY = isLandscapeMode ? -deltaX : deltaY;
          setRotationZ(prev => prev + effectiveDeltaX * 0.5);
          setViewAngleX(prev => Math.min(85, Math.max(10, prev - effectiveDeltaY * 0.5)));
          lastMousePos.current = { x: e.clientX, y: e.clientY };
        };
        const handleTouchMove = (e) => {
          if (e.touches.length === 2 && lastPinchDist.current !== null) { 
              const currentDist = getTouchDistance(e.touches); 
              const delta = currentDist - lastPinchDist.current; 
              if (viewMode === '2d') {
                  setView2D(v => ({ ...v, k: Math.min(5, Math.max(0.5, v.k + delta * 0.005)) }));
              } else {
                  setZoom(prev => Math.min(3, Math.max(0.2, prev + delta * 0.005))); 
              }
              lastPinchDist.current = currentDist; 
              return; 
          }
          if (!isDragging || e.touches.length !== 1) return;
          if (rafRef.current) return;
          const clientX = e.touches[0].clientX; const clientY = e.touches[0].clientY;
          rafRef.current = requestAnimationFrame(() => {
              const deltaX = clientX - lastMousePos.current.x; const deltaY = clientY - lastMousePos.current.y; let effectiveDeltaX = isLandscapeMode ? deltaY : deltaX; let effectiveDeltaY = isLandscapeMode ? -deltaX : deltaY; setRotationZ(prev => prev + effectiveDeltaX * 0.5); setViewAngleX(prev => Math.min(85, Math.max(10, prev - effectiveDeltaY * 0.5))); lastMousePos.current = { x: clientX, y: clientY }; rafRef.current = null;
          });
        };
        const handleMouseUp = () => { setIsDragging(false); lastPinchDist.current = null; };
        const handleZoomIn = () => { if (viewMode === '2d') { setView2D(v => ({ ...v, k: Math.min(5, v.k * 1.2) })); } else { setZoom(prev => Math.min(3, prev + 0.2)); } };
        const handleZoomOut = () => { if (viewMode === '2d') { setView2D(v => ({ ...v, k: Math.max(0.5, v.k / 1.2) })); } else { setZoom(prev => Math.max(0.2, prev - 0.2)); } };
        const handleLayerClick = (e, layer) => { e.stopPropagation(); if (selectedFloor && selectedFloor.id === layer.id) return; const settings = floorSettings[layer.id] || {}; setSelectedFloor({ ...layer, rotation: layer.rotation || 0, pivot: settings.pivot || { x: 0, y: 0 }, alignment: settings.alignment || { x: 'left', y: 'back' }, violations: layer.violations || [], points: settings.points || null, curves: settings.curves || null }); const targetZ = layer.z + layer.height * 0.5; setFocusOffset({ x: -layer.shiftX, y: -layer.shiftYPx, z: -targetZ }); setZoom(2.5); };
        const handleBgClick = () => { if (selectedFloor) { setSelectedFloor(null); } }; 
        const toggleFullscreen = () => { if (isSummaryOpen) { setIsSummaryOpen(false); } else { setIsSummaryOpen(true); } };

        const updateFloorSetting = (floorId, field, value) => {
           if (isConstraintMode) return; 
           if (floorId === 'base') {
                if (field === 'points') {
                    setBasePoints(value);
                    if (value) {
                         setFloorSettings(prev => { const next = { ...prev }; Object.keys(next).forEach(k => { if (k !== 'base') { delete next[k].points; delete next[k].curves; delete next[k].manualArea; delete next[k].manualDim; delete next[k].width; delete next[k].depth; } }); return next; });
                         setExcavationPoints(null); setExcavationCurves(null);
                    }
                } else if (field === 'curves') { setBaseCurves(value); } else if (field === 'reset') { setBasePoints(null); setBaseCurves(null); setFrontageIndices(new Set()); setEdgeTypes({}); }
                return;
           }
           if (floorId === 'excavation') { if (field === 'points') setExcavationPoints(value); if (field === 'reset') { setExcavationPoints(null); setExcavationCurves(null); } return; }
           if (field === 'reset') { setFloorSettings(prev => { const copy = {...prev}; delete copy[floorId]; return copy; }); return; }
           setFloorSettings(prev => { const current = prev[floorId] || {}; let newData = { ...current }; if (field.startsWith('align_')) { const axis = field.split('_')[1]; const alignment = { ...(current.alignment || { x: 'left', y: 'back' }), [axis]: value }; newData.alignment = alignment; } else if (field.startsWith('pivot')) { const axis = field === 'pivotX' ? 'x' : 'y'; const pivot = { ...(current.pivot || { x: 0, y: 0 }), [axis]: value }; newData.pivot = pivot; } else if (field === 'area') { newData.area = value; newData.manualArea = true; } else if (field === 'points') { if (value && value.length >= 3) { let area = calculatePolygonArea(value); newData.area = area; newData.manualArea = true; } newData.points = value; } else if (field === 'curves') { newData.curves = value; } else if (field === 'offset_delta') { const currentOff = current.offset || { x: 0, y: 0 }; newData.offset = { x: currentOff.x + value.x, y: currentOff.y + value.y }; } else { newData[field] = value; if (field === 'width' || field === 'depth') newData.manualDim = true; } return { ...prev, [floorId]: newData }; });
        };
        
        const handleBaseEditEnd = (floorId, points) => {
             if (floorId === 'base' && points) {
                 const area = calculatePolygonArea(points);
                 const currentArea = parseFloat(inputs.baseArea || 0);
                 if (Math.abs(area - currentArea) > 0.01) {
                     onUpdateBaseDim('baseArea', parseFloat(area.toFixed(2)));
                 }
                 const xs = points.map(p => p.x); const w = Math.max(...xs) - Math.min(...xs); 
                 const currentW = parseFloat(inputs.baseWidth || 0);
                 if (Math.abs(w - currentW) > 0.01) {
                     onUpdateInputs('baseWidth', parseFloat(w.toFixed(2)));
                 }
             }
        };

        const resetFloor = (floorId) => { setFloorSettings(prev => { const copy = { ...prev }; delete copy[floorId]; return copy; }); };
        useEffect(() => { if (selectedFloor) { const layer = massingLayers.layers.find(l => l.id === selectedFloor.id); if (layer) { setSelectedFloor({ ...layer, rotation: floorSettings[layer.id]?.rotation || 0, pivot: floorSettings[layer.id]?.pivot || { x: 0, y: 0 }, alignment: floorSettings[layer.id]?.alignment || { x: 'left', y: 'back' }, violations: layer.violations, points: floorSettings[layer.id]?.points || null, curves: floorSettings[layer.id]?.curves || null }); } } }, [floorSettings, isConstraintMode]);

        const updateEdgeTypes = (index, type) => { setEdgeTypes(prev => { if (index === null && typeof type === 'object') { return type; } const next = { ...prev }; if (next[index] === type) { delete next[index]; } else { next[index] = type; } return next; }); };

        const canvasSize = isMobile ? (isLandscapeMode ? 320 : 200) : 280; 
        const baseWidthM = parseFloat(inputs.baseWidth) > 0 ? parseFloat(inputs.baseWidth) : Math.sqrt(inputs.baseArea || 100);
        let baseDepthM = (inputs.baseArea || 100) / baseWidthM;
        if (basePoints && basePoints.length > 0) { const ys = basePoints.map(p => p.y); const bboxH = Math.max(...ys) - Math.min(...ys); if (bboxH > baseDepthM) baseDepthM = bboxH; }
        
        const scale = canvasSize / Math.max(baseWidthM, baseDepthM);
        const w = baseWidthM * scale;
        const d = baseDepthM * scale;
        const frontM = parseFloat(inputs.frontYardDepth) || 0;
        const backM = parseFloat(inputs.backYardDepth) || 0;
        const sideM = parseFloat(inputs.sideYardDepth) || 0;
        const sideDir = inputs.sideYardDirection || 'right';
        const roadW_M = parseFloat(inputs.roads.find(r => r.type === 'primary')?.width || inputs.roads[0]?.width || 6);
        const byRatio = parseFloat(inputs.minBackyardDepthRatio) || 0;
        const arcadeM = (inputs.frontYardDepth == 0 && inputs.arcadeDepth) ? parseFloat(inputs.arcadeDepth) : 0; 
        const frontPx = frontM * scale; const backPx = backM * scale; const sidePx = sideM * scale; const roadW_Px = roadW_M * scale; const shiftX = sideDir === 'left' ? (sidePx / 2) : (-sidePx / 2);

          const handleAddFloor = () => { 
    if (massingLayers.currentTotalUsed >= res.totalCFA) {
        alert("已達最大允建總樓地板面積 (Total CFA) 上限，無法新增樓層。");
        return;
    }
              setManualFloorsOverride((prev) => (prev !== null ? prev : massingLayers.totalFloors) + 1); 
          };
        const handleRemoveFloor = () => { const newFloorsAbove = Math.max(1, (manualFloorsOverride !== null ? manualFloorsOverride : massingLayers.totalFloors) - 1); setManualFloorsOverride(newFloorsAbove); onUpdateInputs('floorsAbove', newFloorsAbove); if (selectedFloor && !['base', 'excavation'].includes(selectedFloor.id)) { const floorNum = parseInt(selectedFloor.id); if (!isNaN(floorNum) && floorNum > newFloorsAbove) { setSelectedFloor(null); } } };

        const massingLayers = useMemo(() => {
            const layers = [];
            const limitCFA = res.totalCFA;
            
            // Task 2: Taxable Basement Area (Assuming Total CFA is fixed limit)
            const taxableBasementArea = Math.max(0, activeBasementArea - res.exemptBasement);
            const availableForSuperstructure = Math.max(0, limitCFA - taxableBasementArea);
            
            let remainingAreaM2 = availableForSuperstructure; 
            
            let currentZM = 0;
            let floorCount = 0;
            let currentTotalUsed = taxableBasementArea; 
            
            const maxSimulatedFloors = manualFloorsOverride !== null ? manualFloorsOverride : 100;
            const buildBackM = backM;
            const buildFrontM = baseDepthM - frontM;
            const buildWidthM = Math.max(0, baseWidthM - sideM);
            const originHeightRatioY = baseDepthM + roadW_M; 
            const originWeiLaoY = baseDepthM + roadW_M / 2;
            
            let oneFFootprint = null;

            // Filter frontageIndices: Primary -> Front, Secondary -> Side (unless manually overridden)
            const primaryIndices = new Set();
            const secondaryIndices = new Set();
            
            if (inputs.roads) {
                inputs.roads.forEach(r => {
                    const indices = new Set();
                    if (r.edgeIndices) r.edgeIndices.forEach(i => indices.add(i));
                    if (r.edgeIndex !== undefined && r.edgeIndex !== "") indices.add(parseInt(r.edgeIndex));
                    
                    if (r.type === 'primary') {
                        indices.forEach(i => primaryIndices.add(i));
                    } else {
                        indices.forEach(i => secondaryIndices.add(i));
                    }
                });
            }

            const effectiveFrontIndices = new Set();
            
            if (frontageIndices && frontageIndices.size > 0) {
                 // Manual Mode: Trust user selection for "Front"
                 frontageIndices.forEach(i => effectiveFrontIndices.add(i));
            } else {
                 // Auto Mode: Primary Roads are Front
                 primaryIndices.forEach(i => effectiveFrontIndices.add(i));
                 
                 // Fallback: If no primary roads, treat all secondary roads as Front
                 if (primaryIndices.size === 0 && secondaryIndices.size > 0) {
                      secondaryIndices.forEach(i => effectiveFrontIndices.add(i));
                 }
            }

            // Prepare combined edge types (Secondary -> Side)
            const combinedEdgeTypes = { ...edgeTypes };
            secondaryIndices.forEach(idx => {
                // Only mark as side if NOT in effectiveFrontIndices and NOT already set (e.g. Back)
                if (!effectiveFrontIndices.has(idx) && !combinedEdgeTypes[idx]) {
                    combinedEdgeTypes[idx] = 'side';
                }
            });

            if (basePoints) { 
                const res = offsetPolygon(basePoints, combinedEdgeTypes, { front: frontM, back: backM, side: sideM }, effectiveFrontIndices, baseCurves); 
                oneFFootprint = res ? res.points : null;
            }
            let oneFFootprintArea = 0;
            if (oneFFootprint) { oneFFootprintArea = calculatePolygonArea(oneFFootprint); } else { oneFFootprintArea = buildWidthM * (Math.max(0, buildFrontM - buildBackM)); }

            const targetFloors = res.floorsAbove;
            let finalFootprintPoints = oneFFootprint;
            let finalFootprintArea = oneFFootprintArea;
            const effectiveAvgAllowed = availableForSuperstructure / targetFloors;

            if (oneFFootprintArea > effectiveAvgAllowed && effectiveAvgAllowed > 0) {
                if (oneFFootprint) {
                    const scaleFactor = Math.sqrt(effectiveAvgAllowed / oneFFootprintArea);
                    const polyCentroid = getPolygonCentroid(oneFFootprint);
                    const { points: scaledPts, curves: scaledCurves } = scalePolygon(oneFFootprint, null, scaleFactor, polyCentroid);
                    finalFootprintPoints = scaledPts;
                    finalFootprintArea = effectiveAvgAllowed;
                } else {
                   const scaleFactor = Math.sqrt(effectiveAvgAllowed / oneFFootprintArea);
                   // Approximating for box
                   finalFootprintArea = effectiveAvgAllowed;
                }
            }

            while ((remainingAreaM2 > 0.1 || floorCount < res.floorsAbove) && floorCount < maxSimulatedFloors) {
                if (remainingAreaM2 <= 0.1 && manualFloorsOverride === null) break;
                const floorId = `${floorCount + 1}F`;
                const settings = floorSettings[floorId] || {};
                const h = (floorCount === 0) ? (parseFloat(inputs.floorHeight1F) || 4.2) : (parseFloat(inputs.floorHeightOther) || 3.6);
                const checkZ = currentZM + h;
                
                // --- Dynamic Setback Calculation ---
                let currentFrontM = frontM;
                let currentBackM = backM;
                if (floorCount === 0 && arcadeM > 0) currentFrontM = Math.max(currentFrontM, arcadeM);

                if (isConstraintMode) {
                     // Height Ratio: H <= (Setback + RoadW) * 3.6 => Setback >= (H / 3.6) - RoadW
                     const reqDist = (checkZ / 3.6) - roadW_M;
                     if (reqDist > currentFrontM) currentFrontM = reqDist;

                     // Min Backyard Ratio: H <= Setback * Ratio => Setback >= H / Ratio
                     if (byRatio > 0) {
                        const reqBack = checkZ / byRatio;
                        if (reqBack > currentBackM) currentBackM = reqBack;
                     }

                     if (showWeiLao) {
                         // WeiLao: H <= (Setback + RoadW/2) * 5.0 => Setback >= (H / 5.0) - RoadW/2
                         const reqDistWeiLao = (checkZ / 5.0) - (roadW_M / 2);
                         if (reqDistWeiLao > currentFrontM) currentFrontM = reqDistWeiLao;
                     }
                }

                // Recalculate polygon for this floor
                let floorPolygon = oneFFootprint;
                let floorPolygonArea = oneFFootprintArea;

                // Optimization: If setbacks changed from 1F default, recalculate
                if (basePoints && (currentFrontM > frontM || currentBackM > backM || (floorCount === 0 && arcadeM > 0))) {
                    const res = offsetPolygon(basePoints, combinedEdgeTypes, { front: currentFrontM, back: currentBackM, side: sideM }, effectiveFrontIndices, baseCurves);
                    floorPolygon = res ? res.points : null;
                    floorPolygonArea = floorPolygon ? calculatePolygonArea(floorPolygon) : 0;
                }
                
                // Fallback for Box Mode (approximate)
                const validDepthM = Math.max(0, baseDepthM - currentFrontM - currentBackM);
                const maxFloorAreaM2 = floorPolygon ? floorPolygonArea : (buildWidthM * validDepthM);

                if (maxFloorAreaM2 <= 0.01 && !settings.manualDim && !settings.manualArea) break; 
                
                let visualWidthM = buildWidthM;
                let visualDepthM = validDepthM;
                let rotation = settings.rotation || 0;
                let usedAreaM2 = 0;

                // Determine Area Usage
                if (settings.manualDim && settings.width !== undefined && settings.depth !== undefined) { 
                    visualWidthM = settings.width; visualDepthM = settings.depth; usedAreaM2 = visualWidthM * visualDepthM; 
                } 
                else if (settings.manualArea && settings.area !== undefined) { 
                    usedAreaM2 = settings.area; 
                } 
                else { 
                    // Auto: Fill up to remaining area or max floor area
                    usedAreaM2 = Math.min(remainingAreaM2, maxFloorAreaM2);
                }
                
                if (isConstraintMode) {
                     usedAreaM2 = Math.min(usedAreaM2, maxFloorAreaM2);
                }
                
                // Calculate Final Geometry
                let layerPoints = settings.points || null;
                let layerCurves = settings.curves || null;

                if (!layerPoints && floorPolygon) {
                    layerPoints = floorPolygon;
                    // If we need to scale down (e.g. not enough remaining area)
                    if (usedAreaM2 < floorPolygonArea - 0.1) {
                         const scaleRate = Math.sqrt(usedAreaM2 / floorPolygonArea);
                         const polyCentroid = getPolygonCentroid(floorPolygon);
                         const { points: newPts, curves: newCurves } = scalePolygon(floorPolygon, null, scaleRate, polyCentroid);
                         layerPoints = newPts;
                         layerCurves = newCurves;
                    }
                } else if (!layerPoints) {
                    // Box Mode Scaling
                    const usageRatio = maxFloorAreaM2 > 0 ? usedAreaM2 / maxFloorAreaM2 : 0; 
                    const scaleFactor = Math.sqrt(usageRatio); 
                    visualWidthM = buildWidthM * scaleFactor; 
                    visualDepthM = validDepthM * scaleFactor;
                }

                // Center logic for Box Mode (Shift)
                const limitBackRatio = (byRatio > 0) ? Math.max(buildBackM, checkZ / byRatio) : buildBackM;
                const finalLimitBack = Math.max(buildBackM, limitBackRatio);
                const envelopeCenterY = (finalLimitBack + validDepthM / 2) - (baseDepthM / 2);
                
                const alignPref = settings.alignment || { x: 'left', y: 'back' };
                const getOffsets = (wM, dM) => {
                    if (settings.offset) return settings.offset;
                    let offX = 0; const widthDiff = (buildWidthM - wM) * scale;
                    if (alignPref.x === 'left') offX = -widthDiff / 2; else if (alignPref.x === 'right') offX = widthDiff / 2;
                    let offY = 0; const depthDiff = (validDepthM - dM) * scale;
                    if (alignPref.y === 'back') offY = -depthDiff / 2; else if (alignPref.y === 'front') offY = depthDiff / 2;
                    return { x: offX, y: offY };
                }
                const userOff = getOffsets(settings.points ? buildWidthM : visualWidthM, settings.points ? validDepthM : visualDepthM);

                let shiftYPx, shiftXVal;
                if (layerPoints) { shiftYPx = userOff.y; shiftXVal = userOff.x; } else { shiftYPx = (envelopeCenterY * scale) + userOff.y; shiftXVal = shiftX + userOff.x; }

                const violations = []; 
                layers.push({
                    id: floorId, z: currentZM * scale, height: Math.max(10, h * scale * 0.9), depthPx: visualDepthM * scale, widthPx: visualWidthM * scale, shiftYPx: shiftYPx, shiftX: shiftXVal, rotation: rotation, pivot: settings.pivot, realArea: usedAreaM2, realWidth: visualWidthM, realDepth: visualDepthM, realHeight: h, maxGeometricArea: maxFloorAreaM2, maxGeometricWidth: buildWidthM, maxGeometricDepth: validDepthM, isViolation: violations.length>0, violations: violations, points: layerPoints, curves: layerCurves
                });
                remainingAreaM2 -= usedAreaM2; currentTotalUsed += usedAreaM2; currentZM += h; floorCount++;
            }
            return { layers, totalFloors: floorCount, totalHeight: currentZM, currentTotalUsed, remainingArea: Math.max(0, remainingAreaM2) };
        }, [res.totalCFA, res.exemptBasement, activeBasementArea, baseDepthM, baseWidthM, frontM, backM, sideM, roadW_M, inputs.floorHeight1F, inputs.floorHeightOther, showCheckLines, showWeiLao, byRatio, scale, floorSettings, arcadeM, isConstraintMode, manualFloorsOverride, basePoints, baseCurves, edgeTypes, frontageIndices, res.floorsAbove, inputs.roads]); 

        const floorLayers = massingLayers.layers;
        const colors = { bg: isDarkMode ? "#0f172a" : "#fafaf9", grid: isDarkMode ? "linear-gradient(#1e293b 1px, transparent 1px), linear-gradient(90deg, #1e293b 1px, transparent 1px)" : "linear-gradient(#e5e7eb 1px, transparent 1px), linear-gradient(90deg, #e5e7eb 1px, transparent 1px)", floor: showCheckLines ? (isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(255, 255, 255, 0.3)") : (isDarkMode ? "rgba(255, 255, 255, 0.9)" : "#ffffff"), stroke: showCheckLines ? "#fb923c" : (isDarkMode ? "#94a3b8" : "#a8a29e") };
        const visualTotalH_Px = massingLayers.totalHeight * scale;
        const visualFloorsAbove = massingLayers.totalFloors;
        const totalAreaViolation = massingLayers.currentTotalUsed > volumeLimit; 
        const unusedArea = massingLayers.remainingArea;

        // Fix 3D Coordinates: Center the points
        const normalizePoints = (points) => {
            if (!points) return null;
            const centroid = getPolygonCentroid(points);
            return points.map(p => ({ x: p.x - centroid.x, y: p.y - centroid.y }));
        };

        const renderRoads = () => {
             // Use explicit base points OR default rect to render roads relative to something stable
             let pointsToUse = basePoints;
             if (!pointsToUse) {
                 const hw = baseWidthM / 2; const hd = baseDepthM / 2;
                 pointsToUse = [{x: -hw, y: -hd}, {x: hw, y: -hd}, {x: hw, y: hd}, {x: -hw, y: hd}];
             }
             const normalizedPoints = normalizePoints(pointsToUse);
             const N = normalizedPoints.length;
             
             if (!inputs.roads || inputs.roads.length === 0) return null;

             const paths = [];
             const labels = [];
             
             // 1. Collect all road segments
             const allSegments = [];
             inputs.roads.forEach(road => {
                 const indices = new Set();
                 if (road.edgeIndices) road.edgeIndices.forEach(i => indices.add(i));
                 if (road.edgeIndex !== undefined) indices.add(road.edgeIndex);
                 
                 indices.forEach(idx => {
                     allSegments.push({
                         edgeIdx: idx,
                         width: parseFloat(road.width || 6),
                         name: road.name,
                         roadId: road.id,
                         type: road.type
                     });
                 });
             });
             
             if (allSegments.length === 0) return null;

             // 2. Sort by edge index
             allSegments.sort((a, b) => a.edgeIdx - b.edgeIdx);

             // 3. Group adjacent segments with same WIDTH
             const groups = [];
             if (allSegments.length > 0) {
                 let curGroup = [allSegments[0]];
                 for (let i = 1; i < allSegments.length; i++) {
                     const prev = curGroup[curGroup.length - 1];
                     const curr = allSegments[i];
                     // Check adjacency (curr.edgeIdx == prev.edgeIdx + 1) AND same width
                     if (curr.edgeIdx === prev.edgeIdx + 1 && Math.abs(curr.width - prev.width) < 0.01) {
                         curGroup.push(curr);
                     } else {
                         groups.push(curGroup);
                         curGroup = [curr];
                     }
                 }
                 // Check wrapping (Last -> First)
                 if (groups.length > 0) {
                     const first = groups[0][0];
                     const last = curGroup[curGroup.length - 1];
                     if (last.edgeIdx === N - 1 && first.edgeIdx === 0 && Math.abs(last.width - first.width) < 0.01) {
                          groups[0] = [...curGroup, ...groups[0]];
                     } else {
                          groups.push(curGroup);
                     }
                 } else {
                      groups.push(curGroup);
                 }
             }

             // 4. Render groups
             groups.forEach((grp, gIdx) => {
                 const roadRW = grp[0].width;
                 const isLoop = (grp.length === N);
                 const shouldExtend = !isLoop;
                 const EXT_LEN = 50; 
                 
                 let rawPoints = [];
                 let rawCurves = [];
                 grp.forEach(seg => {
                     rawPoints.push(normalizedPoints[seg.edgeIdx % N]);
                     rawCurves.push(baseCurves?.[seg.edgeIdx % N]);
                 });
                 const lastSeg = grp[grp.length-1];
                 rawPoints.push(normalizedPoints[(lastSeg.edgeIdx + 1) % N]); // End point

                 let finalPoints = [...rawPoints];
                 let finalCurves = [...rawCurves];

                 if (shouldExtend && rawPoints.length >= 2) {
                     const p0 = rawPoints[0];
                     const p1 = rawPoints[1];
                     const c0 = rawCurves[0];
                     
                     let startDir = { x: p1.x - p0.x, y: p1.y - p0.y };
                     if (c0) {
                         startDir = { x: c0.x - p0.x, y: c0.y - p0.y };
                     }
                     const lenStart = Math.sqrt(startDir.x*startDir.x + startDir.y*startDir.y);
                     if (lenStart > 0) {
                         const extP = { 
                             x: p0.x - (startDir.x/lenStart) * EXT_LEN, 
                             y: p0.y - (startDir.y/lenStart) * EXT_LEN 
                         };
                         finalPoints.unshift(extP);
                         finalCurves.unshift(null);
                     }

                     const pn = rawPoints[rawPoints.length-1];
                     const pn_1 = rawPoints[rawPoints.length-2];
                     const cn_1 = rawCurves[rawCurves.length-1];
                     
                     let endDir = { x: pn.x - pn_1.x, y: pn.y - pn_1.y };
                     if (cn_1) {
                         endDir = { x: pn.x - cn_1.x, y: pn.y - cn_1.y };
                     }
                     const lenEnd = Math.sqrt(endDir.x*endDir.x + endDir.y*endDir.y);
                     if (lenEnd > 0) {
                         const extP = {
                             x: pn.x + (endDir.x/lenEnd) * EXT_LEN,
                             y: pn.y + (endDir.y/lenEnd) * EXT_LEN
                         };
                         finalPoints.push(extP);
                         finalCurves.push(null);
                     }
                 }

                 const getOffsetLine = (p1, p2) => {
                     const centroid = {x:0, y:0};
                     const normal = getSegmentNormal(p1, p2, centroid); 
                     const vx = -normal.x * roadRW; 
                     const vy = -normal.y * roadRW;
                     return { start: {x: p1.x + vx, y: p1.y + vy}, dir: {x: p2.x - p1.x, y: p2.y - p1.y}, vec: {x: vx, y: vy} };
                 };
                 const getIntersection = (l1, l2) => {
                     const x1 = l1.start.x; const y1 = l1.start.y;
                     const x2 = x1 + l1.dir.x; const y2 = y1 + l1.dir.y;
                     const x3 = l2.start.x; const y3 = l2.start.y;
                     const x4 = x3 + l2.dir.x; const y4 = y3 + l2.dir.y;
                     const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                     if (Math.abs(den) < 1e-6) return null;
                     const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
                     return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1) };
                 };

                 const lines = [];
                 for(let i=0; i < finalPoints.length - 1; i++) {
                     lines.push(getOffsetLine(finalPoints[i], finalPoints[i+1]));
                 }

                 const outerPoints = [];
                 for(let i=0; i < finalPoints.length; i++) {
                     let pt;
                     if (isLoop && !shouldExtend) {
                         const l1 = lines[(i - 1 + lines.length) % lines.length];
                         const l2 = lines[i % lines.length];
                         pt = getIntersection(l1, l2) || { x: finalPoints[i].x + l1.vec.x, y: finalPoints[i].y + l1.vec.y };
                     } else {
                         if (i === 0) {
                             const l = lines[0];
                             pt = { x: finalPoints[0].x + l.vec.x, y: finalPoints[0].y + l.vec.y };
                         } else if (i === finalPoints.length - 1) {
                             const l = lines[lines.length - 1];
                             pt = { x: finalPoints[i].x + l.vec.x, y: finalPoints[i].y + l.vec.y };
                         } else {
                             const l1 = lines[i-1];
                             const l2 = lines[i];
                             pt = getIntersection(l1, l2) || { x: finalPoints[i].x + l1.vec.x, y: finalPoints[i].y + l1.vec.y };
                         }
                     }
                     outerPoints.push(pt);
                 }

                 let innerPathD = "";
                 let outerPathD = "";

                 finalPoints.forEach((p, i) => {
                     const x = p.x*scale + w/2; 
                     const y = p.y*scale + d/2;
                     if (i === 0) innerPathD += `M ${x} ${y}`;
                     else {
                         const curve = finalCurves[i-1];
                         if (curve) {
                             innerPathD += ` Q ${curve.x*scale + w/2} ${curve.y*scale + d/2}, ${x} ${y}`;
                         } else {
                             innerPathD += ` L ${x} ${y}`;
                         }
                     }
                 });

                 for(let i = outerPoints.length - 1; i >= 0; i--) {
                     const p = outerPoints[i];
                     const x = p.x*scale + w/2;
                     const y = p.y*scale + d/2;
                     
                     if (i === outerPoints.length - 1) outerPathD += ` L ${x} ${y}`;
                     else {
                         const curve = finalCurves[i];
                         if (curve) {
                             const l = lines[i];
                             const cp = { x: curve.x*scale + w/2 + l.vec.x*scale, y: curve.y*scale + d/2 + l.vec.y*scale };
                             outerPathD += ` Q ${cp.x} ${cp.y}, ${x} ${y}`;
                         } else {
                             outerPathD += ` L ${x} ${y}`;
                         }
                     }
                 }
                 
                 const fullD = innerPathD + outerPathD + " Z";
                 paths.push(
                     <path key={`road-path-${gIdx}`} d={fullD} fill={isDarkMode ? "rgba(71, 85, 105, 0.5)" : "rgba(229, 231, 235, 0.6)"} stroke={isDarkMode ? "#64748b" : "#d1d5db"} strokeWidth="1" strokeDasharray="5,5"/>
                 );
                 
                 // Label Logic: Use middle segment
                 const midSegIdx = Math.floor((rawPoints.length - 1) / 2);
                 const seg = grp[midSegIdx];
                 if (seg) {
                      const p1 = rawPoints[midSegIdx];
                      const p2 = rawPoints[midSegIdx+1];
                      const l = lines[midSegIdx + (shouldExtend ? 1 : 0)];
                      if (l) {
                         const labelX = (p1.x + p2.x)/2 * scale + w/2 + l.vec.x/2 * scale;
                         const labelY = (p1.y + p2.y)/2 * scale + d/2 + l.vec.y/2 * scale;
                         labels.push(
                             <Si key={`road-label-${gIdx}`} text={`${seg.name} ${seg.width}m`} x={labelX} y={labelY} z={2} rotationZ={rotationZ} baseRotation={inputs.northAngle || 0} viewAngleX={viewAngleX} visible={true} className={`text-[10px] font-bold bg-white/80 text-stone-600 px-1 rounded shadow-sm`} />
                         );
                      }
                 }
             });

             return (
                  <div style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', pointerEvents: 'none', zIndex: 5 }}>
                      <svg width="100%" height="100%" viewBox={`0 0 ${w} ${d}`} style={{overflow: 'visible'}}>
                           {paths}
                      </svg>
                      {labels}
                  </div>
             );
        };
        
        const renderPolygonSetbacks = () => {
             let pointsToUse = basePoints;
             if (!pointsToUse || pointsToUse.length < 3) {
                 const hw = baseWidthM / 2; const hd = baseDepthM / 2;
                 pointsToUse = [{x: -hw, y: -hd}, {x: hw, y: -hd}, {x: hw, y: hd}, {x: -hw, y: hd}];
             }

             const rawNormalized = normalizePoints(pointsToUse);
             
             // 1. Discretize Base Points (Outer Ring) to match offsetPolygon's internal logic
             const { points: normalizedPoints, edgeMap } = discretizePolygon(rawNormalized, baseCurves, 15);
             
             // Filter frontageIndices: Primary -> Front, Secondary -> Side (unless manually overridden)
             const primaryIndices = new Set();
             const secondaryIndices = new Set();
             
             if (inputs.roads) {
                 inputs.roads.forEach(r => {
                     const indices = new Set();
                     if (r.edgeIndices) r.edgeIndices.forEach(i => indices.add(i));
                     if (r.edgeIndex !== undefined && r.edgeIndex !== "") indices.add(parseInt(r.edgeIndex));
                     
                     if (r.type === 'primary') {
                         indices.forEach(i => primaryIndices.add(i));
                     } else {
                         indices.forEach(i => secondaryIndices.add(i));
                     }
                 });
             }
 
             const frontIndices = new Set();
             
             if (frontageIndices && frontageIndices.size > 0) {
                  frontageIndices.forEach(i => frontIndices.add(i));
             } else {
                  primaryIndices.forEach(i => frontIndices.add(i));
                  if (primaryIndices.size === 0 && secondaryIndices.size > 0) {
                       secondaryIndices.forEach(i => frontIndices.add(i));
                  }
             }
 
             // Prepare combined edge types (Secondary -> Side)
             const combinedEdgeTypes = { ...edgeTypes };
             secondaryIndices.forEach(idx => {
                 if (!frontIndices.has(idx) && !combinedEdgeTypes[idx]) {
                     combinedEdgeTypes[idx] = 'side';
                 }
             });

             // --- Grouping Logic for Frontyard Labels (uses Original Indices) ---
             const sortedIndices = Array.from(frontIndices).sort((a,b)=>a-b);
             const labelIndices = new Set();
             if (sortedIndices.length > 0) {
                 const groups = [];
                 let cur = [sortedIndices[0]];
                 for(let k=1; k<sortedIndices.length; k++){
                     if (sortedIndices[k] === sortedIndices[k-1]+1) cur.push(sortedIndices[k]);
                     else { groups.push(cur); cur = [sortedIndices[k]]; }
                 }
                 const N = rawNormalized.length; // Use original count for wrapping logic
                 if (groups.length > 0 && cur[cur.length-1] === N-1 && groups[0][0] === 0) {
                     groups[0] = [...cur, ...groups[0]];
                 } else {
                     groups.push(cur);
                 }
                 groups.forEach(grp => {
                     const mid = grp[Math.floor(grp.length/2)];
                     labelIndices.add(mid);
                 });
             }
             // -------------------------------------------

             const offsetResult = offsetPolygon(rawNormalized, combinedEdgeTypes, { front: frontM, back: backM, side: sideM }, frontIndices, baseCurves);
             if (!offsetResult || !offsetResult.points) return null;
             const innerPoints = offsetResult.points;
             
             const alignedInnerPoints = [];
             for(let i=0; i<innerPoints.length; i++) {
                 alignedInnerPoints.push(innerPoints[i]);
             }

             // Priority Helper (uses Original Index)
             const getPriority = (origIdx) => {
                 if (frontIndices.has(origIdx)) return 2;
                 if (combinedEdgeTypes && combinedEdgeTypes[origIdx] === 'back') return 2;
                 if (combinedEdgeTypes && combinedEdgeTypes[origIdx] === 'side') return 1;
                 return 0;
             };
             
             const paths = [];
             const labels = [];
             
             const edgePolys = normalizedPoints.map(() => ({ start: [], end: [] }));

             for (let i = 0; i < normalizedPoints.length; i++) {
                 const prevIdx = (i - 1 + normalizedPoints.length) % normalizedPoints.length;
                 const currIdx = i;
                 
                 const pCorner = normalizedPoints[i];
                 const ipCorner = alignedInnerPoints[i];
                 
                 const origIdx = edgeMap[i];
                 const prevOrigIdx = edgeMap[prevIdx];
                 
                 const prevPrio = getPriority(prevOrigIdx);
                 const currPrio = getPriority(origIdx);
                 
                 const isRealCorner = origIdx !== prevOrigIdx;

                 if (isRealCorner && prevPrio > currPrio) {
                     const l1p1 = alignedInnerPoints[prevIdx];
                     const l1p2 = alignedInnerPoints[i];
                     const l2p1 = normalizedPoints[i];
                     const l2p2 = normalizedPoints[(i + 1) % normalizedPoints.length];
                     
                     const intersect = getLineIntersection(l1p1, l1p2, l2p1, l2p2);
                     if (intersect) {
                         edgePolys[prevIdx].end = [pCorner, intersect, ipCorner];
                         edgePolys[currIdx].start = [intersect, ipCorner];
                     } else {
                        edgePolys[prevIdx].end = [pCorner, ipCorner];
                        edgePolys[currIdx].start = [pCorner, ipCorner];
                     }
                 } else if (isRealCorner && prevPrio < currPrio) {
                     const l1p1 = alignedInnerPoints[i];
                     const l1p2 = alignedInnerPoints[(i + 1) % alignedInnerPoints.length];
                     const l2p1 = normalizedPoints[prevIdx];
                     const l2p2 = normalizedPoints[i];
                     
                     const intersect = getLineIntersection(l1p1, l1p2, l2p1, l2p2);
                     if (intersect) {
                         edgePolys[prevIdx].end = [intersect, ipCorner];
                         edgePolys[currIdx].start = [intersect, pCorner, ipCorner];
                     } else {
                        edgePolys[prevIdx].end = [pCorner, ipCorner];
                        edgePolys[currIdx].start = [pCorner, ipCorner];
                     }
                 } else {
                     edgePolys[prevIdx].end = [pCorner, ipCorner];
                     edgePolys[currIdx].start = [pCorner, ipCorner];
                 }
             }
             
             for (let i = 0; i < normalizedPoints.length; i++) {
                 const originalIdx = edgeMap[i];
                 
                 let color = "rgba(59, 130, 246, 0.2)"; 
                 let label = "側院";
                 let textColor = isDarkMode ? "text-blue-300" : "text-blue-600";
                 let depth = 0;
                 
                 if (frontIndices.has(originalIdx)) {
                    color = "rgba(244, 63, 94, 0.2)"; 
                    label = arcadeM > 0 ? "騎樓" : "前院";
                    depth = arcadeM > 0 ? arcadeM : frontM;
                    textColor = isDarkMode ? "text-rose-300" : "text-rose-600";
                } else if (combinedEdgeTypes && combinedEdgeTypes[originalIdx] === 'back') {
                    color = "rgba(16, 185, 129, 0.2)"; 
                    label = "後院";
                    depth = backM;
                    textColor = isDarkMode ? "text-emerald-300" : "text-emerald-600";
                } else if (combinedEdgeTypes && combinedEdgeTypes[originalIdx] === 'side') {
                    color = "rgba(59, 130, 246, 0.2)"; 
                    label = "側院";
                    depth = sideM;
                    textColor = isDarkMode ? "text-blue-300" : "text-blue-600";
                } else {
                    continue;
                }
                 
                 const starts = edgePolys[i].start;
                 const ends = edgePolys[i].end;
                 
                 let d = `M ${starts[0].x*scale + w/2} ${starts[0].y*scale + d/2}`;
                 for (let k = 1; k < ends.length; k++) {
                     d += ` L ${ends[k].x*scale + w/2} ${ends[k].y*scale + d/2}`;
                 }
                 for (let k = starts.length - 1; k > 0; k--) {
                     d += ` L ${starts[k].x*scale + w/2} ${starts[k].y*scale + d/2}`;
                 }
                 d += " Z";
                 
                 paths.push(
                     <path key={`setback-area-${i}`} d={d} fill={color} stroke="none" />
                 );
             }
             
             // Pre-calc label positions
             const labelPosMap = {};
             normalizedPoints.forEach((p, idx) => {
                 const oIdx = edgeMap[idx];
                 if (!labelPosMap[oIdx]) labelPosMap[oIdx] = [];
                 labelPosMap[oIdx].push(idx);
             });

             // Re-loop for drawing LABELS based on Original Edge Groups
            Object.keys(labelPosMap).forEach(key => {
                const originalIdx = parseInt(key);
                const indices = labelPosMap[originalIdx];
                if (!indices || indices.length === 0) return;

                let label = "側院";
                let textColor = isDarkMode ? "text-blue-300" : "text-blue-600";
                let showLabel = true;
                let depth = 0;

                if (frontIndices.has(originalIdx)) {
                   label = arcadeM > 0 ? "騎樓" : "前院";
                   depth = arcadeM > 0 ? arcadeM : frontM;
                   textColor = isDarkMode ? "text-rose-300" : "text-rose-600";
                   if (!labelIndices.has(originalIdx)) showLabel = false;
               } else if (combinedEdgeTypes && combinedEdgeTypes[originalIdx] === 'back') {
                   label = "後院";
                   depth = backM;
                   textColor = isDarkMode ? "text-emerald-300" : "text-emerald-600";
               } else if (combinedEdgeTypes && combinedEdgeTypes[originalIdx] === 'side') {
                   label = "側院";
                   depth = sideM;
                   textColor = isDarkMode ? "text-blue-300" : "text-blue-600";
               } else {
                   return;
               }
                
                if (!showLabel || depth <= 0) return;

                const midIndex = indices[Math.floor(indices.length/2)];
                const p1 = normalizedPoints[midIndex];
                const nextIdx = (midIndex + 1) % normalizedPoints.length;
                const p2 = normalizedPoints[nextIdx];
                const ip1 = alignedInnerPoints[midIndex];
                const ip2 = alignedInnerPoints[nextIdx];
                
                const cx = (p1.x + p2.x + ip1.x + ip2.x) / 4;
                const cy = (p1.y + p2.y + ip1.y + ip2.y) / 4;

                let angle = Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
                if (angle > 90) angle -= 180;
                if (angle < -90) angle += 180;
                
                labels.push(
                    <g key={`label-group-${originalIdx}`}>
                        <text 
                            x={cx * scale + w/2}
                            y={cy * scale + d/2 - 6}
                            transform={`rotate(${angle}, ${cx * scale + w/2}, ${cy * scale + d/2})`}
                            textAnchor="middle"
                            dominantBaseline="middle"
                            className={`text-[9px] select-none pointer-events-none font-bold ${textColor}`}
                            style={{ textShadow: isDarkMode ? '0px 1px 2px rgba(0,0,0,0.8)' : '0px 1px 2px rgba(255,255,255,0.8)' }}
                        >
                            {label}
                        </text>
                        <text 
                            x={cx * scale + w/2}
                            y={cy * scale + d/2 + 6}
                            transform={`rotate(${angle}, ${cx * scale + w/2}, ${cy * scale + d/2})`}
                            textAnchor="middle"
                            dominantBaseline="middle"
                            className={`text-[10px] select-none pointer-events-none font-black ${isDarkMode ? 'text-white' : 'text-stone-700'}`}
                            style={{ textShadow: isDarkMode ? '0px 1px 2px rgba(0,0,0,0.8)' : '0px 1px 2px rgba(255,255,255,0.8)' }}
                        >
                            {depth.toFixed(2)}m
                        </text>
                    </g>
                );
            });

             return (
                  <div style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', pointerEvents: 'none', zIndex: 10 }}>
                      <svg width="100%" height="100%" viewBox={`0 0 ${w} ${d}`} style={{overflow: 'visible'}}>
                           {paths}
                           <path d={generateSvgPath(innerPoints, null, scale, w/2, d/2)} fill="none" stroke={isDarkMode ? "#94a3b8" : "#64748b"} strokeWidth="2" strokeDasharray="8,4" opacity="0.8"/>
                           {labels}
                      </svg>
                  </div>
             );
        };

        const calculateCheckLines = () => {
             const lines = [];
             const offX = w / 2;
             const offY = d / 2;

             // Helper to find primary road info
            const getPrimaryRoadInfo = () => {
                let road = inputs.roads.find(r => r.type === 'primary');
                if (!road) return { widthPx: 6 * scale, widthM: 6, isDefault: true, roadObj: null };
                return { widthPx: parseFloat(road.width) * scale, widthM: parseFloat(road.width), isDefault: false, roadObj: road };
            };
             
             const { widthPx: primRoadW_Px, widthM: primRoadW_M, roadObj: primRoad } = getPrimaryRoadInfo();

             // Use discretized points to handle curves correctly
             // We need to map edges back to original indices to check frontage/back types
             let workingPoints = [];
             let workingEdgeIndices = [];
             
             if (basePoints) {
                 const normPoints = normalizePoints(basePoints);
                 // Discretize for accurate geometric position on curves
                 const discretized = discretizePolygon(normPoints, baseCurves, 20);
                 workingPoints = discretized.points;
                 workingEdgeIndices = discretized.edgeMap;
             } else {
                  // Fallback for default rect
                  const hw = baseWidthM / 2; const hd = baseDepthM / 2;
                  workingPoints = [{x: -hw, y: -hd}, {x: hw, y: -hd}, {x: hw, y: hd}, {x: -hw, y: hd}];
                  workingEdgeIndices = [0, 1, 2, 3];
             }

             if (!workingPoints || workingPoints.length < 3) return [];
             
             // --- Consistent Edge Logic Start ---
             const primaryIndices = new Set();
             const secondaryIndices = new Set();
             
             if (inputs.roads) {
                 inputs.roads.forEach(r => {
                     const indices = new Set();
                     if (r.edgeIndices) r.edgeIndices.forEach(i => indices.add(i));
                     if (r.edgeIndex !== undefined && r.edgeIndex !== "") indices.add(parseInt(r.edgeIndex));
                     
                     if (r.type === 'primary') {
                         indices.forEach(i => primaryIndices.add(i));
                     } else {
                         indices.forEach(i => secondaryIndices.add(i));
                     }
                 });
             }
 
             const frontIndices = new Set();
             if (frontageIndices && frontageIndices.size > 0) {
                  frontageIndices.forEach(i => frontIndices.add(i));
             } else {
                  primaryIndices.forEach(i => frontIndices.add(i));
                  if (primaryIndices.size === 0 && secondaryIndices.size > 0) {
                       secondaryIndices.forEach(i => frontIndices.add(i));
                  }
             }

             // Prepare combined edge types (Secondary -> Side)
             const combinedEdgeTypes = { ...edgeTypes };
             secondaryIndices.forEach(idx => {
                 if (!frontIndices.has(idx) && !combinedEdgeTypes[idx]) {
                     combinedEdgeTypes[idx] = 'side';
                 }
             });
             // --- Consistent Edge Logic End ---

             const centroid = getPolygonCentroid(workingPoints);

             // Iterate through discretized segments
             // Group segments by Original Index to consolidate labels
             const linesByEdge = {};

             for (let i = 0; i < workingPoints.length; i++) {
                 const p1 = workingPoints[i];
                 const p2 = workingPoints[(i + 1) % workingPoints.length];
                 const originalIdx = workingEdgeIndices[i];
                 
                 // IMPORTANT: getSegmentNormal returns normal pointing INWARD (towards centroid)
                 const normal = getSegmentNormal(p1, p2, centroid); 
                 const mid = { x: (p1.x + p2.x)/2, y: (p1.y + p2.y)/2 };
                 
                 if (!linesByEdge[originalIdx]) linesByEdge[originalIdx] = [];

                 // 1. Height Ratio & WeiLao (Frontage)
                 if (frontIndices.has(originalIdx)) {
                     const fD = parseFloat(inputs.frontYardDepth || 0); 
                     
                     // Normal points INWARD.
                     // Calculate all geometry in METERS first to avoid unit mismatch errors
                     
                     // Road Far Side (Outermost) = Move OUT against normal by Road Width (M)
                     const p_out_M = { x: mid.x - normal.x * primRoadW_M, y: mid.y - normal.y * primRoadW_M };
                     
                     // Road Center = Move OUT against normal by Road Width / 2 (M)
                     const p_center_M = { x: mid.x - normal.x * (primRoadW_M / 2), y: mid.y - normal.y * (primRoadW_M / 2) };
                     
                     // Setback Line (Inside) = Move IN with normal by Front Depth (M)
                     const p_setback_M = { x: mid.x + normal.x * fD, y: mid.y + normal.y * fD };

                     if (showCheckLines) {
                         const hRatioH = 3.6 * (primRoadW_M + fD) * scale; 
                         linesByEdge[originalIdx].push({ 
                             id: `height-${i}`, 
                             type: 'height',
                             start: { x: offX + p_out_M.x * scale, y: offY + p_out_M.y * scale, z: 0 }, // Start at Road Far Side
                             end: { x: offX + p_setback_M.x * scale, y: offY + p_setback_M.y * scale, z: hRatioH }, // End at Setback Line (Max Height)
                             label: "高度比", 
                             color: "#f43f5e",
                             dashed: false,
                             thick: true
                         });
                     }
                     
                     if (showWeiLao) {
                         const wlH = 5 * (0.5 * primRoadW_M + fD) * scale;
                         linesByEdge[originalIdx].push({ 
                             id: `weilao-${i}`, 
                             type: 'weilao',
                             start: { x: offX + p_center_M.x * scale, y: offY + p_center_M.y * scale, z: 0 }, // Start at Road Center
                             end: { x: offX + p_setback_M.x * scale, y: offY + p_setback_M.y * scale, z: wlH }, // End at Setback Line
                             label: "危老檢討", 
                             color: isDarkMode ? "#60a5fa" : "#3b82f6", // Blue
                             dashed: true,
                             thick: true
                         });
                     }
                 }

                 // 2. Backyard Depth Ratio (Back)
                 // Use inputs.minBackyardDepthRatio (New Input)
                 const minBYRatio = parseFloat(inputs.minBackyardDepthRatio || 0);
                 if (minBYRatio > 0 && showCheckLines) {
                     if (combinedEdgeTypes[originalIdx] === 'back') {
                         const bD = parseFloat(inputs.backYardDepth || 0); 
                         const limitH = (bD * minBYRatio) * scale; 
                         
                         // Backyard Setback (Inside) = Move IN with normal by Backyard Depth (Meters)
                         const p_back_setback_M = { x: mid.x + normal.x * bD, y: mid.y + normal.y * bD };
                         
                         linesByEdge[originalIdx].push({ 
                            id: `backyard-${i}`, 
                            type: 'backyard',
                            start: { x: offX + mid.x * scale, y: offY + mid.y * scale, z: 0 }, // Start at Base Line
                            end: { x: offX + p_back_setback_M.x * scale, y: offY + p_back_setback_M.y * scale, z: limitH }, // End at Backyard Setback
                            label: "後院檢討", 
                            color: inputs.backyardLineColor || (isDarkMode ? "#4ade80" : "#22c55e"), 
                            dashed: inputs.backyardLineDashed !== false, 
                            thick: inputs.backyardLineThick !== false
                        });
                     }
                 }
             }
             
             // Process groups to remove duplicate labels
             Object.values(linesByEdge).forEach(groupLines => {
                 // Group by type within edge
                 const byType = {};
                 groupLines.forEach(l => {
                     if (!byType[l.type]) byType[l.type] = [];
                     byType[l.type].push(l);
                 });
                 
                 Object.values(byType).forEach(subGroup => {
                     // Only keep label for the middle line
                     const midIdx = Math.floor(subGroup.length / 2);
                     subGroup.forEach((l, idx) => {
                         if (idx !== midIdx) l.label = null;
                         lines.push(l);
                     });
                 });
             });
             
             return lines;
        };



        const landscapeStyle = isLandscapeMode ? { position: 'fixed', top: 0, left: '100vw', width: '100dvh', height: '100vw', transform: 'rotate(90deg)', transformOrigin: 'top left', zIndex: 9999, margin: 0, borderRadius: 0, touchAction: 'none', backgroundColor: isDarkMode ? '#0f172a' : '#fafaf9' } : { backgroundImage: colors.grid, backgroundSize: '40px 40px', touchAction: 'none' };
        const controlBarClass = isLandscapeMode ? "absolute top-6 right-6 z-30 flex gap-2" : "absolute top-4 right-4 z-30 flex gap-2";
        const viewTransition = isDragging ? 'none' : 'transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1)';
        
        return (
          <div className="bg-[#fdfbf7] rounded-xl p-0 mb-6 shadow-md overflow-hidden relative min-h-[350px] md:min-h-[600px] flex flex-col md:flex-row border border-stone-300 font-['GenYoGothic',_sans-serif] md:sticky md:top-0 md:z-40">
             <div className="flex flex-col md:flex-row w-full h-full relative">
                
                <div ref={viewportRef} className={`flex-1 relative flex flex-col items-center justify-center perspective-1000 min-h-[350px] md:min-h-[600px] overflow-hidden transition-colors duration-500 touch-none ${isDragging ? 'cursor-grabbing' : 'cursor-grab'} ${isDarkMode ? 'bg-slate-900' : 'bg-[#fafaf9]'}`} style={{ ...landscapeStyle, ...(isLandscapeMode ? {} : { backgroundImage: colors.grid, backgroundSize: '40px 40px' }) }} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleMouseUp} onClick={handleBgClick}>
                  {/* Road Direction Info */}
                  <div className="absolute top-16 left-4 z-20 pointer-events-none">
                      {inputs.roads && inputs.roads.length > 0 && (
                          <div className={`text-[10px] font-bold px-2 py-1 rounded backdrop-blur-md shadow-sm border ${isDarkMode ? 'bg-slate-800/80 border-slate-700 text-slate-300' : 'bg-white/80 border-stone-200 text-stone-600'}`}>
                              {(() => {
                                  const r = inputs.roads.find(r=>r.type==='primary') || inputs.roads[0];
                                  const dirMap = { top:'上方', bottom:'下方', left:'左側', right:'右側', custom:'自訂' };
                                  return (
                                      <>
                                        主要道路: {r.name} <span className="text-[9px] opacity-75">({dirMap[r.orientation] || r.orientation})</span> <br/>
                                        方位角: {inputs.northAngle || 0}°
                                      </>
                                  );
                              })()}
                          </div>
                      )}
                  </div>
                  {/* ... same controls ... */}
                  <div className="absolute top-4 left-4 z-40 flex flex-col gap-2">
                      <div className="flex bg-white/90 backdrop-blur rounded-lg border border-stone-200 shadow-sm p-1 gap-1">
                          <button onClick={() => setViewMode('3d')} className={`flex items-center gap-1 px-3 py-1.5 rounded text-xs font-bold transition-colors ${viewMode === '3d' ? 'bg-stone-800 text-white' : 'text-stone-500 hover:bg-stone-100'}`}><Box size={14} /> 3D 模擬</button>
                          <button onClick={() => setViewMode('2d')} className={`flex items-center gap-1 px-3 py-1.5 rounded text-xs font-bold transition-colors ${viewMode === '2d' ? 'bg-stone-800 text-white' : 'text-stone-500 hover:bg-stone-100'}`}><LayoutTemplate size={14} /> 平面分析</button>
                      </div>
                  </div>
                  <div className={controlBarClass}>
                     <div className={`${isDarkMode ? 'bg-slate-800/80 border-slate-700' : 'bg-white/90 border-stone-200'} p-1 rounded-full border shadow-lg flex items-center gap-1 backdrop-blur-md transition-colors duration-300`}>
                        <button onClick={toggleFullscreen} className={`p-2 rounded-full transition-all ${isDarkMode ? 'text-indigo-400 hover:bg-slate-600' : 'text-indigo-600 hover:bg-stone-100'}`} title={isSummaryOpen ? "全螢幕模式 (隱藏面板)" : "顯示詳細面板"}>{isSummaryOpen ? <Maximize2 size={18} /> : <PanelRightOpen size={18} />}</button>
                     </div>
                  </div>
                  {isConstraintMode && viewMode === '3d' && (<div className="absolute bottom-24 right-6 z-20 pointer-events-none"><div className="bg-emerald-600/90 text-white px-3 py-1.5 rounded-full shadow-lg text-sm font-bold flex items-center gap-2 backdrop-blur border border-emerald-400 animate-pulse"><CheckCircle2 size={16} fill="white" className="text-emerald-700" />鎖定編輯</div></div>)}
                  {viewMode === '2d' ? (
                      <PlanAnalysis2D layers={floorLayers} baseWidthM={baseWidthM} baseDepthM={baseDepthM} onSelectFloor={(id) => { if (id === 'base' || id === 'excavation') { setSelectedFloor({ id }); } else if (id) { const l = floorLayers.find(f => f.id === id); if (l) handleLayerClick({ stopPropagation: () => {} }, l); } }} selectedFloorId={selectedFloor?.id} isDarkMode={isDarkMode} onUpdateSetting={updateFloorSetting} floorSettings={floorSettings} inputs={inputs} scale3d={scale} basements={basements} onToggleBasement={toggleBasement} activeBasementArea={activeBasementArea} totalAllowedArea={res.totalCFA} showCheckLines={showCheckLines} volumeLimit={volumeLimit} parkingOn1F={parkingOn1F} onToggleParkingLocation={toggleParkingLocation} onClose={() => { if (selectedFloor) { setSelectedFloor(null); } else { setViewMode('3d'); } }} basePoints={basePoints} baseCurves={baseCurves} excavationPoints={excavationPoints} excavationCurves={excavationCurves} onAddRoad={onUpdateRoads} frontageIndices={frontageIndices} onUpdateFrontageIndices={setFrontageIndices} onAddFloor={handleAddFloor} onRemoveFloor={handleRemoveFloor} edgeTypes={edgeTypes} onUpdateEdgeTypes={updateEdgeTypes} view={view2D} onUpdateView={setView2D} onUpdateInputs={onUpdateInputs} onUpdateRoads={onUpdateRoads} onEditEnd={handleBaseEditEnd} />
                  ) : (
                      <>
                          {!isConstraintMode && <FloorInfoCard data={selectedFloor} isDarkMode={isDarkMode} onReset={resetFloor} isConstraintMode={isConstraintMode} inputs={inputs}/>}
                          <div className="absolute top-16 left-6 z-20 pointer-events-none"><ArtisticCompass className="w-16 h-16" rotation={rotationZ - (inputs.northAngle || 0)} isDarkMode={isDarkMode} /></div>
                          {totalAreaViolation && <div className="absolute top-8 left-1/2 transform -translate-x-1/2 z-20 pointer-events-none animate-pulse"><div className="bg-red-500/90 text-white px-3 py-1.5 rounded-full shadow-lg text-sm font-bold flex items-center gap-2 backdrop-blur"><AlertTriangle size={16} fill="white" className="text-red-500" />總容積超限! (量體 {formatNum(toPing(massingLayers.currentTotalUsed))} &gt; 法定 {formatNum(toPing(volumeLimit))}坪)</div></div>}
                          <div className="relative w-full h-full flex items-center justify-center pointer-events-none" style={{ perspective: '2500px', transformStyle: 'preserve-3d' }}>
                            <div style={{ transform: `rotateX(${viewAngleX}deg) rotateZ(${rotationZ}deg) scale3d(${zoom}, ${zoom}, ${zoom}) translate3d(${focusOffset.x}px, ${focusOffset.y}px, ${focusOffset.z}px)`, transformStyle: 'preserve-3d', transition: viewTransition }}>
                               <div style={{ position: 'relative', width: `${w}px`, height: `${d}px`, backgroundColor: 'transparent', transformStyle: 'preserve-3d', transition: 'background-color 0.5s', pointerEvents: 'auto' }} onMouseDown={handleMouseDown} onTouchStart={handleTouchStart}>
                                  {/* Base Layer with Stroke */}
                                  <div className="absolute inset-0" style={{ width: '100%', height: '100%' }}>
                                     {basePoints ? (
                                         <svg width={100} height={100} viewBox={`0 0 ${w} ${d}`} style={{overflow: 'visible'}}>
                                             <path 
                                                 d={generateSvgPath(normalizePoints(basePoints), baseCurves, scale, w/2, d/2)} 
                                                 fill={isDarkMode ? 'rgba(30, 41, 59, 0.8)' : 'rgba(255, 255, 255, 0.9)'} 
                                                 stroke={isDarkMode ? '#475569' : '#a8a29e'} 
                                                 strokeWidth="2"
                                                 style={{ filter: isDarkMode ? 'drop-shadow(0 0 10px rgba(0,0,0,0.5))' : 'drop-shadow(0 0 10px rgba(0,0,0,0.1))' }}
                                             />
                                         </svg>
                                     ) : (
                                         <div className={`w-full h-full border-2 shadow-2xl transition-colors duration-500 ${isDarkMode ? 'bg-slate-800/80 border-slate-600' : 'bg-white/90 border-stone-300'}`} style={{ boxShadow: isDarkMode ? '0 0 20px rgba(0,0,0,0.5)' : 'none' }}></div>
                                     )}
                                  </div>
                                     {!basePoints && ( <> <div style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: `${backPx}px`, background: isDarkMode ? 'repeating-linear-gradient(45deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.1) 10px, rgba(16, 185, 129, 0.2) 10px, rgba(16, 185, 129, 0.2) 20px)' : 'repeating-linear-gradient(45deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.1) 10px, rgba(16, 185, 129, 0.2) 10px, rgba(16, 185, 129, 0.2) 20px)', borderBottom: '2px dashed #10b981', pointerEvents: 'none' }}> <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-[10px] font-bold text-emerald-600/80 tracking-widest whitespace-nowrap bg-white/50 px-1 rounded backdrop-blur-sm">後院</div> </div> <div style={{ position: 'absolute', bottom: 0, left: 0, width: '100%', height: `${Math.max(frontPx, (arcadeM * scale) || 0)}px`, background: isDarkMode ? 'repeating-linear-gradient(45deg, rgba(244, 63, 94, 0.1), rgba(244, 63, 94, 0.1) 10px, rgba(244, 63, 94, 0.2) 10px, rgba(244, 63, 94, 0.2) 20px)' : 'repeating-linear-gradient(45deg, rgba(244, 63, 94, 0.1), rgba(244, 63, 94, 0.1) 10px, rgba(244, 63, 94, 0.2) 10px, rgba(244, 63, 94, 0.2) 20px)', borderTop: '2px dashed #f43f5e', pointerEvents: 'none' }}> <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-[10px] font-bold text-rose-600/80 tracking-widest whitespace-nowrap bg-white/50 px-1 rounded backdrop-blur-sm">{arcadeM > 0 ? "騎樓" : "前院"}</div> </div> </> )}
                                  </div>
                                  {renderRoads()} {renderPolygonSetbacks()}
                                  {calculateCheckLines().map(line => (
                                      <CheckLine key={line.id} {...line} baseRotation={0} viewAngleX={viewAngleX} rotationZ={rotationZ} visible={true} dashed={true} thick={true} isDarkMode={isDarkMode} labelPosRatio={0.2} />
                                  ))}
                                  {basements.map((b, i) => { if (!b.active) return null; let pts = excavationPoints; let crvs = excavationCurves; let wPx = w * 0.8; let dPx = d * 0.8; if (!pts && basePoints) { const scaleRate = Math.sqrt(inputs.excavationRatio / 100); const { points: newPts, curves: newCurves } = scalePolygon(basePoints, baseCurves, scaleRate); pts = normalizePoints(newPts); crvs = newCurves; } else if (pts) { pts = normalizePoints(pts); } return ( <BuildingLayer key={`bsmt-${b.id}`} width={wPx} depth={dPx} height={3.6} x={0} y={0} z={-(i+1)*3.6*scale} rotation={0} scale={scale} points={pts} curves={crvs} color={isDarkMode ? "#334155" : "#cbd5e1"} strokeColor={isDarkMode ? "#475569" : "#94a3b8"} showFrame={showCheckLines} opacity={0.9} visible={true} isSlabMode={true} isDarkMode={isDarkMode} isViolation={false} onClick={(e) => handleLayerClick(e, {id: b.id, z: -(i+1)*3.6*scale, height: 3.6})} /> ); })}
                                  {floorLayers.map((layer, i) => { const pts = layer.points ? normalizePoints(layer.points) : null; return (<BuildingLayer key={`fl-${i}`} width={layer.widthPx} depth={layer.depthPx} height={layer.height} x={layer.shiftX} y={layer.shiftYPx} z={layer.z} rotation={layer.rotation} pivot={selectedFloor?.id === layer.id ? selectedFloor.pivot : floorSettings[layer.id]?.pivot} scale={scale} points={pts} curves={layer.curves} color={colors.floor} strokeColor={colors.stroke} showFrame={showCheckLines} opacity={1} visible={true} isSlabMode={!showCheckLines} animate={animate} delay={i * 50} isDarkMode={isDarkMode} isSelected={selectedFloor && selectedFloor.id === layer.id} isViolation={layer.isViolation} onClick={(e) => handleLayerClick(e, layer)} />) })}
                               </div>
                           </div>
                       </>
                   )}
                </div>
                {/* Right Panel Summary (Same as before) */}
                <div className={`transition-all duration-500 ease-in-out border-l border-stone-200 bg-[#f8fafc] flex flex-col num-font z-10 relative overflow-hidden ${isSummaryOpen ? 'w-full md:w-96 opacity-100' : 'w-0 opacity-0 border-none'}`}>
                   <div className="flex-1 overflow-y-auto p-6">
                      <div className="mb-6 border-b border-stone-200 pb-4 sticky top-0 bg-white/95 backdrop-blur z-40 -mt-6 -mx-6 px-6 pt-6 shadow-sm">
                         <div className="flex items-center justify-between"><h3 className="text-stone-400 text-sm font-bold uppercase tracking-widest flex items-center gap-2"><Building2 size={16} /> Project Summary</h3><div className="w-6"></div> </div>
                         <div className="space-y-3 mt-4">
                            <SummaryRow label="專案名稱" value={inputs.projectName} />
                            <SummaryRow label="工程預算" value={`${formatNum(res.estimatedBudget)} 萬`} highlight />
                            <SummaryRow label="建築物高度" value={`${formatNum(massingLayers.totalHeight)} m`} />
                            <SummaryRow label="模擬樓層" value={`${visualFloorsAbove} 層`} subtext="(含退縮)" />
                            {showCheckLines && <SummaryRow label="高度比" value={formatNum(res.heightRatio, 2)} isAlert={res.isHighRise} alertText={res.isSuperHighRise ? "超高" : "高層"} />}
                            <div className="pt-2 border-t border-stone-200 mt-2">
                               <div className="flex justify-between items-center mb-2">
                                   <span className="text-stone-500 text-sm font-medium">檢討線顯示</span>
                                   <div className="flex items-center gap-1">
                                       <button onClick={() => setShowCheckLines(!showCheckLines)} className={`px-3 py-1 rounded-full border shadow-sm flex items-center gap-2 text-xs font-bold transition-colors ${showCheckLines ? 'bg-indigo-50 border-indigo-200 text-indigo-600' : 'bg-white border-stone-200 text-stone-500'}`}>{showCheckLines ? <ToggleRight size={16} /> : <ToggleLeft size={16} />}{showCheckLines ? "開啟" : "關閉"}</button>
                                       {showCheckLines && (
                                           <button onClick={() => setShowWeiLao(!showWeiLao)} className={`px-3 py-1 rounded-full border shadow-sm flex items-center gap-2 text-xs font-bold transition-colors ${showWeiLao ? 'bg-purple-50 border-purple-200 text-purple-600' : 'bg-white border-stone-200 text-stone-400'}`} title="危老檢討線 (1:5)">
                                               {showWeiLao ? <CheckSquare size={14}/> : <Square size={14}/>} 危老
                                           </button>
                                       )}
                                       <button onClick={toggleConstraints} className={`px-3 py-1 rounded-full border shadow-sm flex items-center gap-2 text-xs font-bold transition-colors ${isConstraintMode ? 'bg-emerald-600 text-white border-emerald-700' : 'bg-white hover:bg-emerald-50 text-emerald-600 border-emerald-200'}`} title={isConstraintMode ? "關閉檢討模式 (允許編輯)" : "開啟檢討模式 (強制符合法規)"}><CheckCircle2 size={16}/> {isConstraintMode ? "檢討開啟" : "檢討關閉"}</button>
                                   </div>
                               </div>
                            </div>
                         </div>
                      </div>
                      <div className="grid grid-cols-2 gap-3">
                         <div className="bg-white p-3 rounded-lg border border-stone-200"><div className="text-stone-400 text-[10px] uppercase mb-1">總樓地板 (坪)</div><div className={`font-bold text-lg num-font ${totalAreaViolation ? 'text-red-500' : 'text-stone-700'}`}>{formatNum(toPing(massingLayers.currentTotalUsed))} <span className="text-xs font-sans font-normal text-stone-400">/ {formatNum(toPing(volumeLimit))} Max</span></div></div>
                         <div className="bg-white p-3 rounded-lg border border-stone-200"><div className="text-stone-400 text-[10px] uppercase mb-1">預估坪效</div><div className="font-bold text-lg num-font text-emerald-600">{formatNum(res.efficiency)} <span className="text-xs font-sans font-normal text-stone-400">倍</span></div></div>
                         <div className="bg-white p-3 rounded-lg border border-stone-200"><div className="text-stone-400 text-[10px] uppercase mb-1">樓層</div><div className="font-bold text-lg num-font text-indigo-600">{visualFloorsAbove}F <span className="text-xs font-sans font-normal text-stone-400">/ B{inputs.floorsBelow}</span></div></div>
                         <div className="bg-white p-3 rounded-lg border border-stone-200"><div className="text-stone-400 text-[10px] uppercase mb-1">停車</div><div className="font-bold text-lg num-font text-stone-700">{res.possibleParking} <span className="text-xs font-sans font-normal text-stone-400">部</span></div></div>
                      </div>
                   </div>
                   <div className="p-6 bg-white border-t border-stone-200 mt-auto">
                      <div className="text-stone-400 text-sm font-bold uppercase mb-4 flex items-center gap-2"><Car size={14} /> 停車空間預估</div>
                      <div className="flex justify-between items-center">
                         <div className="flex items-center gap-3"><div className="p-2 bg-stone-100 rounded text-stone-600"><Car size={18} /></div><div><div className="text-xs text-stone-400">汽車位</div><div className="font-bold text-stone-800 text-lg num-font">{res.possibleParking}</div></div></div>
                         <div className="h-8 w-[1px] bg-stone-200"></div>
                         <div className="flex items-center gap-3"><div className="p-2 bg-stone-100 rounded text-stone-600"><Bike size={18} /></div><div><div className="text-xs text-stone-400">機車位</div><div className="font-bold text-stone-800 text-lg num-font">{Math.floor(res.possibleParking * 1.2)}</div></div></div>
                      </div>
                   </div>
                </div>
             </div>
          </div>
        );
      };

      const CheckLine = React.memo(({ start, end, color, label, rotationZ, baseRotation, viewAngleX, visible, dashed, thick, labelPosRatio = 0.5, isDarkMode }) => {
        const dx = end.x - start.x; const dy = end.y - start.y; const dz = end.z - start.z; const length = Math.sqrt(dx * dx + dy * dy + dz * dz); const lx = start.x + dx * labelPosRatio; const ly = start.y + dy * labelPosRatio; const lz = start.z + dz * labelPosRatio; const angleZ = Math.atan2(dy, dx) * (180 / Math.PI); const angleY = -Math.atan2(dz, Math.sqrt(dx * dx + dy * dy)) * (180 / Math.PI); const isSteep = viewAngleX > 75; const thickness = thick ? (isSteep ? "6px" : "3px") : (isSteep ? "4px" : "2px");
        return ( <> <div className="absolute origin-left" style={{ left: 0, top: 0, width: `${length}px`, height: thickness, backgroundColor: dashed ? 'transparent' : color, borderTop: dashed ? `2px dashed ${color}` : 'none', transform: `translate3d(${start.x}px, ${start.y}px, ${start.z}px) rotateZ(${angleZ}deg) rotateY(${angleY}deg)`, opacity: visible ? (isSteep ? 1 : 0.9) : 0, pointerEvents: 'none', boxShadow: isSteep ? `0 0 4px ${color}` : 'none', zIndex: 60 }}></div> {isSteep && (<div className="absolute origin-left" style={{ left: 0, top: 0, width: `${length}px`, height: thickness, backgroundColor: color, transform: `translate3d(${start.x}px, ${start.y}px, ${start.z}px) rotateZ(${angleZ}deg) rotateY(${angleY}deg) rotateX(90deg)`, opacity: visible ? 1 : 0, pointerEvents: 'none', zIndex: 60 }}></div>)} {visible && label && (<Si text={label} x={lx} y={ly} z={lz + 10} rotationZ={rotationZ} baseRotation={baseRotation} viewAngleX={viewAngleX} visible={visible} className={`text-[10px] px-2 py-0.5 rounded-full shadow-lg font-bold border ${isDarkMode ? 'bg-slate-900 border-slate-600 text-white' : 'bg-white/90 border-slate-200 text-slate-600'}`} />)} </> );
      });

      const Si = React.memo(({ text, x, y, z, rotationZ, baseRotation, viewAngleX, visible, className, lineConnector, isRoadLabel }) => (
        visible ? (<div className="absolute pointer-events-none" style={{ left: 0, top: 0, transform: `translate3d(${x}px, ${y}px, ${z}px) rotateZ(${isRoadLabel ? -(rotationZ + baseRotation) : -(rotationZ + baseRotation)}deg) rotateX(${-viewAngleX}deg)`, zIndex: 7000 }}><div className="flex items-center" style={{ transform: 'translate(-50%, -50%)' }}>{lineConnector && <div className="w-4 h-[1px] bg-stone-400"></div>}<div className={`whitespace-nowrap px-2 py-0.5 rounded shadow-sm text-sm backdrop-blur-sm num-font ${className}`}>{text}</div></div></div>) : null
      ));

      const CollapsibleSection = ({ title, icon, children, defaultOpen = true, className = "" }) => {
        const [isOpen, setIsOpen] = useState(defaultOpen);
        return ( <div className={`bg-white rounded-xl shadow-sm border border-stone-100 overflow-hidden ${className}`}><div className="flex items-center justify-between p-5 cursor-pointer hover:bg-stone-50 transition-colors border-b border-stone-100" onClick={() => setIsOpen(!isOpen)}><h3 className="font-bold text-stone-700 flex items-center gap-2">{icon} {title}</h3><div className="text-stone-400">{isOpen ? <ChevronUp size={20} /> : <ChevronDown size={20} />}</div></div><div className={`transition-all duration-300 ease-in-out overflow-hidden ${isOpen ? 'max-h-[1200px] opacity-100' : 'max-h-0 opacity-0'}`}><div className="p-5">{children}</div></div></div> );
      };

      const InputRow = ({ id, label, value, calculatedValue, formula, note, isEditMode, onOverride, highlight = false, subTotal = false, bold = false, paramKey, paramValue, onParamChange }) => {
        const isConflict = isEditMode && calculatedValue !== undefined && Math.abs(value - calculatedValue) > 0.01;
        const displayValue = formatNum(value);
        const displayPing = formatNum(toPing(value));
        return ( <tr className={`hover:bg-stone-50 ${subTotal ? 'bg-stone-50/80 italic text-stone-600' : ''}`}><td className={`p-4 pl-8 border-l-4 ${highlight ? 'border-emerald-400 font-bold text-emerald-700' : 'border-stone-300'} ${bold ? 'font-bold' : 'font-medium'}`}>{label}</td><td className={`p-4 text-right ${highlight ? 'font-bold text-emerald-700' : ''} ${bold ? 'font-bold' : ''}`}>{isEditMode ? (<div className="flex items-center justify-end gap-2 relative">{isConflict && <div className="absolute right-full mr-2 text-rose-500 animate-pulse" title="警告：數值與公式計算結果衝突"><AlertTriangle size={16} /></div>}<input type="number" value={value} onChange={(e) => onOverride(id, e.target.value)} className={`w-24 p-1 text-right border rounded outline-none focus:ring-2 ${isConflict ? 'border-rose-300 focus:ring-rose-200 bg-rose-50' : 'border-stone-300 focus:ring-indigo-200'} num-font`} /></div>) : (<span className="num-font">{displayValue}</span>)}</td><td className={`p-4 text-right text-stone-500 ${highlight ? 'font-bold text-emerald-700' : ''} ${bold ? 'font-bold' : ''} num-font`}>{displayPing}</td>{isEditMode && (<><td className="p-4 font-mono text-xs text-indigo-600/80 bg-indigo-50/10 border-l border-stone-100">{paramKey ? (<div className="flex items-center gap-2"><span className="text-stone-500">{paramKey === 'exemptRate' ? '免計率' : paramKey === 'stairRate' ? '梯廳率' : '陽台率'}:</span><input type="number" value={paramValue} onChange={(e) => onParamChange(paramKey, e.target.value)} className="w-16 p-1 border rounded text-center font-bold text-indigo-700 num-font" style={{ fontSize: '12px' }}/><span>%</span></div>) : formula}</td><td className="p-4 text-sm text-stone-500 bg-indigo-50/10">{note}</td></>)}</tr> );
      };

      const SectionHeader = ({ title }) => ( <tr className="bg-stone-200 text-stone-800"><td colSpan={10} className="p-2 pl-4 font-bold text-xs uppercase tracking-wider">{title}</td></tr> );

      const Cal = () => {
        const [lots, setLots] = useState([{ id: 1, lot: '___段___地號', area: 239.12 }]);
        const [inputs, setInputs] = useState({ projectName: '', district: '南投縣中興新村', roads: [{ id: 1, name: '向陽路', width: 10, orientation: 'bottom', type: 'primary', edgeIndex: 2 }], zoneType: '住宅區', urbanPlanName: '中興新村都市計畫區', coverageRatio: 50, floorRatio: 150, excavationRatio: 60, floorsBelow: 1, avgCarArea: 35, frontYardDepth: 4, sideYardDepth: 1.5, sideYardDirection: 'right', backYardDepth: 3, floorHeight1F: 4.2, floorHeightOther: 3.6, baseWidth: '', incentiveArea: 0, transferArea: 0, minBackyardDepthRatio: 0, arcadeDepth: 0, floorsAbove: 4, northAngle: 0 });
        const [params, setParams] = useState({ exemptRate: 15, stairRate: 5, balconyRate: 10, pricePerPing: 25 });
        const [isEditMode, setIsEditMode] = useState(false);
        const [overrides, setOverrides] = useState({});
        const [showDetail, setShowDetail] = useState(true);
  const [showCheckLines, setShowCheckLines] = useState(true);
  const [showWeiLao, setShowWeiLao] = useState(false);
  const [isConstraintMode, setIsConstraintMode] = useState(false);

  const toggleConstraints = () => setIsConstraintMode(!isConstraintMode);

  const updateLot = (id, field, value) => { setLots(prev => prev.map(l => l.id === id ? { ...l, [field]: field === 'area' ? (parseFloat(value) || 0) : value } : l)); };
        const addLot = () => { const newId = Math.max(...lots.map(l => l.id), 0) + 1; setLots([...lots, { id: newId, lot: '', area: 0 }]); };
        const removeLot = (id) => { if (lots.length > 1) setLots(lots.filter(l => l.id !== id)); };
        const updateRoad = (id, field, value) => { setInputs(prev => ({ ...prev, roads: prev.roads.map(r => r.id === id ? { ...r, [field]: value } : r) })); };
        const addRoad = () => { const newId = Math.max(...inputs.roads.map(r => r.id), 0) + 1; setInputs(prev => ({ ...prev, roads: [...prev.roads, { id: newId, name: '新道路', width: 6, orientation: 'custom', type: 'secondary' }] })); };
        const removeRoad = (id) => { if (inputs.roads.length > 1) setInputs(prev => ({ ...prev, roads: prev.roads.filter(r => r.id !== id) })); };
        const handleUpdateRoads = (newRoads) => { setInputs(prev => ({ ...prev, roads: newRoads })); };

        const totalBaseArea = useMemo(() => lots.reduce((acc, curr) => acc + curr.area, 0), [lots]);
        
        const results = useMemo(() => {
          const base = inputs.baseArea || totalBaseArea;
          const maxBuildingArea = base * (inputs.coverageRatio / 100);
          const statutoryFA = base * (inputs.floorRatio / 100); 
          const exempt15 = statutoryFA * (params.exemptRate / 100);
          const exemptStair = statutoryFA * (params.stairRate / 100);
          const exemptIndoor = exempt15 + exemptStair;
          const balcony = statutoryFA * (params.balconyRate / 100);
          const incentive = parseFloat(inputs.incentiveArea) || 0;
          const transfer = parseFloat(inputs.transferArea) || 0;
          const permittedIndoor = statutoryFA + exemptIndoor + incentive + transfer;
          const roofProtrusion = maxBuildingArea * 0.125 * 2;
          const basementAreaPerFloor = base * (inputs.excavationRatio / 100);
          const totalBasementArea = basementAreaPerFloor * inputs.floorsBelow;
          
          const statutoryParking = Math.floor((statutoryFA + incentive + transfer) / 150); 
          const possibleParking = Math.floor(totalBasementArea / inputs.avgCarArea);
          
          const exemptBasement = statutoryParking * 40;
          
          // TASK: Total CFA should strictly be the limit (Statutory + Bonuses + Exempt), excluding basement variance?
          // Actually, "Total CFA" definition usually includes basement.
          // But to enforce the "Trade-off", we calculate Total CFA as the MAX ALLOWABLE BULK.
          // If we want adding basement to reduce above ground, we fix Total CFA.
          // Let's assume Total CFA = AboveGroundLimit + FixedBasementLimit?
          // No, simpler: Total CFA = PermittedIndoor + Balcony + RoofProtrusion + (ExemptBasement?).
          // Let's just exclude the variable `totalBasementArea` from the `totalCFA` sum here,
          // so it acts as a cap. If `totalBasementArea` grows, it consumes this fixed cap.
          // Wait, that means Total CFA is constant? Yes.
          
          // REVISED LOGIC: Total CFA = Permitted Above + Permitted Below.
          // But we want to simulate: "I have X ping. If I put 50 ping in basement, I have X-50 left for top."
          // So X (Total CFA) should NOT depend on how much basement I actually build.
          // It should depend on Statutory FA + Bonuses.
          // Let's define Total CFA as: Permitted Indoor + Balcony + Roof + (Basement * X floors?). 
          // No, let's fix it to: Permitted Indoor + Balcony + Roof. (Basically Above Ground Permitted).
          // And add a fixed buffer?
          // Or just use the override if available.
          
          // Actually, if we remove `totalBasementArea` from this sum, `totalCFA` becomes just the superstructure limit.
          // If we then say "Total Used" = Super + Basement, and limit it to `totalCFA`, then Basement eats Super.
          // This seems to be what the user wants.
          
          const totalCFA = permittedIndoor + balcony + roofProtrusion; // + totalBasementArea REMOVED for strict cap logic
          
          const efficiency = toPing(base) > 0 ? toPing(totalCFA + totalBasementArea) / toPing(base) : 0; // Efficiency includes everything
          
          const calculatedFloors = maxBuildingArea > 0 ? permittedIndoor / maxBuildingArea : 0;
          const floorsAbove = Math.ceil(calculatedFloors);
          const estimatedBudget = toPing(totalCFA + totalBasementArea) * params.pricePerPing; // Budget includes everything
          const fh1 = parseFloat(inputs.floorHeight1F) || 0;
          const fhO = parseFloat(inputs.floorHeightOther) || 0;
          const buildingHeight = fh1 + (fhO * Math.max(0, floorsAbove - 1)) + 9;
          const mainRoad = inputs.roads.find(r => r.type === 'primary') || inputs.roads[0];
          const roadWidth = mainRoad ? parseFloat(mainRoad.width) : 0;
          const frontYard = parseFloat(inputs.frontYardDepth) || 0;
          const backYard = parseFloat(inputs.backYardDepth) || 0;
          const heightRatio = (roadWidth + frontYard) > 0 ? buildingHeight / (roadWidth + frontYard) : 0;
          const backyardDepthRatio = backYard > 0 ? buildingHeight / backYard : 0;
          const isHighRise = buildingHeight > 24;
          const isSuperHighRise = buildingHeight > 100;
          const weiLaoRatio = (0.5 * roadWidth + frontYard) > 0 ? 5 / (0.5 * roadWidth + frontYard) : 0;

          return { base, maxBuildingArea, statutoryFA, exempt15, exemptStair, exemptIndoor, balcony, permittedIndoor, roofProtrusion, basementAreaPerFloor, totalBasementArea, totalCFA, efficiency, statutoryParking, possibleParking, calculatedFloors, floorsAbove, estimatedBudget, buildingHeight, heightRatio, backyardDepthRatio, isHighRise, isSuperHighRise, weiLaoRatio, exemptBasement };
        }, [inputs, totalBaseArea, params]);

        const finalRes = { ...results, ...overrides };
        
        useEffect(() => {
             setOverrides(prev => { const copy = {...prev}; delete copy.totalCFA; return copy; });
        }, [inputs.baseArea, inputs.floorRatio]);

        const handleInputChange = (e) => { const { name, value } = e.target; setInputs(prev => ({ ...prev, [name]: value })); };
        const handleOverride = (id, value) => { const val = parseFloat(value); if (!isNaN(val)) setOverrides(prev => ({ ...prev, [id]: val })); };
        const handleParamChange = (key, value) => { setParams(prev => ({ ...prev, [key]: parseFloat(value) || 0 })); };
        const updateBaseDim = (key, val) => { setInputs(prev => ({ ...prev, [key]: val })); };
        const handleUpdateInputs = (key, val) => { setInputs(prev => ({ ...prev, [key]: val })); };

        const inputClass = "w-full p-2 border border-stone-200 rounded-md outline-none transition-all focus:border-indigo-500 focus:ring-4 focus:ring-indigo-500/10 text-stone-700 text-sm num-font";
        const labelClass = "block text-sm font-bold text-stone-500 uppercase mb-1";

        return (
          <div className="min-h-screen bg-stone-50 p-4 md:p-8 text-stone-800">
            <div className="max-w-7xl mx-auto space-y-6">
              <header className="flex flex-col md:flex-row justify-between items-start md:items-center bg-white p-6 rounded-xl shadow-sm border border-stone-200">
                <div><h1 className="text-3xl font-serif font-bold flex items-center gap-3 text-stone-800"><Building2 className="text-stone-600" size={32} />自地自建評估計算書</h1><p className="text-stone-500 font-medium mt-1 ml-1">基地開發效益評估 / 容積獎勵檢討 / 停車空間規劃</p></div>
                <div className="flex items-center gap-4 mt-4 md:mt-0"><div className="flex flex-col mr-4"><label className="text-xs text-stone-400 font-bold uppercase">專案名稱</label><input type="text" name="projectName" value={inputs.projectName} onChange={handleInputChange} placeholder="輸入專案名稱" className="border-b border-stone-300 focus:border-stone-800 outline-none bg-transparent py-1 text-lg font-bold text-stone-800" /></div><button onClick={() => setIsEditMode(!isEditMode)} className={`w-12 h-12 flex items-center justify-center rounded-full transition-all duration-300 shadow-sm border ${isEditMode ? 'bg-stone-800 border-stone-800 text-white' : 'bg-white border-stone-200 text-stone-400 hover:border-stone-400'}`}>{isEditMode ? <Settings2 size={20} /> : <Pencil className="w-6 h-6" />}</button></div>
              </header>
              <Visualizer3D 
            inputs={{...inputs, baseArea: finalRes.base, floorsAbove: finalRes.floorsAbove}} 
            res={finalRes} 
            onUpdateBaseDim={updateBaseDim} 
            onUpdateRoads={handleUpdateRoads} 
            onUpdateInputs={handleUpdateInputs}
            showCheckLines={showCheckLines}
            setShowCheckLines={setShowCheckLines}
            showWeiLao={showWeiLao}
            setShowWeiLao={setShowWeiLao}
            isConstraintMode={isConstraintMode}
            setIsConstraintMode={setIsConstraintMode}
        />
              <div className="grid grid-cols-1 xl:grid-cols-3 gap-6">
                <CollapsibleSection title="基本資料" icon={<MapPin size={18} className="text-rose-500" />} className="xl:col-span-1">
                  <div className="space-y-3">
                    <div><label className={labelClass}>行政區</label><input type="text" name="district" value={inputs.district} onChange={handleInputChange} className={inputClass} /></div>
                    <div className="space-y-2"><div className="flex justify-between items-center"><label className={labelClass}>地號與面積 (㎡)</label><button onClick={addLot} className="text-indigo-500 hover:text-indigo-700 text-sm flex items-center gap-1"><Plus size={12} /> 新增</button></div><div className="max-h-40 overflow-y-auto pr-1 space-y-2">{lots.map(l => (<div key={l.id} className="flex gap-2 items-center group"><input type="text" placeholder="地號" value={l.lot} onChange={(e) => updateLot(l.id, 'lot', e.target.value)} className={`${inputClass} text-sm`} /><input type="number" placeholder="面積" value={l.area} onChange={(e) => updateLot(l.id, 'area', e.target.value)} className={`${inputClass} text-sm w-24 text-right`} />{lots.length > 1 && <button onClick={() => removeLot(l.id)} className="text-stone-300 hover:text-rose-500"><Trash2 size={14} /></button>}</div>))}</div><div className="text-right text-sm font-bold text-stone-500 pt-1 border-t">合計: {formatNum(totalBaseArea)} ㎡ ({formatNum(toPing(totalBaseArea))} 坪)</div></div>
                    <div className="space-y-3 mt-4 pt-4 border-t border-stone-100"><div className="flex justify-between items-center"><label className={labelClass}>臨路狀況</label><button onClick={addRoad} className="text-indigo-500 hover:text-indigo-700 text-sm flex items-center gap-1"><Plus size={12} /> 新增道路</button></div><div className="space-y-2"><div className="grid grid-cols-12 gap-2 text-xs text-stone-400 font-bold mb-1 px-1"><div className="col-span-4">路名</div><div className="col-span-2 text-center">寬(M)</div><div className="col-span-3">方位</div><div className="col-span-2 text-center">主要</div><div className="col-span-1"></div></div><div className="max-h-40 overflow-y-auto pr-1 space-y-2">{inputs.roads.map(r => (<div key={r.id} className="grid grid-cols-12 gap-2 items-center bg-stone-50 p-2 rounded border border-stone-100"><div className="col-span-4"><input type="text" value={r.name} onChange={(e) => updateRoad(r.id, 'name', e.target.value)} className={`${inputClass} py-1 text-sm`} placeholder="路名"/></div><div className="col-span-2"><input type="number" value={r.width} onChange={(e) => updateRoad(r.id, 'width', e.target.value)} className={`${inputClass} py-1 text-sm text-center`} placeholder="M"/></div><div className="col-span-3 text-xs text-stone-500 text-center">{r.edgeIndex !== undefined ? `邊線 ${r.edgeIndex}` : (r.orientation==='custom'?'自訂':r.orientation)}</div><div className="col-span-2 flex justify-center"><input type="checkbox" checked={r.type === 'primary'} onChange={(e) => updateRoad(r.id, 'type', e.target.checked ? 'primary' : 'secondary')} className="w-4 h-4 rounded border-stone-300 text-indigo-600 focus:ring-indigo-500 cursor-pointer"/></div><div className="col-span-1 text-center">{inputs.roads.length > 1 && <button onClick={() => removeRoad(r.id)} className="text-stone-300 hover:text-rose-500"><Trash2 size={14} /></button>}</div></div>))}</div></div></div>
                    <div className="mt-4 pt-4 border-t border-stone-100"><div className="flex justify-between items-center mb-2"><h4 className="text-xs font-bold text-stone-500 uppercase flex items-center gap-1"><Ruler size={12} /> 基地形狀設定 (3D)</h4></div><div className="grid grid-cols-2 gap-2"><div><label className="text-[10px] text-stone-400 block">面寬 (Width)</label><input type="number" value={inputs.baseWidth || Math.sqrt(totalBaseArea || 100).toFixed(1)} onChange={(e) => updateBaseDim('baseWidth', e.target.value)} className="w-full border border-stone-200 rounded p-1 text-sm font-bold text-stone-700 bg-stone-50 focus:bg-white focus:ring-2 ring-indigo-100 outline-none num-font" /></div><div><label className="text-[10px] text-stone-400 block">深度 (Depth)</label><input type="number" value={((totalBaseArea || 100) / (parseFloat(inputs.baseWidth) || Math.sqrt(totalBaseArea || 100))).toFixed(1)} onChange={(e) => { const val = parseFloat(e.target.value); if (val > 0 && totalBaseArea > 0) updateBaseDim('baseWidth', (totalBaseArea/val).toFixed(2)); }} className="w-full border border-stone-200 rounded p-1 text-sm font-bold text-stone-700 bg-stone-50 focus:bg-white focus:ring-2 ring-indigo-100 outline-none num-font" /></div></div></div>
                  </div>
                </CollapsibleSection>
                <CollapsibleSection title="法規參數" icon={<FileText size={18} className="text-sky-500" />} className="xl:col-span-1">
                  <div className="space-y-3">
                    <div><label className={labelClass}>使用分區</label><input type="text" name="zoneType" value={inputs.zoneType} onChange={handleInputChange} className={inputClass} /></div>
                    <div><label className={labelClass}>都市計畫名稱</label><input type="text" name="urbanPlanName" value={inputs.urbanPlanName} onChange={handleInputChange} className={inputClass} /></div>
                    <div className="grid grid-cols-2 gap-3"><div><label className={`${labelClass} text-sky-600`}>建蔽率 (%)</label><input type="number" name="coverageRatio" value={inputs.coverageRatio} onChange={handleInputChange} className={`${inputClass} font-bold text-sky-700`} /></div><div><label className={`${labelClass} text-sky-600`}>容積率 (%)</label><input type="number" name="floorRatio" value={inputs.floorRatio} onChange={handleInputChange} className={`${inputClass} font-bold text-sky-700`} /></div></div>
                    <div><label className={`${labelClass} text-amber-600`}>地下室開挖率 (%)</label><input type="number" name="excavationRatio" value={inputs.excavationRatio} onChange={handleInputChange} className={`${inputClass} text-amber-700`} /></div>
                  </div>
                </CollapsibleSection>
                <CollapsibleSection title="樓層規劃" icon={<Layers size={18} className="text-indigo-500" />} className="xl:col-span-1">
                  <div className="space-y-3">
                    <div className="grid grid-cols-2 gap-3"><div><label className={labelClass}>地上樓層數 (預估)</label><div className={`${inputClass} bg-stone-50 font-bold text-indigo-600 flex items-center justify-between`}><span>{finalRes.floorsAbove}F</span><span className="text-xs text-stone-400 font-normal">(C8/A2={formatNum(finalRes.calculatedFloors)})</span></div></div><div><label className={labelClass}>地下樓層數</label><input type="number" name="floorsBelow" value={inputs.floorsBelow} onChange={handleInputChange} className={inputClass} /></div></div>
                    <div><label className={labelClass}>允建總樓地板面積 (Total CFA)</label><div className={`${inputClass} bg-stone-50 text-xl font-bold text-right flex items-center justify-between text-indigo-800`}><span className="text-xs text-indigo-300 font-normal">Auto Calc</span>{formatNum(finalRes.totalCFA)}</div></div>
                  </div>
                </CollapsibleSection>
              </div>
              <div className="bg-white rounded-xl shadow-sm overflow-hidden border border-stone-200">
                <div className="p-4 bg-stone-100 border-b border-stone-200 flex justify-between items-center cursor-pointer hover:bg-stone-100 transition-colors" onClick={() => setShowDetail(!showDetail)}><h3 className="font-bold text-stone-700 flex items-center gap-2"><FileText size={18} /> 詳細計算表</h3><div className="text-stone-500">{showDetail ? <ChevronUp size={20} /> : <ChevronDown size={20} />}</div></div>
                <div className={`transition-all duration-500 ease-in-out overflow-hidden ${showDetail ? 'max-h-[2500px] opacity-100' : 'max-h-0 opacity-0'}`}>
                   <div className="overflow-x-auto">
                      <table className="w-full text-left border-collapse num-font">
                         <thead><tr className="bg-stone-50 text-stone-600 text-sm border-b border-stone-300"><th className="p-4 w-1/4">評估項目</th><th className="p-4 w-1/6 text-right">數值/面積 (㎡)</th><th className="p-4 w-1/6 text-right">坪數 (坪)</th>{isEditMode && <><th className="p-4 text-indigo-700 bg-indigo-50/50 w-1/4">參數設定</th><th className="p-4 text-indigo-700 bg-indigo-50/50">註解與說明</th></>}</tr></thead>
                         <tbody className="text-stone-700 divide-y divide-stone-100">
                            <SectionHeader title="A. 基地基礎法規檢討" />
                            <InputRow id="base" label="1. 基地面積" value={finalRes.base} calculatedValue={results.base} formula="SUM(地號面積)" note="多筆地號加總" isEditMode={isEditMode} onOverride={handleOverride} />
                            <InputRow id="maxBuildingArea" label="2. 允建建築面積" value={finalRes.maxBuildingArea} calculatedValue={results.maxBuildingArea} formula="基地面積 × 法定建蔽率" note={`建蔽率 ${inputs.coverageRatio}%，單層最大面積`} isEditMode={isEditMode} onOverride={handleOverride} highlight />
                            <InputRow id="statutoryFA" label="3. 法定容積 (FA)" value={finalRes.statutoryFA} calculatedValue={results.statutoryFA} formula="基地面積 × 法定容積率" note={`容積率 ${inputs.floorRatio}%，不含獎勵`} isEditMode={isEditMode} onOverride={handleOverride} highlight />
                            <SectionHeader title="B. 免計容積與獎勵試算" />
                            <InputRow id="incentiveArea" label="4. 獎勵容積" value={inputs.incentiveArea} calculatedValue={inputs.incentiveArea} formula="自行輸入" note="都更、危老等獎勵" isEditMode={isEditMode} onOverride={handleInputChange} />
                            <InputRow id="transferArea" label="5. 移轉容積" value={inputs.transferArea} calculatedValue={inputs.transferArea} formula="自行輸入" note="容積移轉" isEditMode={isEditMode} onOverride={handleInputChange} />
                            <InputRow id="exempt15" label={`6. 免計容積 (${params.exemptRate}%)`} value={finalRes.exempt15} calculatedValue={results.exempt15} formula="法定容積 FA × 免計率" note="機電設備、安全梯等 (法規上限)" isEditMode={isEditMode} onOverride={handleOverride} paramKey="exemptRate" paramValue={params.exemptRate} onParamChange={handleParamChange} />
                            <InputRow id="exemptStair" label="7. 免計梯廳" value={finalRes.exemptStair} calculatedValue={results.exemptStair} formula={`法定容積 FA × ${params.stairRate}%`} note="梯廳獎勵，需視設計而定" isEditMode={isEditMode} onOverride={handleOverride} paramKey="stairRate" paramValue={params.stairRate} onParamChange={handleParamChange} />
                            <InputRow id="exemptIndoor" label="8. 免計容積室內合計" value={finalRes.exemptIndoor} calculatedValue={results.exemptIndoor} formula="Item 6 + Item 7" note="免計容積總和" isEditMode={isEditMode} onOverride={handleOverride} subTotal />
                            <InputRow id="balcony" label="9. 免計容積陽台" value={finalRes.balcony} calculatedValue={results.balcony} formula={`法定容積 FA × ${params.balconyRate}%`} note="每層樓地板 1/8 或 FA 10%" isEditMode={isEditMode} onOverride={handleOverride} paramKey="balconyRate" paramValue={params.balconyRate} onParamChange={handleParamChange} />
                            <SectionHeader title="C. 允建面積總表" />
                            <InputRow id="permittedIndoor" label="10. 允建室內面積" value={finalRes.permittedIndoor} calculatedValue={results.permittedIndoor} formula="法定 + 獎勵 + 移轉 + 免計" note="不含陽台之室內實際使用空間" isEditMode={isEditMode} onOverride={handleOverride} bold />
                            <InputRow id="roofProtrusion" label="11. 允建屋突面積" value={finalRes.roofProtrusion} calculatedValue={results.roofProtrusion} formula="(建築面積 × 1/8) × 2層" note="屋頂突出物 (水箱、電梯機房)" isEditMode={isEditMode} onOverride={handleOverride} />
                            <InputRow id="totalBasementArea" label="12. 地下室總面積" value={finalRes.totalBasementArea} calculatedValue={results.totalBasementArea} formula="基地 × 開挖率 × 地下層數" note={`開挖率 ${inputs.excavationRatio}%，地下 ${inputs.floorsBelow} 層`} isEditMode={isEditMode} onOverride={handleOverride} />
                            <tr className="bg-amber-50 border-y-2 border-amber-200"><td className="p-4 font-bold text-stone-800 text-lg">13. 允建總樓地板面積 (Total CFA)</td><td className="p-4 text-right font-bold text-stone-800 text-lg">{isEditMode ? (<div className="flex items-center justify-end gap-2">{Math.abs(finalRes.totalCFA - results.totalCFA) > 0.01 && <div className="text-red-500 flex items-center text-xs" title="與公式計算值衝突"><AlertTriangle size={14}/></div>}<input type="number" value={finalRes.totalCFA} onChange={(e) => handleOverride('totalCFA', e.target.value)} className="w-24 p-1 text-right border border-stone-300 rounded bg-white"/></div>) : formatNum(finalRes.totalCFA)}</td><td className="p-4 text-right font-bold text-stone-800 text-lg">{formatNum(toPing(finalRes.totalCFA))}</td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-600">允建室內+陽台+屋突</td><td className="p-4 text-sm text-stone-600">鎖定上限 (含獎勵/免計)</td></>}</tr>
                            <tr className="bg-stone-100 border-y-2 border-stone-200"><td className="p-4 font-bold text-stone-700 text-lg">工程預算評估</td><td className="p-4 text-right font-bold text-stone-700 text-lg" colSpan={2}><div className="flex items-center justify-end gap-2"><span className="text-sm text-stone-500 font-normal mr-2">單價(萬/坪):</span>{isEditMode ? <input type="number" value={params.pricePerPing} onChange={(e) => handleParamChange('pricePerPing', e.target.value)} className="w-20 p-1 text-right border border-stone-300 rounded bg-white font-bold"/> : <span className="font-bold underline decoration-dotted decoration-stone-400">{params.pricePerPing}</span>}<span className="text-sm text-stone-500 mx-2">=</span><span>{formatNum(finalRes.estimatedBudget)} 萬</span></div></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">Total CFA (坪) × 單價</td><td className="p-4 text-sm text-stone-500">概估造價 (未含設計監造/稅)</td></>}</tr>
                            <SectionHeader title="D. 空間與停車檢討" />
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">12. 地上樓層估算</td><td className="p-4 text-right" colSpan={2}>約 <span className="font-bold text-indigo-600">{formatNum(finalRes.floorsAbove)}</span> 層</td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">C8 / A2</td><td className="p-4 text-sm text-stone-500">允建室內 / 允建建築面積</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">13. 地下層開挖檢討</td><td className="p-4 text-right" colSpan={2}>B1 ~ B{inputs.floorsBelow} (單層 {formatNum(toPing(finalRes.basementAreaPerFloor))} 坪)</td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">基地 × {inputs.excavationRatio}%</td><td className="p-4 text-sm text-stone-500">單層最大開挖面積</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium flex items-center gap-2"><Car size={16}/> 14. 停車空間檢討</td><td className="p-4 text-right" colSpan={2}>法定約 {formatNum(finalRes.statutoryParking)} 部 / 空間可停 {formatNum(finalRes.possibleParking)} 部</td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">總樓地板/150 (法定)</td><td className="p-4 text-sm text-stone-500">空間以每車 {inputs.avgCarArea}m² 預估</td></>}</tr>
                             <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">*. 地下室免計容積</td><td className="p-4 text-right" colSpan={2}>{formatNum(finalRes.exemptBasement)} ㎡ ({formatNum(toPing(finalRes.exemptBasement))} 坪)</td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">40 × 法定停車</td><td className="p-4 text-sm text-stone-500">地下室停車免計面積</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">15. 坪效分析 (倍數)</td><td className="p-4 text-right font-bold text-emerald-600" colSpan={2}>{formatNum(finalRes.efficiency)} 倍</td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">總銷坪 / 基地坪</td><td className="p-4 text-sm text-stone-500">投入 1 坪土地可蓋出的坪數</td></>}</tr>
                            <SectionHeader title="E. 高度比檢討" />
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">16. 前院深度</td><td className="p-4 text-right"><div className="flex items-center justify-end gap-2"><input type="number" name="frontYardDepth" value={inputs.frontYardDepth} onChange={handleInputChange} className="w-20 p-1 text-right border border-stone-300 rounded"/> m</div></td><td className="p-4 text-right text-stone-500"></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">自行輸入</td><td className="p-4 text-sm text-stone-500">3D圖面顯示退縮</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">17. 側院深度</td><td className="p-4 text-right"><div className="flex items-center justify-end gap-2"><select name="sideYardDirection" value={inputs.sideYardDirection} onChange={handleInputChange} className="p-1 border border-stone-300 rounded text-xs bg-stone-50"><option value="right">右側</option><option value="left">左側</option></select><input type="number" name="sideYardDepth" value={inputs.sideYardDepth} onChange={handleInputChange} className="w-20 p-1 text-right border border-stone-300 rounded"/> m</div></td><td className="p-4 text-right text-stone-500"></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">選單邊</td><td className="p-4 text-sm text-stone-500">3D圖面顯示退縮</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">18. 後院深度</td><td className="p-4 text-right"><div className="flex items-center justify-end gap-2"><input type="number" name="backYardDepth" value={inputs.backYardDepth} onChange={handleInputChange} className="w-20 p-1 text-right border border-stone-300 rounded"/> m</div></td><td className="p-4 text-right text-stone-500"></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">自行輸入</td><td className="p-4 text-sm text-stone-500">3D圖面顯示退縮</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">19. 樓層高度設定</td><td className="p-4 text-right" colSpan={2}><div className="flex flex-col gap-2 items-end"><div className="flex items-center gap-2"><span className="text-xs text-stone-500">1F:</span><input type="number" name="floorHeight1F" value={inputs.floorHeight1F} onChange={handleInputChange} className={`w-16 p-1 text-right border rounded ${inputs.zoneType === '住宅區' && parseFloat(inputs.floorHeight1F) > 4.2 ? 'border-rose-400 bg-rose-50' : 'border-stone-300'}`}/>{inputs.arcadeDepth > 0 && inputs.frontYardDepth == 0 && parseFloat(inputs.floorHeight1F) < 3 && <span className="text-[10px] text-red-500 font-bold bg-red-50 px-1 rounded animate-pulse">騎樓需&gt;3m</span>}</div><div className="flex items-center gap-2"><span className="text-xs text-stone-500">其他:</span><input type="number" name="floorHeightOther" value={inputs.floorHeightOther} onChange={handleInputChange} className={`w-16 p-1 text-right border rounded ${inputs.zoneType === '住宅區' && parseFloat(inputs.floorHeightOther) > 3.6 ? 'border-rose-400 bg-rose-50' : 'border-stone-300'}`}/></div></div></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">住宅區 1F≤4.2, 其他≤3.6</td><td className="p-4 text-sm text-stone-500">自行輸入 (超限變紅)</td></>}</tr>
                            <InputRow id="buildingHeight" label="20. 建築物高度" value={finalRes.buildingHeight} calculatedValue={finalRes.buildingHeight} formula="1F+(其他×(F-1))+9" note={finalRes.isSuperHighRise ? "超高層建築 (>100m)" : finalRes.isHighRise ? "高層建築 (>24m)" : "一般建築"} isEditMode={isEditMode} onOverride={handleOverride} highlight />
                            <InputRow id="heightRatio" label="21. 高度比" value={finalRes.heightRatio} calculatedValue={finalRes.heightRatio} formula="高度 / (路寬+前院)" note="建築高度 / (主路寬+前院深)" isEditMode={isEditMode} onOverride={handleOverride} highlight />
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">22. 最小後院深度比 (檢討)</td><td className="p-4 text-right"><div className="flex flex-col items-end gap-1"><div className="flex items-center justify-end gap-2"><input type="number" name="minBackyardDepthRatio" value={inputs.minBackyardDepthRatio || 0} onChange={handleInputChange} className="w-20 p-1 text-right border border-stone-300 rounded"/></div>{inputs.minBackyardDepthRatio > 0 && (<div className="flex items-center gap-2 mt-1"><input type="color" name="backyardLineColor" value={inputs.backyardLineColor || "#22c55e"} onChange={handleInputChange} className="w-6 h-6 rounded cursor-pointer border-none" title="線條顏色"/><label className="flex items-center gap-1 text-xs text-stone-500"><input type="checkbox" name="backyardLineDashed" checked={inputs.backyardLineDashed !== false} onChange={(e) => handleInputChange({target: {name: 'backyardLineDashed', value: e.target.checked}})} />虛線</label><label className="flex items-center gap-1 text-xs text-stone-500"><input type="checkbox" name="backyardLineThick" checked={inputs.backyardLineThick !== false} onChange={(e) => handleInputChange({target: {name: 'backyardLineThick', value: e.target.checked}})} />粗線</label></div>)}</div></td><td className="p-4 text-right text-stone-500"></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">自行輸入</td><td className="p-4 text-sm text-stone-500">決定後院檢討線斜率與樣式</td></>}</tr>
                            <InputRow id="weiLaoRatio" label="23. 危老評估 (路心比)" value={finalRes.weiLaoRatio} calculatedValue={finalRes.weiLaoRatio} formula="5 / (0.5×路寬 + 前院)" note="危老條例高度檢討係數" isEditMode={isEditMode} onOverride={handleOverride} highlight />
                            {inputs.frontYardDepth == 0 && (
                                <tr className="hover:bg-indigo-50/30 border-t-2 border-indigo-100">
                                   <td className="p-4 pl-8 border-l-4 border-indigo-400 font-bold text-indigo-700">24. 騎樓深度</td>
                                   <td className="p-4 text-right">
                                       <div className="flex items-center justify-end gap-2">
                                           <input type="number" name="arcadeDepth" value={inputs.arcadeDepth} onChange={handleInputChange} className="w-20 p-1 text-right border border-indigo-300 rounded font-bold text-indigo-600 bg-white"/> m
                                       </div>
                                   </td>
                                   <td className="p-4 text-right text-stone-500"></td>
                                   {isEditMode && <><td className="p-4 font-mono text-xs text-indigo-500">僅當前院=0時可用</td><td className="p-4 text-sm text-indigo-500">設定後1F自動退縮，樓高需&gt;3m</td></>}
                                </tr>
                            )}
                         </tbody>
                      </table>
                   </div>
                </div>
              </div>

            </div>
          </div>
        );
      };

      const root = createRoot(document.getElementById('root'));
      root.render(<Cal />);
    </script>
  </body>
</html>