<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>自地自建評估計算書</title>

    <!-- 1. 引入 Babel (用於瀏覽器端編譯 JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 2. 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Tailwind Config -->
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['GenYoGothic', 'sans-serif'],
            },
            cursor: {
              grab: 'grab',
              grabbing: 'grabbing',
            }
          },
        },
      }
    </script>

    <style>
      @font-face {
        font-family: 'GenYoGothic';
        src: local('GenYoGothic'), local('源樣黑體'), local('Noto Sans TC');
      }
      body {
        background-color: #f5f5f4;
        font-family: 'GenYoGothic', sans-serif;
        overflow-x: hidden;
        overscroll-behavior-y: none; 
      }
      .num-font {
        font-variant-numeric: tabular-nums;
      }
      .no-scrollbar::-webkit-scrollbar {
        display: none;
      }
      .no-scrollbar {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }
      @keyframes riseUp {
        0% { transform: translate3d(var(--tx), var(--ty), -50px); opacity: 0; }
        100% { transform: translate3d(var(--tx), var(--ty), var(--tz)); opacity: 1; }
      }
      @keyframes slideUp {
        from { transform: translateY(100%); }
        to { transform: translateY(0); }
      }
      .animate-slide-up {
        animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      }
      @keyframes pulse-ring {
        0% { transform: scale(0.8); opacity: 0.8; }
        100% { transform: scale(1.5); opacity: 0; }
      }
      .animate-pulse-ring::before {
        content: '';
        position: absolute;
        left: -50%; top: -50%; width: 200%; height: 200%;
        border-radius: 50%;
        border: 2px solid #0ea5e9;
        animation: pulse-ring 1.5s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <!-- 注意：使用 type="text/babel" data-type="module" -->
    <script type="text/babel" data-type="module">
      import React, { useState, useMemo, useEffect, useRef } from 'https://esm.sh/react@18.2.0';
      import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client';
      import { 
        MapPin, Ruler, FileText, Info, Building2, Car, Layers, 
        ArrowDownUp, AlertTriangle, Bike, Compass, Plus, Trash2, 
        ChevronDown, ChevronUp, ChevronRight, ChevronLeft, Map, LayoutDashboard, Settings2, 
        Pencil, RefreshCw, RotateCw, Eye, Maximize, ToggleLeft, 
        ToggleRight, Box, Sun, Moon, ZoomIn, ZoomOut, PanelRightClose, PanelRightOpen,
        AlignLeft, AlignCenter, AlignRight, AlignVerticalJustifyCenter, ArrowUpToLine, ArrowDownToLine,
        Edit3, RotateCcw, Undo2, CheckCircle2, GripHorizontal, Copy, Move, Maximize2, Lock, Unlock,
        Grid, X, LayoutTemplate, MoreVertical, Hexagon, CheckSquare, Square, Scaling, Settings,
        ParkingCircle, Warehouse, MousePointer2, PlusCircle
      } from 'https://esm.sh/lucide-react@0.263.1';

      // --- Helper Functions ---
      const formatNum = (num) => {
        return new Intl.NumberFormat('zh-TW', {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        }).format(num || 0);
      };

      const toSqm = (ping) => ping * 3.3058;
      const toPing = (sqm) => sqm * 0.3025;
      
      const generateSvgPath = (points, curves, scale = 1, offsetX = 0, offsetY = 0) => {
          if (!points || points.length === 0) return "";
          let d = `M ${(points[0].x * scale) + offsetX} ${(points[0].y * scale) + offsetY}`;
          for (let i = 0; i < points.length; i++) {
              const nextP = points[(i + 1) % points.length];
              const curve = curves ? curves[i] : null;
              if (curve) {
                  d += ` Q ${(curve.x * scale) + offsetX} ${(curve.y * scale) + offsetY}, ${(nextP.x * scale) + offsetX} ${(nextP.y * scale) + offsetY}`;
              } else {
                  d += ` L ${(nextP.x * scale) + offsetX} ${(nextP.y * scale) + offsetY}`;
              }
          }
          d += " Z";
          return d;
      };

      // --- Components ---

      const EditableInput = ({ value, onChange, className, step, disabled }) => {
        const [localVal, setLocalVal] = useState(value);
        const [isEditing, setIsEditing] = useState(false);

        useEffect(() => {
            if (!isEditing) {
                setLocalVal(typeof value === 'number' ? parseFloat(value.toFixed(2)) : value);
            }
        }, [value, isEditing]);

        const handleChange = (e) => {
            setLocalVal(e.target.value);
        };

        const handleBlur = () => {
            setIsEditing(false);
            if (localVal !== "" && !isNaN(parseFloat(localVal))) {
                onChange(parseFloat(localVal));
            } else {
                setLocalVal(parseFloat(value.toFixed(2)));
            }
        };

        const handleKeyDown = (e) => {
            if (e.key === 'Enter') e.target.blur();
        };

        return (
            <input
                type="number"
                value={localVal}
                onChange={handleChange}
                onFocus={() => setIsEditing(true)}
                onBlur={handleBlur}
                onKeyDown={handleKeyDown}
                step={step}
                className={className}
                disabled={disabled}
            />
        );
      };

      // Optimized Compass: Uses CSS Variable for rotation
      const ArtisticCompass = ({ className, rotation, isDarkMode }) => (
        <div className={`${className} relative flex items-center justify-center opacity-80 transition-transform duration-300 ease-out`} 
             style={{ transform: `rotate(calc(-1 * var(--rotZ, ${-rotation}deg)))` }}>
          <svg viewBox="0 0 100 100" className="w-full h-full drop-shadow-lg">
            <circle cx="50" cy="50" r="46" fill={isDarkMode ? "#1e293b" : "#f8fafc"} stroke={isDarkMode ? "#475569" : "#94a3b8"} strokeWidth="1.5" />
            <circle cx="50" cy="50" r="42" fill="none" stroke={isDarkMode ? "#64748b" : "#cbd5e1"} strokeWidth="0.5" strokeDasharray="3 3" />
            <line x1="50" y1="4" x2="50" y2="96" stroke={isDarkMode ? "#334155" : "#e2e8f0"} strokeWidth="0.5" />
            <line x1="4" y1="50" x2="96" y2="50" stroke={isDarkMode ? "#334155" : "#e2e8f0"} strokeWidth="0.5" />
            <path d="M 50 10 L 55 50 L 50 50 L 45 50 Z" fill="#ef4444" />
            <text x="50" y="24" textAnchor="middle" fontSize="8" fontWeight="bold" fill={isDarkMode ? "#e2e8f0" : "#334155"} className="font-serif">N</text>
            <circle cx="50" cy="50" r="2" fill={isDarkMode ? "#e2e8f0" : "#475569"} />
          </svg>
        </div>
      );

      // Floor Info Card
      const FloorInfoCard = ({ data, isDarkMode, onReset, isConstraintMode }) => {
        const [position, setPosition] = useState({ x: 0, y: 0 });
        
        if (!data) return null;

        return (
          <div 
            className={`absolute z-50 pointer-events-auto transition-opacity duration-300 ease-out ${data ? 'opacity-100' : 'opacity-0'}`}
            style={{ 
                top: '50%', left: '50%', 
                transform: `translate(calc(-50% + ${position.x}px), calc(-50% + ${position.y}px - 140px))` 
            }}
          >
             <div className={`backdrop-blur-md border rounded-xl shadow-2xl p-4 min-w-[160px] ${isDarkMode ? 'bg-slate-800/90 border-slate-600 text-white' : 'bg-white/95 border-stone-200 text-stone-700'}`}>
                <div className="flex justify-between items-center mb-2 pb-2 border-b border-stone-200/20">
                    <h3 className="font-bold text-lg flex items-center gap-2">
                        <Layers size={16} className="text-indigo-500"/>
                        {data.id} 樓板
                    </h3>
                    {!isConstraintMode && <button onClick={() => onReset(data.id)} className="p-1 hover:bg-black/10 rounded" title="重置設定"><Undo2 size={14}/></button>}
                </div>
                <div className="space-y-2 text-sm">
                    <div className="flex justify-between items-end">
                        <span className="opacity-60 text-xs">面積</span>
                        <span className="font-bold text-xl num-font text-indigo-600">{formatNum(toPing(data.realArea))} <span className="text-xs text-stone-400 font-normal">坪</span></span>
                    </div>
                     {data.points && (
                         <div className="text-center py-1 text-xs text-stone-400 bg-stone-100/50 rounded mt-1">
                            自訂多邊形
                         </div>
                     )}
                </div>
             </div>
          </div>
        );
      };

      const EditMenu2D = ({ data, isDarkMode, onUpdateSetting, onReset, isOpen, onClose, scale3d }) => {
          const [activeTab, setActiveTab] = useState(null); 
          const [lockedParam, setLockedParam] = useState(null);

          if (!data || !isOpen) return null;

          const pingValue = toPing(data.realArea);
          const points = data.points; 

          const handleArea = (val) => {
              const newAreaSqm = toSqm(val);
              if (points) {
                  const currentArea = data.realArea;
                  const scale = Math.sqrt(newAreaSqm / currentArea);
                  const newPoints = points.map(p => ({ x: p.x * scale, y: p.y * scale }));
                  onUpdateSetting(data.id, 'points', newPoints);
              } else {
                  if (lockedParam === 'width') onUpdateSetting(data.id, 'depth', newAreaSqm/data.realWidth);
                  else if (lockedParam === 'depth') onUpdateSetting(data.id, 'width', newAreaSqm/data.realDepth);
                  onUpdateSetting(data.id, 'area', newAreaSqm);
              }
          };

          const handleWidth = (val) => onUpdateSetting(data.id, 'width', val);
          const handleDepth = (val) => onUpdateSetting(data.id, 'depth', val);
          
          const handleAlign = (axis, val) => onUpdateSetting(data.id, `align_${axis}`, val);
          const handleRotation = (val) => onUpdateSetting(data.id, 'rotation', val);
          const handlePivot = (axis, val) => onUpdateSetting(data.id, `pivot${axis}`, val);

          const handleConvertToPolygon = () => {
              const w = data.realWidth; 
              const d = data.realDepth;
              const pts = [
                  {x: -w/2, y: -d/2}, 
                  {x: w/2, y: -d/2}, 
                  {x: w/2, y: d/2}, 
                  {x: -w/2, y: d/2}
              ];
              onUpdateSetting(data.id, 'points', pts);
          };
          
          const handleResetShape = () => {
              onUpdateSetting(data.id, 'points', null);
              onUpdateSetting(data.id, 'curves', null);
          };

          const handlePointChange = (idx, axis, val) => {
             const newPoints = [...points];
             newPoints[idx] = { ...newPoints[idx], [axis]: parseFloat(val) };
             onUpdateSetting(data.id, 'points', newPoints);
          };

          const toggleTab = (t) => setActiveTab(prev => prev === t ? null : t);
          const toggleLock = (p) => setLockedParam(prev => prev === p ? null : p);
          
          const LockBtn = ({p}) => (
              <button onClick={(e) => {e.stopPropagation(); toggleLock(p);}} className={`p-1 rounded ${lockedParam===p?'bg-indigo-100 text-indigo-600':'text-gray-400'}`}>
                  {lockedParam===p?<Lock size={12}/>:<Unlock size={12}/>}
              </button>
          );

          return (
              <div 
                  className={`absolute bottom-0 left-0 right-0 z-50 rounded-t-2xl shadow-2xl animate-slide-up border-t border-stone-200 transition-all duration-300 ${isDarkMode ? 'bg-slate-800 text-white border-slate-700' : 'bg-white text-stone-800'}`}
                  onClick={(e) => e.stopPropagation()} 
              >
                  <div className="flex items-center justify-between p-3 cursor-default">
                      <div className="flex items-center gap-3">
                          <span className="font-bold text-lg flex items-center gap-1">
                              <Layers size={18} className="text-indigo-500"/>
                              {data.id}
                          </span>
                          <div className="flex flex-col">
                              <span className="text-xs opacity-50">面積</span>
                              <span className="font-bold font-mono">{formatNum(pingValue)}坪</span>
                          </div>
                      </div>
                      
                      <div className="flex gap-2">
                          <button onClick={() => toggleTab('size')} className={`flex items-center gap-1 px-3 py-1.5 rounded-full text-xs font-bold transition-colors ${activeTab==='size' ? 'bg-indigo-100 text-indigo-600' : 'bg-stone-100 hover:bg-stone-200 text-stone-600'}`}><Scaling size={14}/> 尺寸</button>
                          <button onClick={() => toggleTab('pos')} className={`flex items-center gap-1 px-3 py-1.5 rounded-full text-xs font-bold transition-colors ${activeTab==='pos' ? 'bg-indigo-100 text-indigo-600' : 'bg-stone-100 hover:bg-stone-200 text-stone-600'}`}><Move size={14}/> 位置</button>
                          <button onClick={() => toggleTab('shape')} className={`flex items-center gap-1 px-3 py-1.5 rounded-full text-xs font-bold transition-colors ${activeTab==='shape' ? 'bg-indigo-100 text-indigo-600' : 'bg-stone-100 hover:bg-stone-200 text-stone-600'}`}><Hexagon size={14}/> 形狀</button>
                      </div>
                  </div>

                  {activeTab && (
                      <div className="p-4 border-t border-stone-100/10 min-h-[180px] animate-slide-up">
                          {activeTab === 'size' && (
                              <div className="space-y-4">
                                  <div className="flex items-center justify-between gap-4 bg-stone-50/50 p-2 rounded-lg">
                                      <div className="flex items-center gap-2"><Edit3 size={14} className="opacity-50"/><label className="text-xs font-bold opacity-70">設計面積 {points && "(多邊形縮放)"}</label></div>
                                      <div className="flex items-center gap-2 flex-1 justify-end">
                                          <EditableInput value={pingValue} onChange={handleArea} step="0.5" className={`w-24 p-1 text-right font-bold text-lg border-b-2 outline-none bg-transparent ${lockedParam==='area'?'border-indigo-400':'border-stone-300'}`} />
                                          <span className="text-xs opacity-50">坪</span>
                                          {!points && <LockBtn p="area"/>}
                                      </div>
                                  </div>
                                  {points ? <div className="text-center text-xs opacity-60">多邊形模式下僅能等比例縮放面積，細部調整請至「形狀」頁籤。</div> : (
                                      <div className="grid grid-cols-2 gap-4">
                                          <div className="space-y-1">
                                              <div className="flex justify-between px-1"><label className="text-xs opacity-70">寬度 (m)</label><LockBtn p="width"/></div>
                                              <EditableInput value={data.realWidth} onChange={handleWidth} className={`w-full p-2 rounded text-center border outline-none bg-transparent ${lockedParam==='width'?'border-indigo-400':'border-stone-200'}`} />
                                          </div>
                                          <div className="space-y-1">
                                              <div className="flex justify-between px-1"><label className="text-xs opacity-70">深度 (m)</label><LockBtn p="depth"/></div>
                                              <EditableInput value={data.realDepth} onChange={handleDepth} className={`w-full p-2 rounded text-center border outline-none bg-transparent ${lockedParam==='depth'?'border-indigo-400':'border-stone-200'}`} />
                                          </div>
                                      </div>
                                  )}
                              </div>
                          )}
                          {activeTab === 'pos' && (
                              <div className="space-y-4">
                                  <div className="space-y-2">
                                      <label className="text-xs font-bold opacity-70">對齊方式</label>
                                      <div className="flex gap-2">
                                          <div className="flex flex-1 bg-stone-100 rounded p-1 justify-between">
                                              <button onClick={()=>handleAlign('x','left')} className="p-2 hover:bg-white rounded transition"><AlignLeft size={16}/></button>
                                              <button onClick={()=>handleAlign('x','center')} className="p-2 hover:bg-white rounded transition"><AlignCenter size={16}/></button>
                                              <button onClick={()=>handleAlign('x','right')} className="p-2 hover:bg-white rounded transition"><AlignRight size={16}/></button>
                                          </div>
                                          <div className="flex flex-1 bg-stone-100 rounded p-1 justify-between">
                                              <button onClick={()=>handleAlign('y','back')} className="p-2 hover:bg-white rounded transition"><ArrowUpToLine size={16}/></button>
                                              <button onClick={()=>handleAlign('y','center')} className="p-2 hover:bg-white rounded transition"><AlignVerticalJustifyCenter size={16}/></button>
                                              <button onClick={()=>handleAlign('y','front')} className="p-2 hover:bg-white rounded transition"><ArrowDownToLine size={16}/></button>
                                          </div>
                                      </div>
                                  </div>
                                  <div className="flex gap-4 pt-2 border-t border-stone-200/20">
                                      <div className="w-1/3">
                                          <label className="text-xs opacity-70 block mb-1">旋轉角度</label>
                                          <div className="relative">
                                              <EditableInput value={data.rotation||0} onChange={handleRotation} className="w-full p-2 pl-8 rounded border border-stone-200 bg-transparent text-center font-mono" />
                                              <RotateCcw size={14} className="absolute left-2 top-3 opacity-40"/>
                                          </div>
                                      </div>
                                      <div className="flex-1">
                                          <label className="text-xs opacity-70 block mb-1">旋轉圓心 (X, Y)</label>
                                          <div className="flex gap-2">
                                              <EditableInput value={data.pivot?.x||0} onChange={(v)=>handlePivot('X',v)} className="w-full p-2 text-center rounded border border-stone-200 bg-transparent font-mono" />
                                              <EditableInput value={data.pivot?.y||0} onChange={(v)=>handlePivot('Y',v)} className="w-full p-2 text-center rounded border border-stone-200 bg-transparent font-mono" />
                                          </div>
                                      </div>
                                  </div>
                              </div>
                          )}
                          {activeTab === 'shape' && (
                              <div className="space-y-4">
                                  {!points ? (
                                      <div className="flex flex-col items-center justify-center py-6 gap-3">
                                          <p className="text-sm opacity-70">目前為標準矩形</p>
                                          <button onClick={handleConvertToPolygon} className="px-4 py-2 bg-indigo-600 text-white rounded-lg text-sm font-bold shadow hover:bg-indigo-700 transition">轉換為多邊形 (開啟編輯)</button>
                                      </div>
                                  ) : (
                                      <div className="space-y-3">
                                          <div className="flex justify-between items-center mb-2">
                                              <span className="text-xs font-bold opacity-70">頂點座標 (m) - 相對於圓心</span>
                                              <button onClick={handleResetShape} className="text-xs text-red-500 hover:text-red-600 flex items-center gap-1"><Trash2 size={12}/> 重置為矩形</button>
                                          </div>
                                          <div className="max-h-[150px] overflow-y-auto space-y-2 pr-1 custom-scrollbar">
                                              {points.map((p, idx) => (
                                                  <div key={idx} className="flex gap-2 items-center bg-stone-50 p-1.5 rounded border border-stone-100">
                                                      <span className="text-xs w-4 text-center font-mono opacity-50">{idx+1}</span>
                                                      <div className="flex gap-1 flex-1">
                                                          <span className="text-[10px] text-stone-400 mt-1">X</span>
                                                          <EditableInput value={p.x} onChange={(v)=>handlePointChange(idx, 'x', v)} className="w-full p-1 text-center text-sm border-b bg-transparent outline-none num-font"/>
                                                      </div>
                                                      <div className="flex gap-1 flex-1">
                                                          <span className="text-[10px] text-stone-400 mt-1">Y</span>
                                                          <EditableInput value={p.y} onChange={(v)=>handlePointChange(idx, 'y', v)} className="w-full p-1 text-center text-sm border-b bg-transparent outline-none num-font"/>
                                                      </div>
                                                  </div>
                                              ))}
                                          </div>
                                          <p className="text-[10px] text-stone-400 text-center">可按住 Shift 鍵多選點位 | 右鍵點擊邊線可鎖定拖曳</p>
                                      </div>
                                  )}
                              </div>
                          )}
                      </div>
                  )}
              </div>
          );
      };

      const SummaryRow = ({ label, value, isAlert, alertText, highlight, subtext, colorClass }) => (
        <div className={`flex justify-between items-center ${highlight ? 'bg-amber-50 p-2 rounded -mx-2' : ''}`}>
          <span className="text-stone-500 text-sm font-medium">{label}</span>
          <div className="text-right">
            <span className={`text-sm font-bold num-font ${colorClass ? colorClass : 'text-stone-800'}`}>
              {typeof value === 'number' ? formatNum(value) : value || '-'}
            </span>
            {subtext && <span className="ml-1 text-xs text-stone-400 font-normal">{subtext}</span>}
            {isAlert && <span className="ml-2 text-[10px] bg-rose-100 text-rose-600 px-1 rounded font-bold">{alertText}</span>}
          </div>
        </div>
      );

      const InfoItem = ({label, value, unit, isDarkMode, action, subLabel}) => (
        <div className="flex flex-col flex-shrink-0 min-w-fit relative group">
          <span className={`${isDarkMode?"text-slate-400":"text-stone-400"} text-[10px]`}>{label}</span>
          <div className="flex items-center gap-1">
              <span className={`font-bold text-sm whitespace-nowrap ${isDarkMode?"text-slate-100":"text-stone-700"}`}>{value} {unit}</span>
              {action}
          </div>
          {subLabel && <span className="text-[9px] text-stone-400">{subLabel}</span>}
        </div>
      );

      const LegendItem = ({color, label, value, type="box", textColor="text-stone-600", valueColor="text-stone-400"}) => (
        <div className="flex items-center gap-2 flex-shrink-0">
          {type==="box"?<div className={`w-3 h-3 rounded-full border ${color}`}></div>:<div className={`w-4 h-[2px] ${color}`}></div>}
          <div className="flex gap-1">
            <span className={`font-bold text-xs ${textColor}`}>{label}</span>
            {value&&<span className={`text-xs ${valueColor}`}>{value}</span>}
          </div>
        </div>
      );

      // BuildingLayer with Polygon & Curve Support (OPTIMIZED for Mobile)
      const BuildingLayer = ({ width, depth, height, x, y, z, rotation, pivot, scale, color, strokeColor, opacity, visible, showFrame, isSlabMode, animate, delay, isDarkMode, onClick, isSelected, isViolation, points, curves, isMobile }) => {
        if (!visible) return null;
        const thickness = isSlabMode ? Math.max(1.5, height * 0.08) : height;
        
        const pivotX = (pivot?.x || 0) * scale;
        const pivotY = (pivot?.y || 0) * scale;
        
        let displayColor = color;
        let displayBorder = strokeColor;
        let displayOpacity = opacity;

        if (isViolation) {
             displayColor = isDarkMode ? "rgba(220, 38, 38, 0.5)" : "rgba(239, 68, 68, 0.5)"; 
             displayBorder = "#ef4444"; 
             displayOpacity = 0.8;
        }

        const highlightColor = isSelected ? (isDarkMode ? "#38bdf8" : "#0ea5e9") : displayBorder;
        const highlightBorder = isViolation ? `2px solid ${displayBorder}` : (isSelected ? `2px solid ${highlightColor}` : (showFrame ? `1px solid ${displayBorder}` : 'none'));
        const highlightBg = isSelected && !isViolation ? (isDarkMode ? "#0c4a6e" : "#bae6fd") : displayColor;
        const finalBorder = isSlabMode ? `1px solid ${isViolation ? '#ef4444' : highlightColor}` : highlightBorder;
        const finalOpacity = isSlabMode ? (isViolation ? 0.8 : 0.95) : opacity;

        const face = (w, h, tx, ty, tz, rx, ry, rz, bg, border, op) => ({
          width: `${w}px`, height: `${h}px`,
          position: 'absolute', left: '50%', top: '50%',
          marginLeft: `-${w / 2}px`, marginTop: `-${h / 2}px`,
          backgroundColor: bg, border: border, boxSizing: 'border-box',
          transform: `translate3d(${tx}px, ${ty}px, ${tz}px) rotateX(${rx}deg) rotateY(${ry}deg) rotateZ(${rz}deg)`,
          opacity: op, 
          pointerEvents: 'auto',
          cursor: 'pointer',
          transition: 'all 0.5s cubic-bezier(0.4, 0, 0.2, 1)',
          backfaceVisibility: 'visible', 
          animation: isViolation ? 'pulse-red 3s infinite' : 'none',
          boxShadow: isDarkMode ? (isSlabMode ? "inset 0 0 15px rgba(255,255,255,0.1)" : "none") : (isSlabMode ? "inset 0 0 5px rgba(0,0,0,0.1)" : "none")
        });

        // --- Polygon/Curve Rendering Logic ---
        if (points && points.length > 0) {
            const ptsPx = points.map(p => ({ x: (p.x || 0) * scale, y: (p.y || 0) * scale }));
            if (ptsPx.some(p => isNaN(p.x) || isNaN(p.y))) return null;

            const minX = Math.min(...ptsPx.map(p=>p.x));
            const maxX = Math.max(...ptsPx.map(p=>p.x));
            const minY = Math.min(...ptsPx.map(p=>p.y));
            const maxY = Math.max(...ptsPx.map(p=>p.y));
            const bW = maxX - minX;
            const bD = maxY - minY;
            const bCx = (maxX + minX) / 2;
            const bCy = (maxY + minY) / 2;

            // Padding for curves control points
            const padding = 50; 
            const contW = bW + padding * 2;
            const contH = bD + padding * 2;
            
            // Construct Path for ClipPath relative to this new container
            let d = `M ${(ptsPx[0].x - minX + padding)} ${(ptsPx[0].y - minY + padding)}`;
            for (let i = 0; i < ptsPx.length; i++) {
                const pNext = ptsPx[(i + 1) % ptsPx.length];
                const curve = curves ? curves[i] : null;

                const nextX = pNext.x - minX + padding;
                const nextY = pNext.y - minY + padding;

                if (curve) {
                    const cpX = curve.x * scale - minX + padding;
                    const cpY = curve.y * scale - minY + padding;
                    d += ` Q ${cpX} ${cpY}, ${nextX} ${nextY}`;
                } else {
                    d += ` L ${nextX} ${nextY}`;
                }
            }
            d += " Z";
            const clipPath = `path('${d}')`;

            // Generate Walls
            const walls = [];
            // OPTIMIZATION: Reduce segments on mobile to prevent lag
            const segmentsForCurve = isMobile ? 3 : 8; 

            for (let i = 0; i < ptsPx.length; i++) {
                const p1 = ptsPx[i];
                const p2 = ptsPx[(i + 1) % ptsPx.length];
                const curve = curves ? curves[i] : null;

                if (curve) {
                    const cp = { x: curve.x * scale, y: curve.y * scale };
                    let prevP = p1;
                    for(let k=1; k<=segmentsForCurve; k++) {
                        const t = k / segmentsForCurve;
                        const tx = (1-t)*(1-t)*p1.x + 2*(1-t)*t*cp.x + t*t*p2.x;
                        const ty = (1-t)*(1-t)*p1.y + 2*(1-t)*t*cp.y + t*t*p2.y;
                        const currP = { x: tx, y: ty };
                        
                        const dx = currP.x - prevP.x;
                        const dy = currP.y - prevP.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
                        const midX = (prevP.x + currP.x) / 2;
                        const midY = (prevP.y + currP.y) / 2;
                        
                        walls.push(
                            <div key={`${i}-${k}`} style={face(dist + 0.5, thickness, midX, midY, thickness/2, 90, 0, angle, highlightBg, finalBorder, finalOpacity)} />
                        );
                        prevP = currP;
                    }
                } else {
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const angle = Math.atan2(dy, dx) * (180 / Math.PI);
                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;
                    walls.push(
                        <div key={i} style={face(dist + 0.5, thickness, midX, midY, thickness/2, 90, 0, angle, highlightBg, finalBorder, finalOpacity)} />
                    );
                }
            }

            const topFaceStyle = {
                 ...face(contW, contH, bCx, bCy, thickness, 0, 0, 0, highlightBg, 'none', finalOpacity + 0.1),
                 clipPath: clipPath,
                 filter: isSelected ? 'brightness(1.1)' : 'none'
            };
            const bottomFaceStyle = {
                 ...face(contW, contH, bCx, bCy, 0, 0, 0, 0, highlightBg, 'none', finalOpacity),
                 clipPath: clipPath
            };

            // FIX: 3D Wireframe Bounding Box for Review Mode
            let reviewBox = null;
            if (isViolation || showFrame) {
                 const boxBorder = `2px dashed ${isViolation ? '#ef4444' : '#f43f5e'}`;
                 const cornerZ = thickness;
                 
                 reviewBox = (
                     <div className="pointer-events-none" style={{
                         position: 'absolute', top:0, left:0, width:0, height:0,
                         transform: `translate3d(${bCx}px, ${bCy}px, ${thickness/2}px)`
                     }}>
                         <div style={{ position: 'absolute', width: `${bW}px`, height: `${bD}px`, border: boxBorder, transform: `translate(-50%, -50%) translateZ(${thickness/2}px)` }}/>
                         <div style={{ position: 'absolute', width: `${bW}px`, height: `${bD}px`, border: boxBorder, transform: `translate(-50%, -50%) translateZ(${-thickness/2}px)` }}/>
                         <div style={{position: 'absolute', width:0, height:`${thickness}px`, borderLeft: boxBorder, transform: `translate3d(-${bW/2}px, -${bD/2}px, -${thickness/2}px) rotateX(0deg)`}}/>
                         <div style={{position: 'absolute', width:0, height:`${thickness}px`, borderLeft: boxBorder, transform: `translate3d(${bW/2}px, -${bD/2}px, -${thickness/2}px) rotateX(0deg)`}}/>
                         <div style={{position: 'absolute', width:0, height:`${thickness}px`, borderLeft: boxBorder, transform: `translate3d(${bW/2}px, ${bD/2}px, -${thickness/2}px) rotateX(0deg)`}}/>
                         <div style={{position: 'absolute', width:0, height:`${thickness}px`, borderLeft: boxBorder, transform: `translate3d(-${bW/2}px, ${bD/2}px, -${thickness/2}px) rotateX(0deg)`}}/>
                     </div>
                 );
            }

            return (
              <div className="absolute" 
                onClick={onClick}
                style={{
                left: '50%', top: '50%', width: 0, height: 0, transformStyle: 'preserve-3d', 
                transform: `translate3d(${x}px, ${y}px, ${z}px) rotateZ(${rotation || 0}deg)`,
                animation: animate ? `riseUp 0.8s ease-out ${delay}ms backwards` : 'none',
                '--tx': `${x}px`, '--ty': `${y}px`, '--tz': `${z}px`
              }}>
                {walls}
                <div style={topFaceStyle} className="hover:brightness-110" />
                <div style={bottomFaceStyle} />
                {reviewBox}
              </div>
            );
        }

        // --- Standard Rectangular Rendering ---
        const topFaceStyle = {
             ...face(width, depth, 0, 0, thickness, 0, 0, 0, highlightBg, finalBorder, finalOpacity + 0.1),
             filter: isSelected ? 'brightness(1.1)' : 'none'
        };

        return (
          <div className="absolute" 
            onClick={onClick}
            style={{
            left: '50%', top: '50%', width: 0, height: 0, transformStyle: 'preserve-3d', 
            transform: `translate3d(${x}px, ${y}px, ${z}px) rotateZ(${rotation || 0}deg)`,
            transformOrigin: `calc(50% + ${pivotX}px) calc(50% - ${pivotY}px)`,
            animation: animate ? `riseUp 0.8s ease-out ${delay}ms backwards` : 'none',
            '--tx': `${x}px`, '--ty': `${y}px`, '--tz': `${z}px`
          }}>
            <div style={face(width, thickness, 0, depth/2, thickness/2, 90, 0, 0, highlightBg, finalBorder, finalOpacity)} />
            <div style={face(width, thickness, 0, -depth/2, thickness/2, -90, 0, 0, highlightBg, finalBorder, finalOpacity)} />
            <div style={face(depth, thickness, width/2, 0, thickness/2, 0, 90, 90, highlightBg, finalBorder, finalOpacity)} />
            <div style={face(depth, thickness, -width/2, 0, thickness/2, 0, 90, -90, highlightBg, finalBorder, finalOpacity)} />
            <div style={topFaceStyle} className="hover:brightness-110" />
            <div style={face(width, depth, 0, 0, 0, 0, 0, 0, highlightBg, finalBorder, finalOpacity)} />
          </div>
        );
      };

      const Visualizer3D = ({ inputs, res, onUpdateBaseDim, onResetAll }) => {
        const [animate, setAnimate] = useState(false);
        const [showCheckLines, setShowCheckLines] = useState(false);
        const [showWeiLao, setShowWeiLao] = useState(false); 
        const [isDarkMode, setIsDarkMode] = useState(false);
        const [isConstraintMode, setIsConstraintMode] = useState(false); 
        const [viewMode, setViewMode] = useState('3d');
        const [selectedFloor, setSelectedFloor] = useState(null);
        const [focusOffset, setFocusOffset] = useState({ x: 0, y: 0, z: 0 });
        const [preSelectZoom, setPreSelectZoom] = useState(1);
        const [floorSettings, setFloorSettings] = useState({});
        const [showAdaptiveMenu, setShowAdaptiveMenu] = useState(false);
        const floorsBelow = Math.max(0, parseInt(inputs.floorsBelow) || 0);
        const [basementState, setBasementState] = useState({}); 
        const [parkingOn1F, setParkingOn1F] = useState(true);
        const volumeLimit = res.totalCFA;
        const carsPerBasement = (res.basementAreaPerFloor || 0) / (inputs.avgCarArea || 35);
        const recommendedBasementCount = carsPerBasement > 0 ? Math.ceil(res.statutoryParking / carsPerBasement) : 0;
        const basements = useMemo(() => Array.from({length: floorsBelow}).map((_, i) => ({ id: `B${i+1}`, area: res.basementAreaPerFloor, active: !!basementState[`B${i+1}`], recommended: (i + 1) <= recommendedBasementCount })), [floorsBelow, basementState, res.basementAreaPerFloor, recommendedBasementCount]);
        const activeBasementArea = basements.filter(b => b.active).reduce((acc, b) => acc + b.area, 0);
        const toggleBasement = (id) => setBasementState(prev => ({...prev, [id]: !prev[id]}));
        const toggleParkingLocation = () => setParkingOn1F(prev => !prev);
        const handleAdaptiveVolume = () => {
            setShowAdaptiveMenu(false);
            const availableForAbove = Math.max(0, (res.totalCFA - res.exemptIndoor) - activeBasementArea);
            const activeFloorCount = massingLayers.totalFloors;
            if (activeFloorCount > 0) {
                const areaPerFloor = availableForAbove / activeFloorCount;
                const newSettings = { ...floorSettings };
                massingLayers.layers.forEach(l => {
                    const current = newSettings[l.id] || {};
                    newSettings[l.id] = { ...current, area: areaPerFloor, manualArea: true };
                    delete newSettings[l.id].width;
                    delete newSettings[l.id].depth;
                    delete newSettings[l.id].manualDim;
                });
                setFloorSettings(newSettings);
            }
        };
        const toggleConstraints = () => { setIsConstraintMode(!isConstraintMode); if (!isConstraintMode) setShowCheckLines(true); };
        
        // --- OPTIMIZATION: USE REFS FOR VISUAL STATE ---
        const [rotationZ, setRotationZ] = useState(-45);
        const [viewAngleX, setViewAngleX] = useState(58);
        const [zoom, setZoom] = useState(1);
        
        // Mutable refs for immediate updates during drag (bypass React render)
        const visualState = useRef({ rotZ: -45, rotX: 58, zoom: 1 });
        const sceneRef = useRef(null);

        const [isDragging, setIsDragging] = useState(false);
        const lastMousePos = useRef({ x: 0, y: 0 });
        const lastPinchDist = useRef(null); 
        const viewportRef = useRef(null);
        const [isMobile, setIsMobile] = useState(false);
        const [isSummaryOpen, setIsSummaryOpen] = useState(true);
        const isLandscapeMode = isMobile && !isSummaryOpen;

        useEffect(() => { const checkMobile = () => setIsMobile(window.innerWidth < 768); checkMobile(); window.addEventListener('resize', checkMobile); return () => window.removeEventListener('resize', checkMobile); }, []);
        useEffect(() => { setAnimate(true); const timer = setTimeout(() => setAnimate(false), 1000); return () => clearTimeout(timer); }, [res.floorsAbove]);
        useEffect(() => {
          const element = viewportRef.current;
          if (!element) return;
          const handleNativeWheel = (e) => { 
              if(e.cancelable) e.preventDefault(); 
              e.stopPropagation(); 
              const sensitivity = 0.002; 
              const delta = -e.deltaY * sensitivity; 
              const newZoom = Math.min(3, Math.max(0.2, zoom + delta));
              setZoom(newZoom);
              visualState.current.zoom = newZoom;
              // Sync for wheel is fine since it's discrete
          };
          element.addEventListener('wheel', handleNativeWheel, { passive: false });
          return () => element.removeEventListener('wheel', handleNativeWheel);
        }, [zoom]); 

        const getTouchDistance = (touches) => Math.hypot(touches[0].pageX - touches[1].pageX, touches[0].pageY - touches[1].pageY);
        const handleMouseDown = (e) => { if (viewMode === '2d') return; setIsDragging(true); lastMousePos.current = { x: e.clientX, y: e.clientY }; };
        const handleTouchStart = (e) => {
          if (viewMode === '2d') return;
          if (e.touches.length === 2) { lastPinchDist.current = getTouchDistance(e.touches); setIsDragging(false); } 
          else if(e.touches.length === 1) { setIsDragging(true); lastMousePos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY }; }
        };
        
        // OPTIMIZED MOVE HANDLER: Direct DOM Manipulation via CSS Variables
        const handleMove = (clientX, clientY, isTouch = false) => {
            if (!isDragging) return;
            const deltaX = clientX - lastMousePos.current.x;
            const deltaY = clientY - lastMousePos.current.y;
            let effectiveDeltaX = isLandscapeMode ? deltaY : deltaX;
            let effectiveDeltaY = isLandscapeMode ? -deltaX : deltaY;
            
            // Update refs
            visualState.current.rotZ += effectiveDeltaX * 0.5;
            visualState.current.rotX = Math.min(85, Math.max(10, visualState.current.rotX - effectiveDeltaY * 0.5));
            
            // Apply to DOM directly (bypass React Render)
            if (sceneRef.current) {
                sceneRef.current.style.setProperty('--rotZ', `${visualState.current.rotZ}deg`);
                sceneRef.current.style.setProperty('--rotX', `${visualState.current.rotX}deg`);
            }
            
            lastMousePos.current = { x: clientX, y: clientY };
        };

        const handleMouseMove = (e) => handleMove(e.clientX, e.clientY);
        
        const handleTouchMove = (e) => {
          // Pinch Zoom
          if (e.touches.length === 2 && lastPinchDist.current !== null) { 
              const currentDist = getTouchDistance(e.touches); 
              const delta = currentDist - lastPinchDist.current; 
              const newZoom = Math.min(3, Math.max(0.2, visualState.current.zoom + delta * 0.005));
              visualState.current.zoom = newZoom;
              if (sceneRef.current) sceneRef.current.style.setProperty('--zoom', newZoom);
              lastPinchDist.current = currentDist; 
              return; 
          }
          if (e.touches.length !== 1) return;
          handleMove(e.touches[0].clientX, e.touches[0].clientY, true);
        };
        
        // Sync back to React state on end
        const handleEnd = () => { 
            setIsDragging(false); 
            lastPinchDist.current = null;
            // Commit values to state
            setRotationZ(visualState.current.rotZ);
            setViewAngleX(visualState.current.rotX);
            setZoom(visualState.current.zoom);
        };

        const handleZoomIn = () => { const nz = Math.min(3, zoom + 0.2); setZoom(nz); visualState.current.zoom = nz; };
        const handleZoomOut = () => { const nz = Math.max(0.2, zoom - 0.2); setZoom(nz); visualState.current.zoom = nz; };

        const handleLayerClick = (e, layer) => {
            e.stopPropagation(); 
            if (selectedFloor && selectedFloor.id === layer.id) return; 
            if (!selectedFloor) setPreSelectZoom(zoom);
            const settings = floorSettings[layer.id] || {};
            setSelectedFloor({ ...layer, rotation: layer.rotation || 0, pivot: settings.pivot || { x: 0, y: 0 }, alignment: settings.alignment || { x: 'left', y: 'back' }, violations: layer.violations || [], points: settings.points || null, curves: settings.curves || null });
            const targetZ = layer.z + layer.height * 0.5;
            setFocusOffset({ x: -layer.shiftX, y: -layer.shiftYPx, z: -targetZ });
            
            // Zoom in logic
            const newZoom = 2.5;
            setZoom(newZoom);
            visualState.current.zoom = newZoom;
        };
        
        const handleBgClick = () => { 
            if (selectedFloor) { 
                setSelectedFloor(null); 
                setFocusOffset({ x: 0, y: 0, z: 0 }); 
                const oldZoom = Math.max(0.5, preSelectZoom);
                setZoom(oldZoom);
                visualState.current.zoom = oldZoom;
            } 
        };

        const updateFloorSetting = (floorId, field, value) => {
           if (isConstraintMode) return; 
           if (field === 'reset') { setFloorSettings(prev => { const copy = {...prev}; delete copy[floorId]; return copy; }); return; }
           setFloorSettings(prev => {
              const current = prev[floorId] || {};
              let newData = { ...current };
              if (field.startsWith('align_')) { const axis = field.split('_')[1]; const alignment = { ...(current.alignment || { x: 'left', y: 'back' }), [axis]: value }; newData.alignment = alignment; } 
              else if (field.startsWith('pivot')) { const axis = field === 'pivotX' ? 'x' : 'y'; const pivot = { ...(current.pivot || { x: 0, y: 0 }), [axis]: value }; newData.pivot = pivot; } 
              else if (field === 'area') { newData.area = value; newData.manualArea = true; } 
              else if (field === 'points') { if (value && value.length >= 3) { let area = 0; for (let i = 0; i < value.length; i++) { const j = (i + 1) % value.length; area += value[i].x * value[j].y; area -= value[j].x * value[i].y; } area = Math.abs(area) / 2; newData.area = area; newData.manualArea = true; } newData.points = value; } 
              else if (field === 'curves') { newData.curves = value; }
              else if (field === 'offset_delta') { const currentOff = current.offset || { x: 0, y: 0 }; newData.offset = { x: currentOff.x + value.x, y: currentOff.y + value.y }; } 
              else { newData[field] = value; if (field === 'width' || field === 'depth') newData.manualDim = true; }
              return { ...prev, [floorId]: newData };
           });
        };
        const resetFloor = (floorId) => { setFloorSettings(prev => { const copy = { ...prev }; delete copy[floorId]; return copy; }); };
        const applyToAll = (sourceFloorId) => { if (isConstraintMode) return; const sourceSettings = floorSettings[sourceFloorId]; setFloorSettings(prev => { const newSettings = { ...prev }; const floors = massingLayers.layers.map(l => l.id); floors.forEach(fid => { if (fid !== sourceFloorId) { if (sourceSettings) newSettings[fid] = JSON.parse(JSON.stringify(sourceSettings)); else delete newSettings[fid]; } }); return newSettings; }); };
        useEffect(() => { if (selectedFloor) { const layer = massingLayers.layers.find(l => l.id === selectedFloor.id); if (layer) { setSelectedFloor({ ...layer, rotation: floorSettings[layer.id]?.rotation || 0, pivot: floorSettings[layer.id]?.pivot || { x: 0, y: 0 }, alignment: floorSettings[layer.id]?.alignment || { x: 'left', y: 'back' }, violations: layer.violations, points: floorSettings[layer.id]?.points || null, curves: floorSettings[layer.id]?.curves || null }); } } }, [floorSettings, isConstraintMode]);

        const canvasSize = isMobile ? (isLandscapeMode ? 320 : 200) : 280; 
        const baseWidthM = parseFloat(inputs.baseWidth) > 0 ? parseFloat(inputs.baseWidth) : Math.sqrt(inputs.baseArea || 100);
        const baseDepthM = (inputs.baseArea || 100) / baseWidthM;
        const scale = canvasSize / Math.max(baseWidthM, baseDepthM);
        const w = baseWidthM * scale;
        const d = baseDepthM * scale;
        const frontM = parseFloat(inputs.frontYardDepth) || 0;
        const backM = parseFloat(inputs.backYardDepth) || 0;
        const sideM = parseFloat(inputs.sideYardDepth) || 0;
        const sideDir = inputs.sideYardDirection || 'right';
        const roadW_M = parseFloat(inputs.roads.find(r => r.type === 'primary')?.width || inputs.roads[0]?.width || 6);
        const byRatio = parseFloat(inputs.minBackyardDepthRatio) || 0;
        const arcadeM = (inputs.frontYardDepth == 0 && inputs.arcadeDepth) ? parseFloat(inputs.arcadeDepth) : 0; 
        const frontPx = frontM * scale;
        const backPx = backM * scale;
        const sidePx = sideM * scale;
        const roadW_Px = roadW_M * scale;
        const shiftX = sideDir === 'left' ? (sidePx / 2) : (-sidePx / 2);

        const massingLayers = useMemo(() => {
            const layers = [];
            let remainingAreaM2 = res.totalCFA; 
            let currentZM = 0;
            let floorCount = 0;
            let currentTotalUsed = activeBasementArea; 
            const maxSimulatedFloors = 100;
            const buildBackM = backM;
            const buildFrontM = baseDepthM - frontM;
            const buildWidthM = Math.max(0, baseWidthM - sideM);
            const originHeightRatioY = baseDepthM + roadW_M; 
            const originWeiLaoY = baseDepthM + roadW_M / 2;

            while ((remainingAreaM2 > 0.1 || floorCount < res.floorsAbove) && floorCount < maxSimulatedFloors) {
                const floorId = `${floorCount + 1}F`;
                const settings = floorSettings[floorId] || {};
                const h = (floorCount === 0) ? (parseFloat(inputs.floorHeight1F) || 4.2) : (parseFloat(inputs.floorHeightOther) || 3.6);
                const checkZ = currentZM + h;
                let limitFront = buildFrontM;
                let limitBack = buildBackM;
                if (floorCount === 0 && arcadeM > 0) limitFront -= arcadeM; 
                const limitFrontHeight = Math.min(limitFront, originHeightRatioY - (checkZ / 3.6));
                const limitFrontWeiLao = showWeiLao ? (originWeiLaoY - (checkZ / 5.0)) : limitFrontHeight;
                const finalLimitFront = Math.min(limitFront, limitFrontHeight, limitFrontWeiLao);
                const limitBackRatio = (byRatio > 0) ? Math.max(limitBack, checkZ / byRatio) : limitBack;
                const finalLimitBack = Math.max(limitBack, limitBackRatio);
                const validDepthM = Math.max(0, finalLimitFront - finalLimitBack);
                const maxFloorAreaM2 = validDepthM * buildWidthM;
                if (maxFloorAreaM2 <= 1.0 && !settings.manualDim && !settings.manualArea && !isConstraintMode) break; 
                let visualWidthM = buildWidthM;
                let visualDepthM = validDepthM;
                let rotation = settings.rotation || 0;
                let usedAreaM2 = 0;
                if (settings.manualDim && settings.width !== undefined && settings.depth !== undefined) { visualWidthM = settings.width; visualDepthM = settings.depth; usedAreaM2 = visualWidthM * visualDepthM; } 
                else if (settings.manualArea && settings.area !== undefined) { usedAreaM2 = settings.area; if (!settings.points) { const ratio = maxFloorAreaM2 > 0 ? Math.sqrt(usedAreaM2 / maxFloorAreaM2) : 1; visualWidthM = buildWidthM * ratio; visualDepthM = validDepthM * ratio; } } 
                else { usedAreaM2 = Math.min(remainingAreaM2, maxFloorAreaM2); const usageRatio = maxFloorAreaM2 > 0 ? usedAreaM2 / maxFloorAreaM2 : 0; const scaleFactor = Math.sqrt(usageRatio); visualWidthM = buildWidthM * scaleFactor; visualDepthM = validDepthM * scaleFactor; }
                if (isConstraintMode) { visualWidthM = Math.min(visualWidthM, buildWidthM); visualDepthM = Math.min(visualDepthM, validDepthM); rotation = 0; usedAreaM2 = visualWidthM * visualDepthM; }
                const envelopeCenterY = (finalLimitBack + validDepthM / 2) - (baseDepthM / 2);
                const alignPref = settings.alignment || { x: 'left', y: 'back' };
                const getOffsets = (wM, dM) => {
                    if (settings.offset) return settings.offset;
                    let offX = 0; const widthDiff = (buildWidthM - wM) * scale;
                    if (alignPref.x === 'left') offX = -widthDiff / 2; else if (alignPref.x === 'right') offX = widthDiff / 2;
                    let offY = 0; const depthDiff = (validDepthM - dM) * scale;
                    if (alignPref.y === 'back') offY = -depthDiff / 2; else if (alignPref.y === 'front') offY = depthDiff / 2;
                    return { x: offX, y: offY };
                }
                const userOff = getOffsets(settings.points ? buildWidthM : visualWidthM, settings.points ? validDepthM : visualDepthM);
                const shiftYPx = (envelopeCenterY * scale) + userOff.y;
                const shiftXVal = shiftX + userOff.x;
                const L_Back_Px = (finalLimitBack - baseDepthM/2) * scale; 
                const L_Front_Px = (finalLimitFront - baseDepthM/2) * scale; 
                const L_Left_Px = (-buildWidthM/2 * scale) + shiftX;
                const L_Right_Px = (buildWidthM/2 * scale) + shiftX;
                const cx = shiftXVal; const cy = shiftYPx;
                let ptsToCheck;
                if (settings.points) { const rot = rotation * (Math.PI / 180); const cos = Math.cos(rot); const sin = Math.sin(rot); ptsToCheck = settings.points.map(p => ({ x: cx + (p.x*scale * cos - p.y*scale * sin), y: cy + (p.x*scale * sin + p.y*scale * cos) })); } 
                else { const rot = rotation * (Math.PI / 180); const cos = Math.cos(rot); const sin = Math.sin(rot); const hw = (visualWidthM * scale) / 2; const hd = (visualDepthM * scale) / 2; const corners = [{x:-hw,y:-hd}, {x:hw,y:-hd}, {x:hw,y:hd}, {x:-hw,y:hd}]; ptsToCheck = corners.map(p => ({ x: cx + (p.x * cos - p.y * sin), y: cy + (p.x * sin + p.y * cos) })); }
                const minX = Math.min(...ptsToCheck.map(p => p.x)); const maxX = Math.max(...ptsToCheck.map(p => p.x)); const minY = Math.min(...ptsToCheck.map(p => p.y)); const maxY = Math.max(...ptsToCheck.map(p => p.y));
                const violations = [];
                if (minY < L_Back_Px - 1) violations.push('back'); if (maxY > L_Front_Px + 1) violations.push('front'); if (minX < L_Left_Px - 1 || maxX > L_Right_Px + 1) violations.push('side');
                const isViolation = violations.length > 0;
                layers.push({
                    id: floorId, z: currentZM * scale, height: Math.max(10, h * scale * 0.9), depthPx: visualDepthM * scale, widthPx: visualWidthM * scale, shiftYPx: shiftYPx, shiftX: shiftXVal, rotation: rotation, pivot: settings.pivot, realArea: usedAreaM2, realWidth: visualWidthM, realDepth: visualDepthM, realHeight: h, maxGeometricArea: maxFloorAreaM2, maxGeometricWidth: buildWidthM, maxGeometricDepth: validDepthM, isViolation: isViolation, violations: violations, points: settings.points || null, curves: settings.curves || null
                });
                remainingAreaM2 -= usedAreaM2; currentTotalUsed += usedAreaM2; currentZM += h; floorCount++;
            }
            return { layers, totalFloors: floorCount, totalHeight: currentZM, currentTotalUsed };
        }, [res.totalCFA, res.totalBasementArea, baseDepthM, baseWidthM, frontM, backM, sideM, roadW_M, inputs.floorHeight1F, inputs.floorHeightOther, showCheckLines, showWeiLao, byRatio, scale, floorSettings, arcadeM, isConstraintMode, activeBasementArea]);

        const floorLayers = massingLayers.layers;
        const colors = { bg: isDarkMode ? "#0f172a" : "#fafaf9", grid: isDarkMode ? "linear-gradient(#1e293b 1px, transparent 1px), linear-gradient(90deg, #1e293b 1px, transparent 1px)" : "linear-gradient(#e5e7eb 1px, transparent 1px), linear-gradient(90deg, #e5e7eb 1px, transparent 1px)", floor: showCheckLines ? (isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(255, 255, 255, 0.3)") : (isDarkMode ? "rgba(255, 255, 255, 0.9)" : "#ffffff"), stroke: showCheckLines ? "#fb923c" : (isDarkMode ? "#94a3b8" : "#a8a29e") };
        const visualTotalH_Px = massingLayers.totalHeight * scale;
        const visualFloorsAbove = massingLayers.totalFloors;
        const totalAreaViolation = massingLayers.currentTotalUsed > volumeLimit; 
        const renderRoads = () => inputs.roads.map((r, idx) => { const rW = parseFloat(r.width) * scale; const orientation = r.orientation; const ext = 50 * scale; let style = {}; if (orientation === 'bottom') { style = { width: `calc(100% + ${ext*2}px)`, height: `${rW}px`, top: '100%', left: `-${ext}px`, transform: `translateY(2px)` }; } else if (orientation === 'top') { style = { width: `calc(100% + ${ext*2}px)`, height: `${rW}px`, bottom: '100%', left: `-${ext}px`, transform: `translateY(-2px)` }; } else if (orientation === 'left') { style = { width: `${rW}px`, height: `calc(100% + ${ext*2}px)`, right: '100%', top: `-${ext}px`, transform: `translateX(-2px)` }; } else { style = { width: `${rW}px`, height: `calc(100% + ${ext*2}px)`, left: '100%', top: `-${ext}px`, transform: `translateX(2px)` }; } return ( <div key={r.id} className={`absolute flex items-center justify-center text-sm font-bold border-dashed border-stone-300 z-10 ${isDarkMode ? 'bg-slate-800 border-slate-600 text-slate-400' : 'bg-stone-200/50 text-stone-600'}`} style={{ ...style, position: 'absolute' }}>{r.name} ({r.width}m)</div> ); });
        const landscapeStyle = isLandscapeMode ? { position: 'fixed', top: 0, left: '100vw', width: '100dvh', height: '100vw', transform: 'rotate(90deg)', transformOrigin: 'top left', zIndex: 9999, margin: 0, borderRadius: 0, touchAction: 'none', backgroundColor: isDarkMode ? '#0f172a' : '#fafaf9' } : { backgroundImage: colors.grid, backgroundSize: '40px 40px', touchAction: 'none' };
        const controlBarClass = isLandscapeMode ? "absolute top-6 right-6 z-30 flex gap-2" : "absolute top-4 right-4 z-30 flex gap-2";
        const viewTransition = isDragging ? 'none' : 'transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1)';
        const limitH_HeightRatio_M = 3.6 * (roadW_M + frontM); const limitH_HeightRatio_Px = limitH_HeightRatio_M * scale; const limitH_WeiLao_M = 5 * (0.5 * roadW_M + frontM); const limitH_WeiLao_Px = limitH_WeiLao_M * scale; const limitH_Backyard_M = byRatio * backM; const limitH_Backyard_Px = limitH_Backyard_M * scale;

        return (
          <div className="bg-[#fdfbf7] rounded-xl p-0 mb-6 shadow-md overflow-hidden relative min-h-[350px] md:min-h-[600px] flex flex-col md:flex-row border border-stone-300 font-['GenYoGothic',_sans-serif] md:sticky md:top-0 md:z-40">
             <div className="flex flex-col md:flex-row w-full h-full relative">
                <div ref={viewportRef} className={`flex-1 relative flex flex-col items-center justify-center perspective-1000 min-h-[350px] md:min-h-[600px] overflow-hidden transition-colors duration-500 ${isDragging ? 'cursor-grabbing' : 'cursor-grab'} ${isDarkMode ? 'bg-slate-900' : 'bg-[#fafaf9]'}`} style={{ ...landscapeStyle, ...(isLandscapeMode ? {} : { backgroundImage: colors.grid, backgroundSize: '40px 40px' }) }} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleEnd} onMouseLeave={handleEnd} onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleEnd} onClick={handleBgClick}>
                  <div className="absolute top-4 left-4 z-40 flex bg-white/90 backdrop-blur rounded-lg border border-stone-200 shadow-sm p-1 gap-1">
                      <button onClick={() => { setViewMode('3d'); setSelectedFloor(null); }} className={`flex items-center gap-1 px-3 py-1.5 rounded text-xs font-bold transition-colors ${viewMode === '3d' ? 'bg-stone-800 text-white' : 'text-stone-500 hover:bg-stone-100'}`}><Box size={14} /> 3D 模擬</button>
                      <button onClick={() => setViewMode('2d')} className={`flex items-center gap-1 px-3 py-1.5 rounded text-xs font-bold transition-colors ${viewMode === '2d' ? 'bg-stone-800 text-white' : 'text-stone-500 hover:bg-stone-100'}`}><LayoutTemplate size={14} /> 平面分析</button>
                  </div>
                  <div className={controlBarClass}>
                     <div className={`${isDarkMode ? 'bg-slate-800/80 border-slate-700' : 'bg-white/90 border-stone-200'} p-1 rounded-full border shadow-lg flex items-center gap-1 backdrop-blur-md transition-colors duration-300`}>
                        <button onClick={handleZoomOut} className={`p-2 rounded-full transition-all ${isDarkMode ? 'text-slate-300 hover:bg-slate-600' : 'text-slate-600 hover:bg-stone-100'}`} title="縮小"><ZoomOut size={18} /></button><div className={`w-[1px] h-4 ${isDarkMode ? 'bg-slate-600' : 'bg-stone-200'}`}></div><button onClick={handleZoomIn} className={`p-2 rounded-full transition-all ${isDarkMode ? 'text-slate-300 hover:bg-slate-600' : 'text-slate-600 hover:bg-stone-100'}`} title="放大"><ZoomIn size={18} /></button><div className={`w-[1px] h-4 ${isDarkMode ? 'bg-slate-600' : 'bg-stone-200'}`}></div><button onClick={() => setIsDarkMode(!isDarkMode)} className={`p-2 rounded-full transition-all ${isDarkMode ? 'text-yellow-400 hover:bg-slate-600' : 'text-slate-600 hover:bg-stone-100'}`} title={isDarkMode ? "切換至淺色模式" : "切換至深色模式"}>{isDarkMode ? <Sun size={18} /> : <Moon size={18} />}</button><div className={`w-[1px] h-4 ${isDarkMode ? 'bg-slate-600' : 'bg-stone-200'}`}></div><button onClick={() => setIsSummaryOpen(!isSummaryOpen)} className={`p-2 rounded-full transition-all ${isDarkMode ? 'text-indigo-400 hover:bg-slate-600' : 'text-indigo-600 hover:bg-stone-100'}`} title={isSummaryOpen ? "全螢幕模式 (隱藏面板)" : "顯示詳細面板"}>{isSummaryOpen ? <Maximize2 size={18} /> : <PanelRightOpen size={18} />}</button>
                     </div>
                  </div>
                  {isConstraintMode && viewMode === '3d' && (<div className="absolute bottom-24 right-6 z-20 pointer-events-none"><div className="bg-emerald-600/90 text-white px-3 py-1.5 rounded-full shadow-lg text-sm font-bold flex items-center gap-2 backdrop-blur border border-emerald-400 animate-pulse"><CheckCircle2 size={16} fill="white" className="text-emerald-700" />鎖定編輯</div></div>)}
                  {viewMode === '2d' ? (
                      <PlanAnalysis2D layers={floorLayers} baseWidthM={baseWidthM} baseDepthM={baseDepthM} onSelectFloor={(id) => { if (id && id !== 'base') { const l = floorLayers.find(f => f.id === id); if (l) handleLayerClick({ stopPropagation: () => {} }, l); } else { setSelectedFloor(null); } }} selectedFloorId={selectedFloor?.id} isDarkMode={isDarkMode} onUpdateSetting={updateFloorSetting} floorSettings={floorSettings} inputs={inputs} scale3d={scale} basements={basements} onToggleBasement={toggleBasement} activeBasementArea={activeBasementArea} totalAllowedArea={res.totalCFA} showCheckLines={showCheckLines} volumeLimit={volumeLimit} parkingOn1F={parkingOn1F} onToggleParkingLocation={toggleParkingLocation} />
                  ) : (
                      <>
                          {!isConstraintMode && <FloorInfoCard data={selectedFloor} isDarkMode={isDarkMode} onReset={resetFloor} isConstraintMode={isConstraintMode}/>}
                          <div className="absolute top-16 left-6 z-20 pointer-events-none"><ArtisticCompass className="w-16 h-16" rotation={-rotationZ} isDarkMode={isDarkMode} /></div>
                          {totalAreaViolation && <div className="absolute top-8 left-1/2 transform -translate-x-1/2 z-20 pointer-events-none animate-pulse"><div className="bg-red-500/90 text-white px-3 py-1.5 rounded-full shadow-lg text-sm font-bold flex items-center gap-2 backdrop-blur"><AlertTriangle size={16} fill="white" className="text-red-500" />總容積超限! ({formatNum(toPing(massingLayers.currentTotalUsed))} > {formatNum(toPing(volumeLimit))}坪)</div></div>}
                          <div className="relative w-full h-full flex items-center justify-center pointer-events-none" style={{ perspective: '2500px', transformStyle: 'preserve-3d' }}>
                            <div 
                                ref={sceneRef}
                                style={{ 
                                    // Use CSS Variables controlled by JS during drag for performance
                                    '--rotX': `${viewAngleX}deg`,
                                    '--rotZ': `${rotationZ}deg`,
                                    '--zoom': zoom,
                                    transform: `rotateX(var(--rotX)) rotateZ(var(--rotZ)) scale3d(var(--zoom), var(--zoom), var(--zoom)) translate3d(${focusOffset.x}px, ${focusOffset.y}px, ${focusOffset.z}px)`, 
                                    transformStyle: 'preserve-3d', 
                                    transition: isDragging ? 'none' : 'transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1)' 
                                }}
                            >
                               <div style={{ position: 'relative', width: `${w}px`, height: `${d}px`, backgroundColor: isDarkMode ? 'rgba(30, 41, 59, 0.6)' : 'rgba(168, 162, 158, 0.4)', transformStyle: 'preserve-3d', transition: 'background-color 0.5s'}}>
                                  <div className={`absolute border shadow-2xl transition-colors duration-500 ${isDarkMode ? 'bg-slate-800/80 border-slate-600' : 'bg-transparent border-stone-300'}`} style={{ width: '100%', height: '100%', boxShadow: isDarkMode ? '0 0 20px rgba(0,0,0,0.5)' : 'none' }}>
                                     {renderRoads()}
                                     {(showCheckLines || Object.keys(floorSettings).length > 0 || isConstraintMode) && (
                                       <>
                                         {frontPx > 0 && <div className="absolute bottom-0 left-0 right-0 border-t border-dashed flex items-end justify-center bg-rose-50/40 border-rose-200" style={{ height: `${frontPx}px` }}><span className="text-sm font-bold text-rose-500 bg-white/80 px-1 rounded mb-1">前院 {inputs.frontYardDepth}m</span></div>}
                                         {backPx > 0 && <div className="absolute top-0 left-0 right-0 border-b border-dashed flex items-start justify-center bg-emerald-50/40 border-emerald-200" style={{ height: `${backPx}px` }}><span className="text-sm font-bold text-emerald-600 bg-white/80 px-1 rounded mt-1">後院 {inputs.backYardDepth}m</span></div>}
                                         {sidePx > 0 && <div className={`absolute top-0 bottom-0 border-dashed flex items-center justify-center bg-slate-50/40 border-slate-200 ${sideDir === 'left' ? 'left-0 border-r' : 'right-0 border-l'}`} style={{ width: `${sidePx}px` }}><span className="text-sm font-bold text-slate-600 bg-white/80 px-1 rounded transform rotate-90">側院 {inputs.sideYardDepth}m</span></div>}
                                         {arcadeM > 0 && <div className="absolute bottom-0 left-0 right-0 border-t border-dashed border-indigo-300 flex items-end justify-center bg-indigo-50/30" style={{ height: `${arcadeM*scale}px` }}><span className="text-xs font-bold text-indigo-500 bg-white/80 px-1 rounded mb-1">騎樓 {arcadeM}m</span></div>}
                                       </>
                                     )}
                                  </div>
                                  {Array.from({length: floorsBelow}).map((_, i) => (<div key={`bm-${i}`} className={`absolute border border-dashed ${isDarkMode ? 'border-slate-600 bg-slate-800/50' : 'border-stone-400 bg-stone-200/50'}`} style={{ width: `${w*0.8}px`, height: `${d*0.8}px`, left: '50%', top: '50%', transform: `translate(-50%, -50%) translateZ(${-(i+1)*Math.max(20, 3.6*scale*0.8)}px)` }}></div>))}
                                  {floorLayers.map((layer, i) => (<BuildingLayer key={`fl-${i}`} width={layer.widthPx} depth={layer.depthPx} height={layer.height} x={layer.shiftX} y={layer.shiftYPx} z={layer.z} rotation={layer.rotation} pivot={selectedFloor?.id === layer.id ? selectedFloor.pivot : floorSettings[layer.id]?.pivot} scale={scale} points={layer.points} curves={layer.curves} color={colors.floor} strokeColor={colors.stroke} showFrame={true} opacity={1} visible={true} isSlabMode={!showCheckLines} animate={animate} delay={i * 50} isDarkMode={isDarkMode} isSelected={selectedFloor && selectedFloor.id === layer.id} isViolation={layer.isViolation} onClick={(e) => handleLayerClick(e, layer)} isMobile={isMobile}/>))}
                                  {(showCheckLines || Object.keys(floorSettings).length > 0 || isConstraintMode) && (
                                     <>
                                        <CheckLine start={{ x: w/2, y: d + roadW_Px, z: 0 }} end={{ x: w/2, y: d - frontPx, z: limitH_HeightRatio_Px }} color="#f43f5e" label="高度比" baseRotation={0} viewAngleX={viewAngleX} rotationZ={rotationZ} visible={true} dashed={true} thick={true} isDarkMode={isDarkMode} labelPosRatio={0.2} />
                                        {showWeiLao && <CheckLine start={{ x: w/2, y: d + roadW_Px/2, z: 0 }} end={{ x: w/2, y: d - frontPx, z: limitH_WeiLao_Px }} color={isDarkMode ? "#a855f7" : "#8b5cf6"} label="危老檢討" baseRotation={0} viewAngleX={viewAngleX} rotationZ={rotationZ} visible={true} dashed={true} thick={true} isDarkMode={isDarkMode} labelPosRatio={0.2} />}
                                        {byRatio > 0 && <CheckLine start={{ x: w/2, y: 0, z: 0 }} end={{ x: w/2, y: backPx, z: limitH_Backyard_Px }} color={isDarkMode ? "#38bdf8" : "#0ea5e9"} label="後院比" baseRotation={0} viewAngleX={viewAngleX} rotationZ={rotationZ} visible={true} dashed={true} thick={true} isDarkMode={isDarkMode} labelPosRatio={0.2} />}
                                     </>
                                  )}
                               </div>
                            </div>
                          </div>
                      </>
                  )}
                  <div className="absolute bottom-4 left-0 w-full z-40 px-4 flex justify-center pointer-events-none">
                     <div className={`pointer-events-auto rounded-2xl border shadow-lg flex items-center justify-center p-2 backdrop-blur-md transition-colors max-w-full overflow-x-auto no-scrollbar ${isDarkMode ? 'bg-slate-900/90 border-slate-700' : 'bg-white/80 border-white/50'}`}>
                         <div className="flex items-center gap-4 px-2 whitespace-nowrap">
                             {viewMode === '2d' && !selectedFloor ? (
                                <>
                                    <InfoItem label="樓層總數" value={`${massingLayers.totalFloors}F / B${basements.filter(b=>b.active).length}`} isDarkMode={isDarkMode} />
                                    <div className="relative pointer-events-auto">
                                        <button onClick={() => { if (totalAreaViolation) handleAdaptiveVolume(); else setShowAdaptiveMenu(!showAdaptiveMenu); }} className={`text-left flex flex-col rounded px-1 transition-colors ${totalAreaViolation ? 'bg-red-50 hover:bg-red-100' : 'hover:bg-black/5'}`}>
                                            <span className={`${isDarkMode?"text-slate-400":"text-stone-400"} text-[10px]`}>總樓地板面積</span>
                                            <div className="flex items-center gap-1"><span className={`font-bold text-sm whitespace-nowrap ${totalAreaViolation ? 'text-red-500' : (isDarkMode?"text-slate-100":"text-stone-700")}`}>{formatNum(toPing(massingLayers.currentTotalUsed))} 坪</span><MoreVertical size={12} className="opacity-50"/></div>
                                        </button>
                                        {showAdaptiveMenu && (<div className={`absolute bottom-full left-0 mb-2 w-32 rounded shadow-lg overflow-hidden border animate-slide-up ${isDarkMode?'bg-slate-800 border-slate-600 text-white':'bg-white border-stone-200'}`} style={{zIndex: 100}}><button onClick={handleAdaptiveVolume} className="w-full text-left px-3 py-2 text-xs hover:bg-indigo-50 hover:text-indigo-600 transition-colors">自適應容積</button></div>)}
                                    </div>
                                </>
                             ) : (
                                showCheckLines ? ( <><LegendItem color={isDarkMode?"bg-rose-500/20 border-rose-500":"bg-rose-200 border-rose-300"} label={arcadeM > 0 ? "騎樓" : "前院"} value={arcadeM > 0 ? `${arcadeM}m` : `${inputs.frontYardDepth||0}m`} textColor={isDarkMode?"text-slate-200":"text-stone-600"} valueColor={isDarkMode?"text-slate-400":"text-stone-400"} /><LegendItem color={isDarkMode?"bg-emerald-500/20 border-emerald-500":"bg-emerald-200 border-emerald-300"} label="後院" value={`${inputs.backYardDepth||0}m`} textColor={isDarkMode?"text-slate-200":"text-stone-600"} valueColor={isDarkMode?"text-slate-400":"text-stone-400"} /><div className={`w-[1px] h-4 flex-shrink-0 ${isDarkMode ? 'bg-slate-700' : 'bg-stone-300'}`}></div><LegendItem type="line" color="bg-rose-500" label="高度比檢討線" textColor={isDarkMode?"text-slate-200":"text-stone-600"} /></> ) : ( <><InfoItem label="基地面積" value={formatNum(res.base)} unit="m²" isDarkMode={isDarkMode} /><div className={`w-[1px] h-4 flex-shrink-0 ${isDarkMode ? 'bg-slate-700' : 'bg-stone-300'}`}></div><InfoItem label="建蔽率" value={formatNum(inputs.coverageRatio)} unit="%" isDarkMode={isDarkMode} /><div className={`w-[1px] h-4 flex-shrink-0 ${isDarkMode ? 'bg-slate-700' : 'bg-stone-300'}`}></div><InfoItem label="容積率" value={formatNum(inputs.floorRatio)} unit="%" isDarkMode={isDarkMode} /></> )
                             )}
                         </div>
                     </div>
                  </div>
                </div>
                <div className={`transition-all duration-500 ease-in-out border-l border-stone-200 bg-[#f8fafc] flex flex-col num-font z-10 relative overflow-hidden ${isSummaryOpen ? 'w-full md:w-96 opacity-100' : 'w-0 opacity-0 border-none'}`}>
                   <div className="flex-1 overflow-y-auto p-6">
                      <div className="mb-6 border-b border-stone-200 pb-4 sticky top-0 bg-white/95 backdrop-blur z-40 -mt-6 -mx-6 px-6 pt-6 shadow-sm">
                         <div className="flex items-center justify-between"><h3 className="text-stone-400 text-sm font-bold uppercase tracking-widest flex items-center gap-2"><Building2 size={16} /> Project Summary</h3><div className="w-6"></div> </div>
                         <div className="space-y-3 mt-4">
                            <SummaryRow label="專案名稱" value={inputs.projectName} />
                            <SummaryRow label="工程預算" value={`${formatNum(res.estimatedBudget)} 萬`} highlight />
                            <SummaryRow label="建築物高度" value={`${formatNum(massingLayers.totalHeight)} m`} />
                            <SummaryRow label="模擬樓層" value={`${visualFloorsAbove} 層`} subtext="(含退縮)" />
                            {showCheckLines && <SummaryRow label="高度比" value={res.heightRatio} isAlert={res.isHighRise} alertText={res.isSuperHighRise ? "超高" : "高層"} />}
                            <div className="pt-2 border-t border-stone-200 mt-2">
                               <div className="flex justify-between items-center mb-2">
                                   <span className="text-stone-500 text-sm font-medium">檢討線顯示</span>
                                   <div className="flex items-center gap-1">
                                       <button onClick={() => setShowCheckLines(!showCheckLines)} className={`px-3 py-1 rounded-full border shadow-sm flex items-center gap-2 text-xs font-bold transition-colors ${showCheckLines ? 'bg-indigo-50 border-indigo-200 text-indigo-600' : 'bg-white border-stone-200 text-stone-500'}`}>{showCheckLines ? <ToggleRight size={16} /> : <ToggleLeft size={16} />}{showCheckLines ? "開啟" : "關閉"}</button>
                                       <button onClick={toggleConstraints} className={`px-3 py-1 rounded-full border shadow-sm flex items-center gap-2 text-xs font-bold transition-colors ${isConstraintMode ? 'bg-emerald-600 text-white border-emerald-700' : 'bg-white hover:bg-emerald-50 text-emerald-600 border-emerald-200'}`} title={isConstraintMode ? "關閉檢討模式 (允許編輯)" : "開啟檢討模式 (強制符合法規)"}><CheckCircle2 size={16}/> {isConstraintMode ? "檢討開啟" : "檢討關閉"}</button>
                                   </div>
                               </div>
                            </div>
                         </div>
                      </div>
                      <div className="grid grid-cols-2 gap-3">
                         <div className="bg-white p-3 rounded-lg border border-stone-200"><div className="text-stone-400 text-[10px] uppercase mb-1">總樓地板 (坪)</div><div className={`font-bold text-lg num-font ${totalAreaViolation ? 'text-red-500' : 'text-stone-700'}`}>{formatNum(toPing(massingLayers.currentTotalUsed))} <span className="text-xs font-sans font-normal text-stone-400">/ {formatNum(toPing(res.totalCFA))} Max</span></div></div>
                         <div className="bg-white p-3 rounded-lg border border-stone-200"><div className="text-stone-400 text-[10px] uppercase mb-1">預估坪效</div><div className="font-bold text-lg num-font text-emerald-600">{formatNum(res.efficiency)} <span className="text-xs font-sans font-normal text-stone-400">倍</span></div></div>
                         <div className="bg-white p-3 rounded-lg border border-stone-200"><div className="text-stone-400 text-[10px] uppercase mb-1">樓層</div><div className="font-bold text-lg num-font text-indigo-600">{visualFloorsAbove}F <span className="text-xs font-sans font-normal text-stone-400">/ B{inputs.floorsBelow}</span></div></div>
                         <div className="bg-white p-3 rounded-lg border border-stone-200"><div className="text-stone-400 text-[10px] uppercase mb-1">停車</div><div className="font-bold text-lg num-font text-stone-700">{res.possibleParking} <span className="text-xs font-sans font-normal text-stone-400">部</span></div></div>
                      </div>
                   </div>
                   <div className="p-6 bg-white border-t border-stone-200 mt-auto">
                      <div className="text-stone-400 text-sm font-bold uppercase mb-4 flex items-center gap-2"><Car size={14} /> 停車空間預估</div>
                      <div className="flex justify-between items-center">
                         <div className="flex items-center gap-3"><div className="p-2 bg-stone-100 rounded text-stone-600"><Car size={18} /></div><div><div className="text-xs text-stone-400">汽車位</div><div className="font-bold text-stone-800 text-lg num-font">{res.possibleParking}</div></div></div>
                         <div className="h-8 w-[1px] bg-stone-200"></div>
                         <div className="flex items-center gap-3"><div className="p-2 bg-stone-100 rounded text-stone-600"><Bike size={18} /></div><div><div className="text-xs text-stone-400">機車位</div><div className="font-bold text-stone-800 text-lg num-font">{Math.floor(res.possibleParking * 1.2)}</div></div></div>
                      </div>
                   </div>
                </div>
             </div>
          </div>
        );
      };

      const CheckLine = ({ start, end, color, label, rotationZ, baseRotation, viewAngleX, visible, dashed, thick, labelPosRatio = 0.5, isDarkMode }) => {
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const dz = end.z - start.z;
        const length = Math.sqrt(dx * dx + dy * dy + dz * dz);
        const lx = start.x + dx * labelPosRatio;
        const ly = start.y + dy * labelPosRatio;
        const lz = start.z + dz * labelPosRatio;
        const angleZ = Math.atan2(dy, dx) * (180 / Math.PI);
        const angleY = -Math.atan2(dz, Math.sqrt(dx * dx + dy * dy)) * (180 / Math.PI);
        const isSteep = viewAngleX > 75;
        const thickness = thick ? (isSteep ? "6px" : "3px") : (isSteep ? "4px" : "2px");

        return (
          <>
            <div className="absolute origin-left" style={{ left: 0, top: 0, width: `${length}px`, height: thickness, backgroundColor: dashed ? 'transparent' : color, borderTop: dashed ? `2px dashed ${color}` : 'none', transform: `translate3d(${start.x}px, ${start.y}px, ${start.z}px) rotateZ(${angleZ}deg) rotateY(${angleY}deg)`, opacity: visible ? (isSteep ? 1 : 0.9) : 0, pointerEvents: 'none', boxShadow: isSteep ? `0 0 4px ${color}` : 'none' }}></div>
            {isSteep && (<div className="absolute origin-left" style={{ left: 0, top: 0, width: `${length}px`, height: thickness, backgroundColor: color, transform: `translate3d(${start.x}px, ${start.y}px, ${start.z}px) rotateZ(${angleZ}deg) rotateY(${angleY}deg) rotateX(90deg)`, opacity: visible ? 1 : 0, pointerEvents: 'none' }}></div>)}
            {visible && label && (<Si text={label} x={lx} y={ly} z={lz + 10} rotationZ={rotationZ} baseRotation={baseRotation} viewAngleX={viewAngleX} visible={visible} className={`text-[10px] px-2 py-0.5 rounded-full shadow-lg font-bold border ${isDarkMode ? 'bg-slate-900 border-slate-600 text-white' : 'bg-white/90 border-slate-200 text-slate-600'}`} />)}
          </>
        );
      };

      const Si = ({ text, x, y, z, rotationZ, baseRotation, viewAngleX, visible, className, lineConnector }) => (
        visible ? (
            <div className="absolute pointer-events-none" style={{ left: 0, top: 0, transform: `translate3d(${x}px, ${y}px, ${z}px) rotateZ(calc(-1 * (var(--rotZ, ${rotationZ}deg) + ${baseRotation}deg))) rotateX(calc(-1 * var(--rotX, ${viewAngleX}deg)))`, zIndex: 5000 }}>
                <div className="flex items-center" style={{ transform: 'translate(-50%, -50%)' }}>
                    {lineConnector && <div className="w-4 h-[1px] bg-stone-400"></div>}
                    <div className={`whitespace-nowrap px-2 py-0.5 rounded shadow-sm text-sm backdrop-blur-sm num-font ${className}`}>{text}</div>
                </div>
            </div>
        ) : null
      );

      const CollapsibleSection = ({ title, icon, children, defaultOpen = true, className = "" }) => {
        const [isOpen, setIsOpen] = useState(defaultOpen);
        return ( <div className={`bg-white rounded-xl shadow-sm border border-stone-100 overflow-hidden ${className}`}><div className="flex items-center justify-between p-5 cursor-pointer hover:bg-stone-50 transition-colors border-b border-stone-100" onClick={() => setIsOpen(!isOpen)}><h3 className="font-bold text-stone-700 flex items-center gap-2">{icon} {title}</h3><div className="text-stone-400">{isOpen ? <ChevronUp size={20} /> : <ChevronDown size={20} />}</div></div><div className={`transition-all duration-300 ease-in-out overflow-hidden ${isOpen ? 'max-h-[1200px] opacity-100' : 'max-h-0 opacity-0'}`}><div className="p-5">{children}</div></div></div> );
      };

      const InputRow = ({ id, label, value, calculatedValue, formula, note, isEditMode, onOverride, highlight = false, subTotal = false, bold = false, paramKey, paramValue, onParamChange }) => {
        const isConflict = isEditMode && calculatedValue !== undefined && Math.abs(value - calculatedValue) > 0.01;
        const displayValue = formatNum(value);
        const displayPing = formatNum(toPing(value));
        return ( <tr className={`hover:bg-stone-50 ${subTotal ? 'bg-stone-50/80 italic text-stone-600' : ''}`}><td className={`p-4 pl-8 border-l-4 ${highlight ? 'border-emerald-400 font-bold text-emerald-700' : 'border-stone-300'} ${bold ? 'font-bold' : 'font-medium'}`}>{label}</td><td className={`p-4 text-right ${highlight ? 'font-bold text-emerald-700' : ''} ${bold ? 'font-bold' : ''}`}>{isEditMode ? (<div className="flex items-center justify-end gap-2 relative">{isConflict && <div className="absolute right-full mr-2 text-rose-500 animate-pulse" title="警告：數值與公式計算結果衝突"><AlertTriangle size={16} /></div>}<input type="number" value={value} onChange={(e) => onOverride(id, e.target.value)} className={`w-24 p-1 text-right border rounded outline-none focus:ring-2 ${isConflict ? 'border-rose-300 focus:ring-rose-200 bg-rose-50' : 'border-stone-300 focus:ring-indigo-200'} num-font`} /></div>) : (<span className="num-font">{displayValue}</span>)}</td><td className={`p-4 text-right text-stone-500 ${highlight ? 'font-bold text-emerald-700' : ''} ${bold ? 'font-bold' : ''} num-font`}>{displayPing}</td>{isEditMode && (<><td className="p-4 font-mono text-xs text-indigo-600/80 bg-indigo-50/10 border-l border-stone-100">{paramKey ? (<div className="flex items-center gap-2"><span className="text-stone-500">{paramKey === 'exemptRate' ? '免計率' : paramKey === 'stairRate' ? '梯廳率' : '陽台率'}:</span><input type="number" value={paramValue} onChange={(e) => onParamChange(paramKey, e.target.value)} className="w-16 p-1 border rounded text-center font-bold text-indigo-700 num-font" style={{ fontSize: '12px' }}/><span>%</span></div>) : formula}</td><td className="p-4 text-sm text-stone-500 bg-indigo-50/10">{note}</td></>)}</tr> );
      };

      const SectionHeader = ({ title }) => ( <tr className="bg-stone-200 text-stone-800"><td colSpan={10} className="p-2 pl-4 font-bold text-xs uppercase tracking-wider">{title}</td></tr> );

      const Cal = () => {
        const [lots, setLots] = useState([{ id: 1, lot: '___段___地號', area: 239.12 }]);
        const [inputs, setInputs] = useState({ projectName: '', district: '南投縣中興新村', roads: [{ id: 1, name: '向陽路', width: 10, orientation: 'bottom', type: 'primary' }], zoneType: '住宅區', urbanPlanName: '中興新村都市計畫區', coverageRatio: 50, floorRatio: 150, excavationRatio: 60, floorsBelow: 1, avgCarArea: 35, frontYardDepth: 4, sideYardDepth: 1.5, sideYardDirection: 'right', backYardDepth: 3, floorHeight1F: 4.2, floorHeightOther: 3.6, baseWidth: '', incentiveArea: 0, transferArea: 0, minBackyardDepthRatio: 0, arcadeDepth: 0 });
        const [params, setParams] = useState({ exemptRate: 15, stairRate: 5, balconyRate: 10, pricePerPing: 25 });
        const [isEditMode, setIsEditMode] = useState(false);
        const [overrides, setOverrides] = useState({});
        const [showDetail, setShowDetail] = useState(true);

        const updateLot = (id, field, value) => { setLots(prev => prev.map(l => l.id === id ? { ...l, [field]: field === 'area' ? (parseFloat(value) || 0) : value } : l)); };
        const addLot = () => { const newId = Math.max(...lots.map(l => l.id), 0) + 1; setLots([...lots, { id: newId, lot: '', area: 0 }]); };
        const removeLot = (id) => { if (lots.length > 1) setLots(lots.filter(l => l.id !== id)); };
        const updateRoad = (id, field, value) => { setInputs(prev => ({ ...prev, roads: prev.roads.map(r => r.id === id ? { ...r, [field]: value } : r) })); };
        const addRoad = () => { const newId = Math.max(...inputs.roads.map(r => r.id), 0) + 1; setInputs(prev => ({ ...prev, roads: [...prev.roads, { id: newId, name: '新道路', width: 6, orientation: 'left', type: 'secondary' }] })); };
        const removeRoad = (id) => { if (inputs.roads.length > 1) setInputs(prev => ({ ...prev, roads: prev.roads.filter(r => r.id !== id) })); };

        const totalBaseArea = useMemo(() => lots.reduce((acc, curr) => acc + curr.area, 0), [lots]);
        const results = useMemo(() => {
          const base = totalBaseArea;
          const maxBuildingArea = base * (inputs.coverageRatio / 100);
          const statutoryFA = base * (inputs.floorRatio / 100); 
          const exempt15 = statutoryFA * (params.exemptRate / 100);
          const exemptStair = statutoryFA * (params.stairRate / 100);
          const exemptIndoor = exempt15 + exemptStair;
          const balcony = statutoryFA * (params.balconyRate / 100);
          const incentive = parseFloat(inputs.incentiveArea) || 0;
          const transfer = parseFloat(inputs.transferArea) || 0;
          const permittedIndoor = statutoryFA + exemptIndoor + incentive + transfer;
          const roofProtrusion = maxBuildingArea * 0.125 * 2;
          const basementAreaPerFloor = base * (inputs.excavationRatio / 100);
          const totalBasementArea = basementAreaPerFloor * inputs.floorsBelow;
          const totalCFA = permittedIndoor + balcony + roofProtrusion + totalBasementArea;
          const efficiency = toPing(base) > 0 ? toPing(totalCFA) / toPing(base) : 0;
          const statutoryParking = Math.floor(totalCFA / 150);
          const possibleParking = Math.floor(totalBasementArea / inputs.avgCarArea);
          const calculatedFloors = maxBuildingArea > 0 ? permittedIndoor / maxBuildingArea : 0;
          const floorsAbove = Math.ceil(calculatedFloors);
          const estimatedBudget = toPing(totalCFA) * params.pricePerPing;
          const fh1 = parseFloat(inputs.floorHeight1F) || 0;
          const fhO = parseFloat(inputs.floorHeightOther) || 0;
          const buildingHeight = fh1 + (fhO * Math.max(0, floorsAbove - 1)) + 9;
          const mainRoad = inputs.roads.find(r => r.type === 'primary') || inputs.roads[0];
          const roadWidth = mainRoad ? parseFloat(mainRoad.width) : 0;
          const frontYard = parseFloat(inputs.frontYardDepth) || 0;
          const backYard = parseFloat(inputs.backYardDepth) || 0;
          const heightRatio = (roadWidth + frontYard) > 0 ? buildingHeight / (roadWidth + frontYard) : 0;
          const backyardDepthRatio = backYard > 0 ? buildingHeight / backYard : 0;
          const isHighRise = buildingHeight > 24;
          const isSuperHighRise = buildingHeight > 100;
          const weiLaoRatio = (0.5 * roadWidth + frontYard) > 0 ? 5 / (0.5 * roadWidth + frontYard) : 0;

          return { base, maxBuildingArea, statutoryFA, exempt15, exemptStair, exemptIndoor, balcony, permittedIndoor, roofProtrusion, basementAreaPerFloor, totalBasementArea, totalCFA, efficiency, statutoryParking, possibleParking, calculatedFloors, floorsAbove, estimatedBudget, buildingHeight, heightRatio, backyardDepthRatio, isHighRise, isSuperHighRise, weiLaoRatio };
        }, [inputs, totalBaseArea, params]);

        const finalRes = { ...results, ...overrides };
        const handleInputChange = (e) => { const { name, value } = e.target; setInputs(prev => ({ ...prev, [name]: value })); };
        const handleOverride = (id, value) => { const val = parseFloat(value); if (!isNaN(val)) setOverrides(prev => ({ ...prev, [id]: val })); };
        const handleParamChange = (key, value) => { setParams(prev => ({ ...prev, [key]: parseFloat(value) || 0 })); };
        const updateBaseDim = (key, val) => { setInputs(prev => ({ ...prev, [key]: val })); };
        const inputClass = "w-full p-2 border border-stone-200 rounded-md outline-none transition-all focus:border-indigo-500 focus:ring-4 focus:ring-indigo-500/10 text-stone-700 text-sm num-font";
        const labelClass = "block text-sm font-bold text-stone-500 uppercase mb-1";

        return (
          <div className="min-h-screen bg-stone-50 p-4 md:p-8 text-stone-800">
            <div className="max-w-7xl mx-auto space-y-6">
              <header className="flex flex-col md:flex-row justify-between items-start md:items-center bg-white p-6 rounded-xl shadow-sm border border-stone-200">
                <div><h1 className="text-3xl font-serif font-bold flex items-center gap-3 text-stone-800"><Building2 className="text-stone-600" size={32} />自地自建評估計算書</h1><p className="text-stone-500 font-medium mt-1 ml-1">基地開發效益評估 / 容積獎勵檢討 / 停車空間規劃</p></div>
                <div className="flex items-center gap-4 mt-4 md:mt-0"><div className="flex flex-col mr-4"><label className="text-xs text-stone-400 font-bold uppercase">專案名稱</label><input type="text" name="projectName" value={inputs.projectName} onChange={handleInputChange} placeholder="輸入專案名稱" className="border-b border-stone-300 focus:border-stone-800 outline-none bg-transparent py-1 text-lg font-bold text-stone-800" /></div><button onClick={() => setIsEditMode(!isEditMode)} className={`w-12 h-12 flex items-center justify-center rounded-full transition-all duration-300 shadow-sm border ${isEditMode ? 'bg-stone-800 border-stone-800 text-white' : 'bg-white border-stone-200 text-stone-400 hover:border-stone-400'}`}>{isEditMode ? <Settings2 size={20} /> : <Pencil className="w-6 h-6" />}</button></div>
              </header>
              <Visualizer3D inputs={{...inputs, baseArea: totalBaseArea, floorsAbove: finalRes.floorsAbove}} res={finalRes} onUpdateBaseDim={updateBaseDim} />
              <div className="grid grid-cols-1 xl:grid-cols-3 gap-6">
                <CollapsibleSection title="基本資料" icon={<MapPin size={18} className="text-rose-500" />} className="xl:col-span-1">
                  <div className="space-y-3">
                    <div><label className={labelClass}>行政區</label><input type="text" name="district" value={inputs.district} onChange={handleInputChange} className={inputClass} /></div>
                    <div className="space-y-2"><div className="flex justify-between items-center"><label className={labelClass}>地號與面積 (㎡)</label><button onClick={addLot} className="text-indigo-500 hover:text-indigo-700 text-sm flex items-center gap-1"><Plus size={12} /> 新增</button></div><div className="max-h-40 overflow-y-auto pr-1 space-y-2">{lots.map(l => (<div key={l.id} className="flex gap-2 items-center group"><input type="text" placeholder="地號" value={l.lot} onChange={(e) => updateLot(l.id, 'lot', e.target.value)} className={`${inputClass} text-sm`} /><input type="number" placeholder="面積" value={l.area} onChange={(e) => updateLot(l.id, 'area', e.target.value)} className={`${inputClass} text-sm w-24 text-right`} />{lots.length > 1 && <button onClick={() => removeLot(l.id)} className="text-stone-300 hover:text-rose-500"><Trash2 size={14} /></button>}</div>))}</div><div className="text-right text-sm font-bold text-stone-500 pt-1 border-t">合計: {formatNum(totalBaseArea)} ㎡ ({formatNum(toPing(totalBaseArea))} 坪)</div></div>
                    <div className="space-y-3 mt-4 pt-4 border-t border-stone-100"><div className="flex justify-between items-center"><label className={labelClass}>臨路狀況與方位</label><button onClick={addRoad} className="text-indigo-500 hover:text-indigo-700 text-sm flex items-center gap-1"><Plus size={12} /> 新增道路</button></div><div className="space-y-2"><div className="grid grid-cols-12 gap-2 text-xs text-stone-400 font-bold mb-1 px-1"><div className="col-span-4">路名</div><div className="col-span-2 text-center">寬(M)</div><div className="col-span-3">方位</div><div className="col-span-2 text-center">主要</div><div className="col-span-1"></div></div><div className="max-h-40 overflow-y-auto pr-1 space-y-2">{inputs.roads.map(r => (<div key={r.id} className="grid grid-cols-12 gap-2 items-center bg-stone-50 p-2 rounded border border-stone-100"><div className="col-span-4"><input type="text" value={r.name} onChange={(e) => updateRoad(r.id, 'name', e.target.value)} className={`${inputClass} py-1 text-sm`} placeholder="路名"/></div><div className="col-span-2"><input type="number" value={r.width} onChange={(e) => updateRoad(r.id, 'width', e.target.value)} className={`${inputClass} py-1 text-sm text-center`} placeholder="M"/></div><div className="col-span-3"><select value={r.orientation} onChange={(e) => updateRoad(r.id, 'orientation', e.target.value)} className={`${inputClass} py-1 text-xs px-1`}><option value="top">上方</option><option value="bottom">下方</option><option value="left">左側</option><option value="right">右側</option></select></div><div className="col-span-2 flex justify-center"><input type="checkbox" checked={r.type === 'primary'} onChange={(e) => updateRoad(r.id, 'type', e.target.checked ? 'primary' : 'secondary')} className="w-4 h-4 rounded border-stone-300 text-indigo-600 focus:ring-indigo-500 cursor-pointer"/></div><div className="col-span-1 text-center">{inputs.roads.length > 1 && <button onClick={() => removeRoad(r.id)} className="text-stone-300 hover:text-rose-500"><Trash2 size={14} /></button>}</div></div>))}</div></div></div>
                    <div className="mt-4 pt-4 border-t border-stone-100"><div className="flex justify-between items-center mb-2"><h4 className="text-xs font-bold text-stone-500 uppercase flex items-center gap-1"><Ruler size={12} /> 基地形狀設定 (3D)</h4></div><div className="grid grid-cols-2 gap-2"><div><label className="text-[10px] text-stone-400 block">面寬 (Width)</label><input type="number" value={inputs.baseWidth || Math.sqrt(totalBaseArea || 100).toFixed(1)} onChange={(e) => updateBaseDim('baseWidth', e.target.value)} className="w-full border border-stone-200 rounded p-1 text-sm font-bold text-stone-700 bg-stone-50 focus:bg-white focus:ring-2 ring-indigo-100 outline-none num-font" /></div><div><label className="text-[10px] text-stone-400 block">深度 (Depth)</label><input type="number" value={((totalBaseArea || 100) / (parseFloat(inputs.baseWidth) || Math.sqrt(totalBaseArea || 100))).toFixed(1)} onChange={(e) => { const val = parseFloat(e.target.value); if (val > 0 && totalBaseArea > 0) updateBaseDim('baseWidth', (totalBaseArea/val).toFixed(2)); }} className="w-full border border-stone-200 rounded p-1 text-sm font-bold text-stone-700 bg-stone-50 focus:bg-white focus:ring-2 ring-indigo-100 outline-none num-font" /></div></div></div>
                  </div>
                </CollapsibleSection>
                <CollapsibleSection title="法規參數" icon={<FileText size={18} className="text-sky-500" />} className="xl:col-span-1">
                  <div className="space-y-3">
                    <div><label className={labelClass}>使用分區</label><input type="text" name="zoneType" value={inputs.zoneType} onChange={handleInputChange} className={inputClass} /></div>
                    <div><label className={labelClass}>都市計畫名稱</label><input type="text" name="urbanPlanName" value={inputs.urbanPlanName} onChange={handleInputChange} className={inputClass} /></div>
                    <div className="grid grid-cols-2 gap-3"><div><label className={`${labelClass} text-sky-600`}>建蔽率 (%)</label><input type="number" name="coverageRatio" value={inputs.coverageRatio} onChange={handleInputChange} className={`${inputClass} font-bold text-sky-700`} /></div><div><label className={`${labelClass} text-sky-600`}>容積率 (%)</label><input type="number" name="floorRatio" value={inputs.floorRatio} onChange={handleInputChange} className={`${inputClass} font-bold text-sky-700`} /></div></div>
                    <div><label className={`${labelClass} text-amber-600`}>地下室開挖率 (%)</label><input type="number" name="excavationRatio" value={inputs.excavationRatio} onChange={handleInputChange} className={`${inputClass} text-amber-700`} /></div>
                  </div>
                </CollapsibleSection>
                <CollapsibleSection title="樓層規劃" icon={<Layers size={18} className="text-indigo-500" />} className="xl:col-span-1">
                  <div className="space-y-3">
                    <div className="grid grid-cols-2 gap-3"><div><label className={labelClass}>地上樓層數 (預估)</label><div className={`${inputClass} bg-stone-50 font-bold text-indigo-600 flex items-center justify-between`}><span>{finalRes.floorsAbove}F</span><span className="text-xs text-stone-400 font-normal">(C8/A2={formatNum(finalRes.calculatedFloors)})</span></div></div><div><label className={labelClass}>地下樓層數</label><input type="number" name="floorsBelow" value={inputs.floorsBelow} onChange={handleInputChange} className={inputClass} /></div></div>
                    <div><label className={labelClass}>允建總樓地板面積 (Total CFA)</label><div className={`${inputClass} bg-stone-50 text-xl font-bold text-right flex items-center justify-between text-indigo-800`}><span className="text-xs text-indigo-300 font-normal">Auto Calc</span>{formatNum(finalRes.totalCFA)}</div></div>
                  </div>
                </CollapsibleSection>
              </div>
              <div className="bg-white rounded-xl shadow-sm overflow-hidden border border-stone-200">
                <div className="p-4 bg-stone-100 border-b border-stone-200 flex justify-between items-center cursor-pointer hover:bg-stone-100 transition-colors" onClick={() => setShowDetail(!showDetail)}><h3 className="font-bold text-stone-700 flex items-center gap-2"><FileText size={18} /> 詳細計算表</h3><div className="text-stone-500">{showDetail ? <ChevronUp size={20} /> : <ChevronDown size={20} />}</div></div>
                <div className={`transition-all duration-500 ease-in-out overflow-hidden ${showDetail ? 'max-h-[2500px] opacity-100' : 'max-h-0 opacity-0'}`}>
                   <div className="overflow-x-auto">
                      <table className="w-full text-left border-collapse num-font">
                         <thead><tr className="bg-stone-50 text-stone-600 text-sm border-b border-stone-300"><th className="p-4 w-1/4">評估項目</th><th className="p-4 w-1/6 text-right">數值/面積 (㎡)</th><th className="p-4 w-1/6 text-right">坪數 (坪)</th>{isEditMode && <><th className="p-4 text-indigo-700 bg-indigo-50/50 w-1/4">參數設定</th><th className="p-4 text-indigo-700 bg-indigo-50/50">註解與說明</th></>}</tr></thead>
                         <tbody className="text-stone-700 divide-y divide-stone-100">
                            <SectionHeader title="A. 基地基礎法規檢討" />
                            <InputRow id="base" label="1. 基地面積" value={finalRes.base} calculatedValue={results.base} formula="SUM(地號面積)" note="多筆地號加總" isEditMode={isEditMode} onOverride={handleOverride} />
                            <InputRow id="maxBuildingArea" label="2. 允建建築面積" value={finalRes.maxBuildingArea} calculatedValue={results.maxBuildingArea} formula="基地面積 × 法定建蔽率" note={`建蔽率 ${inputs.coverageRatio}%，單層最大面積`} isEditMode={isEditMode} onOverride={handleOverride} highlight />
                            <InputRow id="statutoryFA" label="3. 法定容積 (FA)" value={finalRes.statutoryFA} calculatedValue={results.statutoryFA} formula="基地面積 × 法定容積率" note={`容積率 ${inputs.floorRatio}%，不含獎勵`} isEditMode={isEditMode} onOverride={handleOverride} highlight />
                            <SectionHeader title="B. 免計容積與獎勵試算" />
                            <InputRow id="incentiveArea" label="4. 獎勵容積" value={inputs.incentiveArea} calculatedValue={inputs.incentiveArea} formula="自行輸入" note="都更、危老等獎勵" isEditMode={isEditMode} onOverride={handleInputChange} />
                            <InputRow id="transferArea" label="5. 移轉容積" value={inputs.transferArea} calculatedValue={inputs.transferArea} formula="自行輸入" note="容積移轉" isEditMode={isEditMode} onOverride={handleInputChange} />
                            <InputRow id="exempt15" label={`6. 免計容積 (${params.exemptRate}%)`} value={finalRes.exempt15} calculatedValue={results.exempt15} formula="法定容積 FA × 免計率" note="機電設備、安全梯等 (法規上限)" isEditMode={isEditMode} onOverride={handleOverride} paramKey="exemptRate" paramValue={params.exemptRate} onParamChange={handleParamChange} />
                            <InputRow id="exemptStair" label="7. 免計梯廳" value={finalRes.exemptStair} calculatedValue={results.exemptStair} formula={`法定容積 FA × ${params.stairRate}%`} note="梯廳獎勵，需視設計而定" isEditMode={isEditMode} onOverride={handleOverride} paramKey="stairRate" paramValue={params.stairRate} onParamChange={handleParamChange} />
                            <InputRow id="exemptIndoor" label="8. 免計容積室內合計" value={finalRes.exemptIndoor} calculatedValue={results.exemptIndoor} formula="Item 6 + Item 7" note="免計容積總和" isEditMode={isEditMode} onOverride={handleOverride} subTotal />
                            <InputRow id="balcony" label="9. 免計容積陽台" value={finalRes.balcony} calculatedValue={results.balcony} formula={`法定容積 FA × ${params.balconyRate}%`} note="每層樓地板 1/8 或 FA 10%" isEditMode={isEditMode} onOverride={handleOverride} paramKey="balconyRate" paramValue={params.balconyRate} onParamChange={handleParamChange} />
                            <SectionHeader title="C. 允建面積總表" />
                            <InputRow id="permittedIndoor" label="10. 允建室內面積" value={finalRes.permittedIndoor} calculatedValue={results.permittedIndoor} formula="法定 + 獎勵 + 移轉 + 免計" note="不含陽台之室內實際使用空間" isEditMode={isEditMode} onOverride={handleOverride} bold />
                            <InputRow id="roofProtrusion" label="11. 允建屋突面積" value={finalRes.roofProtrusion} calculatedValue={results.roofProtrusion} formula="(建築面積 × 1/8) × 2層" note="屋頂突出物 (水箱、電梯機房)" isEditMode={isEditMode} onOverride={handleOverride} />
                            <InputRow id="totalBasementArea" label="12. 地下室總面積" value={finalRes.totalBasementArea} calculatedValue={results.totalBasementArea} formula="基地 × 開挖率 × 地下層數" note={`開挖率 ${inputs.excavationRatio}%，地下 ${inputs.floorsBelow} 層`} isEditMode={isEditMode} onOverride={handleOverride} />
                            <tr className="bg-amber-50 border-y-2 border-amber-200"><td className="p-4 font-bold text-stone-800 text-lg">13. 允建總樓地板面積 (Total CFA)</td><td className="p-4 text-right font-bold text-stone-800 text-lg">{isEditMode ? (<div className="flex items-center justify-end gap-2">{Math.abs(finalRes.totalCFA - results.totalCFA) > 0.01 && <div className="text-red-500 flex items-center text-xs" title="與公式計算值衝突"><AlertTriangle size={14}/></div>}<input type="number" value={finalRes.totalCFA} onChange={(e) => handleOverride('totalCFA', e.target.value)} className="w-24 p-1 text-right border border-stone-300 rounded bg-white"/></div>) : formatNum(finalRes.totalCFA)}</td><td className="p-4 text-right font-bold text-stone-800 text-lg">{formatNum(toPing(finalRes.totalCFA))}</td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-600">允建室內+陽台+屋突+地下室</td><td className="p-4 text-sm text-stone-600">全棟可蓋總面積 (含車位空間)</td></>}</tr>
                            <tr className="bg-stone-100 border-y-2 border-stone-200"><td className="p-4 font-bold text-stone-700 text-lg">工程預算評估</td><td className="p-4 text-right font-bold text-stone-700 text-lg" colSpan={2}><div className="flex items-center justify-end gap-2"><span className="text-sm text-stone-500 font-normal mr-2">單價(萬/坪):</span>{isEditMode ? <input type="number" value={params.pricePerPing} onChange={(e) => handleParamChange('pricePerPing', e.target.value)} className="w-20 p-1 text-right border border-stone-300 rounded bg-white font-bold"/> : <span className="font-bold underline decoration-dotted decoration-stone-400">{params.pricePerPing}</span>}<span className="text-sm text-stone-500 mx-2">=</span><span>{formatNum(finalRes.estimatedBudget)} 萬</span></div></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">Total CFA (坪) × 單價</td><td className="p-4 text-sm text-stone-500">概估造價 (未含設計監造/稅)</td></>}</tr>
                            <SectionHeader title="D. 空間與停車檢討" />
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">12. 地上樓層估算</td><td className="p-4 text-right" colSpan={2}>約 <span className="font-bold text-indigo-600">{formatNum(finalRes.floorsAbove)}</span> 層</td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">C8 / A2</td><td className="p-4 text-sm text-stone-500">允建室內 / 允建建築面積</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">13. 地下層開挖檢討</td><td className="p-4 text-right" colSpan={2}>B1 ~ B{inputs.floorsBelow} (單層 {formatNum(toPing(finalRes.basementAreaPerFloor))} 坪)</td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">基地 × {inputs.excavationRatio}%</td><td className="p-4 text-sm text-stone-500">單層最大開挖面積</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium flex items-center gap-2"><Car size={16}/> 14. 停車空間檢討</td><td className="p-4 text-right" colSpan={2}>法定約 {formatNum(finalRes.statutoryParking)} 部 / 空間可停 {formatNum(finalRes.possibleParking)} 部</td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">總樓地板/150 (法定)</td><td className="p-4 text-sm text-stone-500">空間以每車 {inputs.avgCarArea}m² 預估</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">15. 坪效分析 (倍數)</td><td className="p-4 text-right font-bold text-emerald-600" colSpan={2}>{formatNum(finalRes.efficiency)} 倍</td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">總銷坪 / 基地坪</td><td className="p-4 text-sm text-stone-500">投入 1 坪土地可蓋出的坪數</td></>}</tr>
                            <SectionHeader title="E. 高度比檢討" />
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">16. 前院深度</td><td className="p-4 text-right"><div className="flex items-center justify-end gap-2"><input type="number" name="frontYardDepth" value={inputs.frontYardDepth} onChange={handleInputChange} className="w-20 p-1 text-right border border-stone-300 rounded"/> m</div></td><td className="p-4 text-right text-stone-500"></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">自行輸入</td><td className="p-4 text-sm text-stone-500">3D圖面顯示退縮</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">17. 側院深度</td><td className="p-4 text-right"><div className="flex items-center justify-end gap-2"><select name="sideYardDirection" value={inputs.sideYardDirection} onChange={handleInputChange} className="p-1 border border-stone-300 rounded text-xs bg-stone-50"><option value="right">右側</option><option value="left">左側</option></select><input type="number" name="sideYardDepth" value={inputs.sideYardDepth} onChange={handleInputChange} className="w-20 p-1 text-right border border-stone-300 rounded"/> m</div></td><td className="p-4 text-right text-stone-500"></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">選單邊</td><td className="p-4 text-sm text-stone-500">3D圖面顯示退縮</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">18. 後院深度</td><td className="p-4 text-right"><div className="flex items-center justify-end gap-2"><input type="number" name="backYardDepth" value={inputs.backYardDepth} onChange={handleInputChange} className="w-20 p-1 text-right border border-stone-300 rounded"/> m</div></td><td className="p-4 text-right text-stone-500"></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">自行輸入</td><td className="p-4 text-sm text-stone-500">3D圖面顯示退縮</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">*最小後院深度比</td><td className="p-4 text-right"><div className="flex items-center justify-end gap-2"><input type="number" name="minBackyardDepthRatio" value={inputs.minBackyardDepthRatio || 0} onChange={handleInputChange} className="w-20 p-1 text-right border border-stone-300 rounded"/> <span className="text-xs text-stone-400">H/D</span></div></td><td className="p-4 text-right text-stone-500"></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">檢討用</td><td className="p-4 text-sm text-stone-500">決定後院比斜率</td></>}</tr>
                            <tr className="hover:bg-stone-50"><td className="p-4 pl-8 border-l-4 border-stone-300 font-medium">19. 樓層高度設定</td><td className="p-4 text-right" colSpan={2}><div className="flex flex-col gap-2 items-end"><div className="flex items-center gap-2"><span className="text-xs text-stone-500">1F:</span><input type="number" name="floorHeight1F" value={inputs.floorHeight1F} onChange={handleInputChange} className={`w-16 p-1 text-right border rounded ${inputs.zoneType === '住宅區' && parseFloat(inputs.floorHeight1F) > 4.2 ? 'border-rose-400 bg-rose-50' : 'border-stone-300'}`}/>{inputs.arcadeDepth > 0 && inputs.frontYardDepth == 0 && parseFloat(inputs.floorHeight1F) < 3 && <span className="text-[10px] text-red-500 font-bold bg-red-50 px-1 rounded animate-pulse">騎樓需>3m</span>}</div><div className="flex items-center gap-2"><span className="text-xs text-stone-500">其他:</span><input type="number" name="floorHeightOther" value={inputs.floorHeightOther} onChange={handleInputChange} className={`w-16 p-1 text-right border rounded ${inputs.zoneType === '住宅區' && parseFloat(inputs.floorHeightOther) > 3.6 ? 'border-rose-400 bg-rose-50' : 'border-stone-300'}`}/></div></div></td>{isEditMode && <><td className="p-4 font-mono text-xs text-stone-500">住宅區 1F≤4.2, 其他≤3.6</td><td className="p-4 text-sm text-stone-500">自行輸入 (超限變紅)</td></>}</tr>
                            <InputRow id="buildingHeight" label="20. 建築物高度" value={finalRes.buildingHeight} calculatedValue={finalRes.buildingHeight} formula="1F+(其他×(F-1))+9" note={finalRes.isSuperHighRise ? "超高層建築 (>100m)" : finalRes.isHighRise ? "高層建築 (>24m)" : "一般建築"} isEditMode={isEditMode} onOverride={handleOverride} highlight />
                            <InputRow id="heightRatio" label="21. 高度比" value={finalRes.heightRatio} calculatedValue={finalRes.heightRatio} formula="高度 / (路寬+前院)" note="建築高度 / (主路寬+前院深)" isEditMode={isEditMode} onOverride={handleOverride} highlight />
                            <InputRow id="backyardDepthRatio" label="22. 後院深度比" value={finalRes.backyardDepthRatio} calculatedValue={finalRes.backyardDepthRatio} formula="高度 / 後院深" note="建築高度 / 後院深" isEditMode={isEditMode} onOverride={handleOverride} highlight />
                            <InputRow id="weiLaoRatio" label="23. 危老評估 (路心比)" value={finalRes.weiLaoRatio} calculatedValue={finalRes.weiLaoRatio} formula="5 / (0.5×路寬 + 前院)" note="危老條例高度檢討係數" isEditMode={isEditMode} onOverride={handleOverride} highlight />
                            {inputs.frontYardDepth == 0 && (<tr className="hover:bg-indigo-50/30 border-t-2 border-indigo-100"><td className="p-4 pl-8 border-l-4 border-indigo-400 font-bold text-indigo-700">24. 騎樓深度</td><td className="p-4 text-right"><div className="flex items-center justify-end gap-2"><input type="number" name="arcadeDepth" value={inputs.arcadeDepth} onChange={handleInputChange} className="w-20 p-1 text-right border border-indigo-300 rounded font-bold text-indigo-600 bg-white"/> m</div></td><td className="p-4 text-right text-stone-500"></td>{isEditMode && <><td className="p-4 font-mono text-xs text-indigo-500">僅當前院=0時可用</td><td className="p-4 text-sm text-indigo-500">設定後1F自動退縮，樓高需>3m</td></>}</tr>)}
                         </tbody>
                      </table>
                   </div>
                </div>
              </div>

            </div>
          </div>
        );
      };

      const root = createRoot(document.getElementById('root'));
      root.render(<Cal />);
    </script>
  </body>
</html>